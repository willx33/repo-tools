{% extends "base.html" %}

{% block title %}XML Parser - Repo Tools{% endblock %}

{% block content %}
<div class="page-header">
  <h2>üìù XML Parser</h2>
  <p>Parse XML responses apply them to your repository</p>
</div>

<div class="workflow-container">
  <div class="workflow-step" id="step-1">
    <h3>üîç Step 1: Select Path</h3>
    <div class="form-group">
      <label for="path-select">Choose a path to search for repositories:</label>
      <div class="path-input-container">
      <select id="path-select" class="select-dark"></select>
        <input 
          type="text" 
          id="path-input" 
          class="path-input hidden" 
          placeholder="Enter a path to search for repositories"
                    style="padding: 0.8rem;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-size: 14px;
        width: 100%; outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2); margin-bottom: 1rem"
                  >
                </div>
      <div class="button-group">
        <button id="scan-btn" class="btn">Scan Path for Repositories</button>
        <button id="edit-path-button" class="btn btn-orange">Edit Path</button>
        <button id="browse-button" class="btn btn-blue">Select from File Explorer</button>
        <input type="file" id="directory-input" webkitdirectory directory multiple style="display: none;" />
      </div>
    </div>
    <div id="custom-path" class="custom-path hidden">
      <div class="path-header" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
        <p class="selected-path-label" style="margin: 0; flex: 1;">Selected directory:</p>
        <button id="clear-path-button" title="Clear selection" style="background: none; border: none; color: #f44336; cursor: pointer; font-size: 1.2rem; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.2s; margin-left: 10px;">√ó</button>
      </div>
      <p id="selected-path-display" class="selected-path"></p>
      <p class="path-info">Any git repositories inside this directory will be detected and processed.</p>
      <div class="button-group hidden" id="proceed-to-step2">
        <button id="continue-button" class="btn btn-primary">Continue to Repository Selection</button>
      </div>
    </div>
    <div id="path-loading" class="loading-indicator hidden">
      <div class="spinner"></div>
      <p>Scanning for repositories...</p>
    </div>
  </div>

  <div class="workflow-step hidden" id="step-2">
    <h3>üìã Step 2: Select Repository</h3>
    
    <div class="repo-controls" style="display: flex; align-items: center; justify-content: space-between; gap: 10px; width: 100%; margin-bottom: 16px;">
      <!-- Search Bar Container -->
      <div class="repo-search" style="position: relative; flex: 1; display: flex; align-items: center;">
        <span class="repo-search-icon" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); font-size: 14px; z-index: 1; pointer-events: none;">üîç</span>
        <input
          type="text"
          id="repo-search-input"
          class="repo-search-input"
          placeholder="Find a repository..."
          style="width: 100%; padding: 4px 30px 4px 30px; height: 36px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: var(--text-primary); font-size: 14px; box-sizing: border-box;"
        >
        <button id="repo-search-clear" class="repo-search-clear" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; z-index: 1; padding: 0; margin: 0; display: flex; align-items: center; justify-content: center; height: 24px; width: 24px;">√ó</button>
      </div>
      
      <!-- Sort Dropdown Container -->
      <div class="repo-sort" style="flex: 0 0 auto; display: flex; align-items: center; gap: 8px; white-space: nowrap;">
        <span style="margin: 0; padding: 0; font-size: 14px; color: var(--text-secondary); position: relative; top: 2px;">Sort by:</span>
        <select id="repo-sort-select" class="select-dark" style="width: auto; min-width: 120px; max-width: 150px; padding: 4px 8px; height: 30px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: var(--text-primary); font-size: 14px; appearance: auto; box-sizing: border-box; margin: 0;">
          <option value="default">Default</option>
          <option value="name-asc">Name (A-Z)</option>
          <option value="name-desc">Name (Z-A)</option>
        </select>    
      </div>
    </div>
    
    <div class="form-group">
      <label>Select a repository:</label>
      <div id="repo-checklist" class="repo-checklist">
        <!-- Repositories will be populated here as radio buttons -->
      </div>
      <div id="repo-loading" class="loading-indicator hidden">
        <div class="spinner"></div>
        <p>Loading repositories...</p>
      </div>
      <div class="button-group">
        <button id="back-to-step1-btn" class="btn btn-secondary">Back</button>
      </div>
    </div>
  </div>

  <div class="workflow-step hidden" id="step-3">
    <h3>üìä Step 3: Paste and Apply XML</h3>
    
    <div id="repo-info" class="summary-box">
      <div class="summary-header">
        <h4 id="repo-name">Repository: <span></span></h4>
        <p id="repo-path">Path: <span></span></p>
      </div>
    </div>
    
    <div class="form-group">
      <label for="xml-input">Paste XML:</label>
      <textarea 
        id="xml-input" 
        class="select-dark" 
        style="height: 200px; font-family: monospace; resize: vertical;"
        placeholder="Paste the <code_changes>...</code_changes> XML here"
      ></textarea>
    </div>
    
    <div class="button-group">
      <button id="parse-btn" class="btn btn-info">Preview Changes</button>
      <button id="apply-btn" class="btn btn-primary" disabled>Apply Changes</button>
      <button id="back-to-step2-btn" class="btn btn-secondary">Back</button>
    </div>
    
    <div id="preview-container" class="summary-box hidden">
      <div class="summary-header">
        <h4>Preview of Changes</h4>
        <span id="change-count" class="count-badge">0 changes</span>
      </div>
      <div id="preview-list" class="file-list">
        <!-- File changes will be listed here -->
      </div>
    </div>
    
    <div id="results-container" class="summary-box hidden">
      <div class="summary-header">
        <h4>Results</h4>
        <span id="results-count" class="count-badge"><span id="success-count">0</span> of <span id="total-count">0</span> changes applied</span>
      </div>
      <div id="results-list" class="file-list">
        <!-- Results will be listed here -->
      </div>
    </div>
  </div>
</div>

<div id="notification" class="notification hidden">
  <div class="notification-content">
    <span id="notification-message"></span>
    <span class="notification-close">&times;</span>
  </div>
</div>
{% endblock %}

{% block styles %}
<style>
  :root {
    --bg-primary: #121212;
    --bg-secondary: #1e1e1e;
    --bg-tertiary: #2d2d2d;
    --text-primary: #ffffff;
    --text-secondary: #b3b3b3;
    --accent-color: #4caf50;
    --accent-hover: #3d8b40;
    --error-color: #f44336;
    --warning-color: #ff9800;
    --info-color: #2196f3;
    --success-color: #4caf50;
    --border-color: #333333;
    --shadow-color: rgba(0, 0, 0, 0.3);
  }

  /* Path input container for dropdown and text input */
  .path-input-container {
    display: flex;
    margin-bottom: 16px;
    align-items: center;
    gap: 10px;
  }
  
  .path-input-container select, 
  .path-input-container input {
    flex: 1;
  }
  
  .path-input {
    padding: 0.8rem !important;
    background-color: var(--bg-secondary) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px !important;
    color: var(--text-primary) !important;
    font-size: 15px !important;
    width: 100% !important;
    height: 40px !important;
    flex: 1 !important;
  }

  .path-input-focused {
    padding: 0.8rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--accent-color);
    border-radius: 4px;
    color: var(--text-primary);
    font-size: 15px;
    width: 100%;
    height: 40px;
    flex: 1;
    margin-bottom: 1rem;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    outline: none;
  }
  
  .path-input:focus {
    outline: none !important;
    border-color: var(--accent-color) !important;
    box-shadow: 0 0 0 2px var(--accent-color-transparent) !important;
  }

  /* Add CSS style for disabled/readonly inputs */
  .disabled-input {
    opacity: 0.6;
    cursor: not-allowed;
    background-color: rgba(0, 0, 0, 0.1);
  }
  
  /* Path info and related styles */
  .path-info {
    margin-top: 8px;
    font-size: 14px;
    color: #68b5e1;
    font-style: italic;
  }
  
  /* Path header style */
  .path-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  /* Clear path button - red with no background */
  .clear-path-btn {
    background: none;
    border: none;
    color: #f44336;
    cursor: pointer;
    font-size: 1.2rem;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    margin-left: auto;
  }
  
  .clear-path-btn:hover {
    color: #d32f2f;
    transform: scale(1.1);
  }
  
  /* Disabled button styles */
  .btn:disabled, .btn.disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Custom path display */
  .custom-path {
    background-color: rgba(255, 255, 255, 0.05);
    padding: 12px;
    border-radius: 4px;
    margin-bottom: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .selected-path-label {
    margin: 0;
    color: var(--text-secondary);
    font-size: 14px;
  }
  
  .selected-path {
    margin: 5px 0 0 0;
    font-weight: 500;
    color: var(--text-primary);
    font-size: 16px;
    word-break: break-all;
  }

  /* Button colors */
  .btn-orange {
    background-color: #ff9800;
    color: white;
  }
  
  .btn-orange:hover {
    background-color: #f57c00;
  }
  
  .btn-blue {
    background-color: #2196f3;
    color: white;
  }
  
  .btn-blue:hover {
    background-color: #1976d2;
  }

  /* Aggressive override for repo-controls to force same-line display */
  .repo-controls {
    display: flex !important;
    align-items: center !important;
    justify-content: flex-start !important;
    gap: 10px !important;
    width: 100%;
    flex-wrap: nowrap;
  }

  /* Increase the search bar size */
  .repo-search {
    position: relative;
    flex: 1;
    display: flex;
    align-items: center;
  }
  
  .repo-search-icon {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-secondary);
    font-size: 14px;
    z-index: 1;
    pointer-events: none;
  }
  
  .repo-search-input {
    width: 100% !important;
    min-width: 250px !important;
    padding: 4px 30px 4px 30px !important;
    height: 36px !important;
    border-radius: 4px !important;
    background-color: rgba(255, 255, 255, 0.1) !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    color: var(--text-primary) !important;
    font-size: 14px !important;
    box-sizing: border-box !important;
  }
  
  .repo-search-clear {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 16px;
    z-index: 1;
    padding: 0;
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 24px;
    width: 24px;
  }
  
  /* Force sort control to auto-size and remain compact */
  .repo-sort {
    flex: 0 0 auto !important;
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    white-space: nowrap !important;
    height: 36px !important;
  }
  
  .repo-sort label {
    margin: 0;
    font-size: 14px;
    line-height: 36px;
    color: var(--text-secondary);
  }
  
  .repo-sort select {
    width: auto !important;
    min-width: 120px !important;
    max-width: 150px !important;
    padding: 4px 8px !important;
    height: 30px !important;
    border-radius: 4px !important;
    background-color: rgba(255, 255, 255, 0.1) !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    color: var(--text-primary) !important;
    font-size: 14px !important;
    appearance: auto !important;
    box-sizing: border-box !important;
  }
  
  .repo-sort select option {
    background-color: #252525;
    color: var(--text-primary);
  }

  /* The rest of the styles remain unchanged */
  .repo-checklist {
    max-height: 300px;
    overflow-y: auto;
    background-color: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 1rem;
  }
  
  #repo-search-input {
    max-width: 100%;
  }
  
  .repo-checkbox-item {
    padding: 0.8rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
  }
  
  .repo-checkbox-item:last-child {
    border-bottom: none;
  }
  
  .repo-checkbox-item label {
    display: flex;
    align-items: center;
    cursor: pointer;
    flex: 1;
    margin-bottom: 0;
  }
  
  .repo-checkbox-item input[type="radio"] {
    margin-right: 10px;
    cursor: pointer;
    flex-shrink: 0;
  }
  
  .repo-name {
    font-weight: 500;
    margin-right: 10px;
  }
  
  .repo-path {
    font-size: 0.9rem;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .repo-checkbox-item:hover {
    background-color: rgba(255, 255, 255, 0.05);
  }
  
  .badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.8rem;
    text-transform: uppercase;
    font-weight: bold;
    margin-right: 8px;
  }
  
  .badge.create {
    background-color: rgba(40, 167, 69, 0.2);
    color: #28a745;
  }
  
  .badge.update {
    background-color: rgba(0, 123, 255, 0.2);
    color: #007bff;
  }
  
  .badge.delete {
    background-color: rgba(220, 53, 69, 0.2);
    color: #dc3545;
  }
  
  .count-badge {
    color: rgba(255, 255, 255, 0.8);
    font-size: 14px;
    background-color: rgba(60, 60, 60, 0.6);
    padding: 2px 8px;
    border-radius: 4px;
    margin-left: 8px;
  }
  
  .file-item {
    padding: 10px;
    margin-bottom: 8px;
    background-color: var(--bg-tertiary);
    border-radius: 4px;
    border: 1px solid var(--border-color);
  }
  
  .file-item.success {
    border-left: 3px solid #28a745;
  }
  
  .file-item.error {
    border-left: 3px solid #dc3545;
  }
  
  .file-header {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
  }
  
  .file-path {
    font-family: monospace;
    word-break: break-all;
  }
  
  .file-status {
    font-size: 0.9rem;
    color: var(--text-secondary);
  }
  
  .file-warning {
    font-size: 0.9rem;
    color: #ffc107;
    margin-top: 4px;
  }
  
  .file-error {
    font-size: 0.9rem;
    color: #dc3545;
    margin-top: 4px;
  }
  
  .status-icon {
    margin-right: 6px;
  }
  
  #repo-info {
    margin-bottom: 1.5rem;
  }
  
  #repo-info h4 {
    margin-top: 0;
    margin-bottom: 0.5rem;
  }
  
  #repo-info p {
    margin: 0;
    color: var(--text-secondary);
    font-size: 0.9rem;
  }
  
  .no-repos {
    text-align: center;
    padding: 1rem;
    color: var(--text-secondary);
  }
  
  .notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
    max-width: 400px;
    transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
    transform: translateY(0);
    opacity: 1;
  }
  
  .notification.hidden {
    transform: translateY(100px);
    opacity: 0;
    pointer-events: none;
  }
  
  .notification-content {
    padding: 12px 16px;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background-color: #333;
    color: white;
  }
  
  .notification-success .notification-content {
    background-color: rgba(40, 167, 69, 0.9);
  }
  
  .notification-error .notification-content {
    background-color: rgba(220, 53, 69, 0.9);
  }
  
  .notification-warning .notification-content {
    background-color: rgba(255, 193, 7, 0.9);
    color: #212529;
  }
  
  .notification-close {
    margin-left: 10px;
    cursor: pointer;
    font-size: 20px;
    line-height: 1;
  }
  
  .summary-box {
    background-color: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    margin-bottom: 1.5rem;
    overflow: hidden;
  }
  
  .summary-header {
    padding: 12px 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background-color: rgba(0, 0, 0, 0.1);
  }
  
  .summary-header h4 {
    margin: 0;
    font-size: 1rem;
    font-weight: 500;
  }
  
  .file-list {
    padding: 16px;
    max-height: 400px;
    overflow-y: auto;
  }

  /* Select dropdown styling */
  .select-dark {
    background-color: var(--bg-tertiary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    padding: 0.8rem;
    border-radius: 4px;
    cursor: pointer;
    outline: none;
    min-width: 150px;
    height: 40px;
    box-sizing: border-box;
    font-size: 15px;
  }
  
  .select-dark option {
    background-color: var(--bg-secondary);
  }
</style>
{% endblock %}

{% block scripts %}
<script>
  // State variables
  let repositories = [];
  let selectedRepository = null;
  let isEditMode = false;
  
  // DOM Elements
  const step1 = document.getElementById('step-1');
  const step2 = document.getElementById('step-2');
  const step3 = document.getElementById('step-3');
  
  const pathSelect = document.getElementById('path-select');
  const pathInput = document.getElementById('path-input');
  const scanBtn = document.getElementById('scan-btn');
  const editPathButton = document.getElementById('edit-path-button');
  const browseButton = document.getElementById('browse-button');
  const directoryInput = document.getElementById('directory-input');
  const clearPathButton = document.getElementById('clear-path-button');
  const customPath = document.getElementById('custom-path');
  const selectedPathDisplay = document.getElementById('selected-path-display');
  const pathLoading = document.getElementById('path-loading');
  
  const repoChecklist = document.getElementById('repo-checklist');
  const repoLoading = document.getElementById('repo-loading');
  const backToStep1Btn = document.getElementById('back-to-step1-btn');
  
  const repoNameEl = document.querySelector('#repo-name span');
  const repoPathEl = document.querySelector('#repo-path span');
  const xmlInput = document.getElementById('xml-input');
  const parseBtn = document.getElementById('parse-btn');
  const applyBtn = document.getElementById('apply-btn');
  const backToStep2Btn = document.getElementById('back-to-step2-btn');
  
  const previewContainer = document.getElementById('preview-container');
  const previewList = document.getElementById('preview-list');
  const changeCountEl = document.getElementById('change-count');
  
  const resultsContainer = document.getElementById('results-container');
  const resultsListEl = document.getElementById('results-list');
  const successCountEl = document.getElementById('success-count');
  const totalCountEl = document.getElementById('total-count');
  
  // Search and sort
  const repoSearchInput = document.getElementById('repo-search-input');
  const repoSearchClear = document.getElementById('repo-search-clear');
  const repoSortSelect = document.getElementById('repo-sort-select');
  
  // Initialize Socket.IO
  const socket = io();
  
  // Socket.IO event handlers
  socket.on('connect', () => {
    console.log('Connected to server');
  });
  
  socket.on('error', (data) => {
    showNotification(data.message, 'error');
  });
  
  // XML Parser socket events
  socket.on('xml_parse_start', (data) => {
    previewContainer.classList.add('hidden');
    resultsContainer.classList.add('hidden');
    parseBtn.disabled = true;
    parseBtn.textContent = 'Parsing...';
  });
  
  socket.on('xml_parse_complete', (data) => {
    parseBtn.disabled = false;
    parseBtn.textContent = 'Preview Changes';
    
    if (data.success) {
      // Store parsed changes for apply
      window.lastParsedChanges = data.changes;
      
      renderPreview(data.changes);
      changeCountEl.textContent = `${data.changeCount} changes`;
      previewContainer.classList.remove('hidden');
      
      if (data.changeCount > 0) {
        applyBtn.disabled = false;
        showNotification(`Found ${data.changeCount} changes to apply`, 'success');
      } else {
        applyBtn.disabled = true;
        showNotification('No changes found in the XML', 'info');
      }
    } else {
      showNotification('Error parsing XML: ' + data.message, 'error');
      applyBtn.disabled = true;
    }
  });
  
  
  socket.on('xml_error', (data) => {
    parseBtn.disabled = false;
    parseBtn.textContent = 'Preview Changes';
    applyBtn.disabled = true;
    applyBtn.textContent = 'Apply Changes';
    showNotification(data.message, 'error');
  });
  
  // Initialize the page
  document.addEventListener('DOMContentLoaded', () => {
    // Initialize notification close buttons
    document.querySelectorAll('.notification-close').forEach(btn => {
      btn.addEventListener('click', closeNotification);
    });
  
    // Fetch path options
    initializeClientFileSelection();
    
    // Event listeners
    scanBtn.addEventListener('click', scanRepositoriesClient);
    parseBtn.addEventListener('click', parseXML);
    applyBtn.addEventListener('click', applyXML);
    backToStep1Btn.addEventListener('click', backToStep1);
    backToStep2Btn.addEventListener('click', backToStep2);
    
    // Search and Sort
    repoSearchInput.addEventListener('input', filterRepositories);
    repoSearchClear.addEventListener('click', () => {
      repoSearchInput.value = '';
      filterRepositories();
    });
    repoSortSelect.addEventListener('change', sortRepositories);
    
    // Path editing functionality
    editPathButton.addEventListener('click', function() {
      if (isEditMode) {
        exitEditMode();
      } else {
        enterEditMode();
      }
    });
    
    // Path input enter key handler
    pathInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        
        // Get entered path
        const enteredPath = pathInput.value.trim();
        
        if (enteredPath) {
          // Check if path exists in dropdown
          let pathExists = false;
          Array.from(pathSelect.options).forEach(option => {
            if (option.value === enteredPath) {
              option.selected = true;
              pathExists = true;
            }
          });
          
          // If path doesn't exist in dropdown, add it
          if (!pathExists) {
            const newOption = document.createElement('option');
            newOption.value = enteredPath;
            newOption.textContent = enteredPath;
            newOption.selected = true;
            pathSelect.appendChild(newOption);
          }
          
          // Exit edit mode
          exitEditMode();
        } else {
          showNotification('Please enter a valid path', 'warning');
        }
      }
    });
    
    // Browse button functionality
    browseButton.addEventListener('click', scanRepositoriesClient);
    
    // Continue button functionality
    document.getElementById('continue-button').addEventListener('click', function() {
      // Hide the continue button and proceed to step 2
      document.getElementById('proceed-to-step2').classList.add('hidden');
      step1.classList.add('hidden');
      step2.classList.remove('hidden');
      step3.classList.add('hidden');
      populateRepositories();
    });
    
    // Directory selection handler
    directoryInput.addEventListener('change', handleDirectorySelection);
    
    // Clear path button functionality
    clearPathButton.addEventListener('click', function() {
      // Hide custom path div
      customPath.classList.add('hidden');
      
      // Reset path display
      selectedPathDisplay.textContent = '';
      
      // Enable the browse and scan buttons again
      browseButton.disabled = false;
      scanBtn.disabled = false;
      
      // Clear any selected repositories that came from the file browser
      if (step2 && !step2.classList.contains('hidden')) {
        // If we're on step 2, go back to step 1
        step2.classList.add('hidden');
        step1.classList.remove('disabled');
      }
      
      // Show notification
      showNotification('Directory selection cleared', 'info');
      
      // Reset the file input
      directoryInput.value = '';
    });
  });
  
  function initializeClientFileSelection() {
    // Hide the path dropdown and show only the browse button
    pathSelect.style.display = 'none';
    editPathButton.style.display = 'none';
    scanBtn.style.display = 'none';
    
    // Update UI for client-side selection
    const label = document.querySelector('label[for="path-select"]');
    if (label) {
      label.textContent = 'Select a folder from your computer:';
    }
    
    // Show browser support message
    const support = FileSystemManager.getBrowserSupport();
    if (support === 'none') {
      showNotification('Directory selection is not supported in your browser. Please use Chrome or Edge.', 'error');
      browseButton.disabled = true;
      browseButton.textContent = 'Not Supported';
    } else if (support === 'partial') {
      browseButton.textContent = 'Select Folder (Limited Support)';
    } else {
      browseButton.textContent = 'Select Folder';
    }
  }
  
  async function scanRepositoriesClient() {
    try {
      // Show loading immediately
      pathLoading.classList.remove('hidden');
      pathLoading.querySelector('p').textContent = 'Scanning for repositories...';
      
      // Use FileSystemManager to select directory
      const result = await FileSystemManager.selectDirectory();
      
      // Store the selected files and directory handle globally
      window.selectedDirectoryFiles = result.files;
      window.selectedDirectoryHandle = result.directoryHandle;
      
      // Update UI to show selected path
      const dirName = result.directoryHandle ? result.directoryHandle.name : 'Selected Folder';
      selectedPathDisplay.textContent = `üìÇ ${dirName}`;
      customPath.classList.remove('hidden');
      
      // Find repositories client-side
      const repos = FileSystemManager.findGitRepositories(result.files);
      
      pathLoading.classList.add('hidden');
      
      if (repos.length === 0) {
        showNotification('No Git repositories found in the selected directory.', 'warning');
        step1.classList.remove('hidden');
        step2.classList.add('hidden');
        return;
      }
      
      // Store repositories and show continue button instead of auto-proceeding
      repositories = repos;
      showNotification(`Found ${repos.length} repositories. Click Continue to select one.`, 'success');
      document.getElementById('proceed-to-step2').classList.remove('hidden');
      
    } catch (error) {
      pathLoading.classList.add('hidden');
      if (error.message.includes('cancelled')) {
        showNotification('Directory selection cancelled.', 'info');
      } else {
        showNotification('Error selecting directory: ' + error.message, 'error');
      }
    }
  }
  
  // Handle repositories found from scanning
  function handleRepos(repos) {
    repositories = repos;
    populateRepositories();
  }
  
  function showLoading(show) {
    if (show) {
      pathLoading.classList.remove('hidden');
      customPath.classList.add('hidden');
    } else {
      pathLoading.classList.add('hidden');
      customPath.classList.remove('hidden');
    }
  }
  
  function populateRepositories() {
    repoChecklist.innerHTML = '';
    
    if (repositories.length === 0) {
      repoChecklist.innerHTML = '<p class="no-repos">No Git repositories found in the selected path.</p>';
      return;
    }
    
    // Sort repositories
    sortRepositories();
  }
  
  function sortRepositories() {
    const sortBy = repoSortSelect.value;
    
    // Clone array to avoid modifying original
    const sortedRepos = [...repositories];
    
    // Sort based on selected option
    if (sortBy === 'name-asc') {
      sortedRepos.sort((a, b) => a.name.localeCompare(b.name));
    } else if (sortBy === 'name-desc') {
      sortedRepos.sort((a, b) => b.name.localeCompare(a.name));
    }
    // Default just uses the order from the backend
    
    // Display sorted repositories
    renderRepositories(sortedRepos);
  }
  
  function filterRepositories() {
    const searchTerm = repoSearchInput.value.toLowerCase().trim();
    
    if (!searchTerm) {
      // If no search term, show all repositories (sorted)
      sortRepositories();
      return;
    }
    
    
    // Filter repositories based on search term
    const filteredRepos = repositories.filter(repo => 
      repo.name.toLowerCase().includes(searchTerm) || 
      repo.path.toLowerCase().includes(searchTerm)
    );
    
    renderRepositories(filteredRepos);
  }
  
  function renderRepositories(repos) {
    repoChecklist.innerHTML = '';
    
    if (repos.length === 0) {
      repoChecklist.innerHTML = '<p class="no-repos">No repositories match your search.</p>';
      return;
    }
    
    repos.forEach(repo => {
      const repoItem = document.createElement('div');
      repoItem.className = 'repo-checkbox-item';
      
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'repository';
      radio.id = `repo-${repo.name}`;
      radio.value = repo.path;
      radio.className = 'repo-radio';
      radio.style.display = 'none';

      
      // Event listener for selecting a repository
      radio.addEventListener('change', () => {
        if (radio.checked) {
          selectedRepository = repo;
          step3.classList.remove('hidden');
          step2.classList.add('hidden');
          repoNameEl.textContent = repo.name;
          repoPathEl.textContent = repo.path;
          previewContainer.classList.add('hidden');
          resultsContainer.classList.add('hidden');
          applyBtn.disabled = true;
          xmlInput.value = '';
        }
      });
      
      const label = document.createElement('label');
      label.className = 'repo-label';
      label.htmlFor = `repo-${repo.name}`;
      
      // Create the repo name display with folder emoji
      const nameSpan = document.createElement('span');
      nameSpan.className = 'repo-name';
      nameSpan.innerHTML = `üìÇ ${repo.name}`;

      // Add elements to label in correct order (only repo name)
      label.appendChild(radio);
      label.appendChild(nameSpan);

      
      repoItem.appendChild(label);
      repoChecklist.appendChild(repoItem);
    });
  }
  
  function parseXML() {
    if (!selectedRepository) {
      showNotification('Please select a repository first', 'warning');
      return;
    }
    
    const xml = xmlInput.value.trim();
    if (!xml) {
      showNotification('Please paste XML content first', 'warning');
      return;
    }
    
    // Clear previous results
    previewContainer.classList.add('hidden');
    resultsContainer.classList.add('hidden');
    
    // Emit socket event to server for parsing
    socket.emit('xml_parse', { 
      xml: xml, 
      repoPath: selectedRepository.path 
    });
  }
  
  function renderPreview(changes) {
    previewList.innerHTML = '';
    
    if (!changes || changes.length === 0) {
      previewList.innerHTML = '<p class="no-repos">No changes detected in the XML.</p>';
      return;
    }
    
    changes.forEach(change => {
      const changeItem = document.createElement('div');
      changeItem.className = 'file-item';
      
      const header = document.createElement('div');
      header.className = 'file-header';
      
      const operationBadge = document.createElement('span');
      operationBadge.className = `badge ${change.operation.toLowerCase()}`;
      operationBadge.textContent = change.operation;
      
      // Apply inline styles directly
      operationBadge.style.display = 'inline-block';
      operationBadge.style.padding = '2px 8px';
      operationBadge.style.borderRadius = '4px';
      operationBadge.style.fontSize = '12px';
      operationBadge.style.fontWeight = '500';
      operationBadge.style.textTransform = 'uppercase';
      operationBadge.style.marginRight = '8px';
      operationBadge.style.color = 'white'; // Default text color

      // Set background color based on operation
      switch (change.operation.toLowerCase()) {
        case 'create':
          operationBadge.style.backgroundColor = '#28a745'; // Solid green
          break;
        case 'update':
          operationBadge.style.backgroundColor = '#007bff'; // Solid blue
          break;
        case 'delete':
          operationBadge.style.backgroundColor = '#dc3545'; // Solid red
          break;
      }
      
      const path = document.createElement('span');
      path.className = 'file-path';
      path.textContent = change.path;
      
      header.appendChild(operationBadge);
      header.appendChild(path);
      changeItem.appendChild(header);
      
      // Add description if present
      if (change.description) {
        const description = document.createElement('div');
        description.className = 'file-status';
        description.textContent = change.description;
        changeItem.appendChild(description);
      }
      
      // Add search pattern if present
      if (change.search) {
        const searchSection = document.createElement('div');
        searchSection.className = 'file-status';
        searchSection.innerHTML = '<strong>Search for:</strong>';
        changeItem.appendChild(searchSection);
        
        const searchContent = document.createElement('pre');
        searchContent.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
        searchContent.style.padding = '8px';
        searchContent.style.marginTop = '4px';
        searchContent.style.borderRadius = '4px';
        searchContent.style.fontSize = '13px';
        searchContent.style.whiteSpace = 'pre-wrap';
        searchContent.textContent = change.search;
        changeItem.appendChild(searchContent);
        
        const replaceSection = document.createElement('div');
        replaceSection.className = 'file-status';
        replaceSection.innerHTML = '<strong>Replace with:</strong>';
        replaceSection.style.marginTop = '8px';
        changeItem.appendChild(replaceSection);
        
        const replaceContent = document.createElement('pre');
        replaceContent.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
        replaceContent.style.padding = '8px';
        replaceContent.style.marginTop = '4px';
        replaceContent.style.borderRadius = '4px';
        replaceContent.style.fontSize = '13px';
        replaceContent.style.whiteSpace = 'pre-wrap';
        replaceContent.textContent = change.content;
        changeItem.appendChild(replaceContent);
      } else {
        // Add status message for simple operations
        const status = document.createElement('div');
        status.className = 'file-status';
        status.textContent = change.status;
        changeItem.appendChild(status);
      }
      
      // Add warning if present
      if (change.warning) {
        const warning = document.createElement('div');
        warning.className = 'file-warning';
        warning.textContent = change.warning;
        changeItem.appendChild(warning);
      }
      
      previewList.appendChild(changeItem);
    });
  }
  
  async function applyXML() {
    if (!selectedRepository) {
      showNotification('Please select a repository first', 'warning');
      return;
    }
    
    const xml = xmlInput.value.trim();
    if (!xml) {
      showNotification('Please paste XML content first', 'warning');
      return;
    }
    
    // Apply changes client-side using the parsed changes from preview
    const changes = window.lastParsedChanges;
    if (!changes || changes.length === 0) {
      showNotification('Please preview changes first', 'warning');
      return;
    }
    
    applyBtn.disabled = true;
    applyBtn.textContent = 'Applying...';
    
    try {
      const results = await applyChangesClientSide(changes);
      
      // Clean up .identifier files if they exist - try immediately and with delay
      await cleanupIdentifierFile();
      
      // Additional cleanup with delay to catch files created after operations
      setTimeout(async () => {
        await cleanupIdentifierFile();
      }, 500);
      
      setTimeout(async () => {
        await cleanupIdentifierFile();
      }, 2000);
      
      // Render results
      renderResults(results);
      const successCount = results.filter(r => r.success).length;
      successCountEl.textContent = successCount;
      totalCountEl.textContent = results.length;
      resultsContainer.classList.remove('hidden');
      
      if (successCount === results.length) {
        showNotification('All changes applied successfully to your local files!', 'success');
      } else {
        showNotification(`${successCount} of ${results.length} changes applied successfully.`, 'warning');
      }
      
    } catch (error) {
      showNotification('Error applying changes: ' + error.message, 'error');
    } finally {
      applyBtn.disabled = false;
      applyBtn.textContent = 'Apply Changes';
    }
  }
  
  // Apply changes to client-side files
  async function applyChangesClientSide(changes) {
    const results = [];
    
    for (const change of changes) {
      const result = {
        operation: change.operation,
        path: change.path,
        success: false,
        error: null,
        message: ''
      };
      
      try {
        // Find the file in the selected directory
        const targetFile = window.selectedDirectoryFiles.find(fileData => {
          const filePath = fileData.path;
          const repoPath = selectedRepository.path;
          
          // Remove repo path prefix and match
          const relativePath = change.path.startsWith(repoPath + '/') 
            ? change.path.substring(repoPath.length + 1)
            : change.path;
            
          return filePath.endsWith(relativePath) || filePath.includes('/' + relativePath);
        });
        
        if (change.operation === 'MODIFY' && change.search) {
          // Handle search and replace
          if (!targetFile) {
            throw new Error(`File not found: ${change.path}`);
          }
          
          const originalContent = await FileSystemManager.readFileContent(targetFile.file);
          
          if (!originalContent.includes(change.search)) {
            throw new Error(`Search pattern not found in file: ${change.path}`);
          }
          
          const newContent = originalContent.replace(change.search, change.content);
          
          // Write directly to user's file system
          await writeFileToUserDirectory(change.path, newContent);
          
          result.success = true;
          result.message = `File modified in your local directory: ${change.path}`;
          
        } else if (change.operation === 'CREATE') {
          // Create new file in user's directory
          await writeFileToUserDirectory(change.path, change.content);
          result.success = true;
          result.message = `New file created in your local directory: ${change.path}`;
          
        } else if (change.operation === 'UPDATE') {
          // Update entire file in user's directory
          await writeFileToUserDirectory(change.path, change.content);
          result.success = true;
          result.message = `File updated in your local directory: ${change.path}`;
          
        } else {
          throw new Error(`Unsupported operation: ${change.operation}`);
        }
        
      } catch (error) {
        result.error = error.message;
        result.message = `Failed: ${error.message}`;
      }
      
      results.push(result);
    }
    
    return results;
  }
  
  // Write file directly to user's directory using File System Access API
  async function writeFileToUserDirectory(filePath, content) {
    if (!window.selectedDirectoryHandle) {
      throw new Error('No directory selected or File System Access API not supported');
    }
    
    try {
      // Navigate to the correct subdirectory if needed
      let currentDir = window.selectedDirectoryHandle;
      const pathParts = filePath.split('/');
      const fileName = pathParts.pop(); // Remove filename, keep directory parts
      
      // Navigate through directory structure
      for (const dirName of pathParts) {
        if (dirName) { // Skip empty parts
          try {
            currentDir = await currentDir.getDirectoryHandle(dirName, { create: true });
          } catch (error) {
            throw new Error(`Failed to create/access directory "${dirName}": ${error.message}`);
          }
        }
      }
      
      // Create or get the file handle
      const fileHandle = await currentDir.getFileHandle(fileName, { create: true });
      
      // Create a writable stream and write the content
      const writableStream = await fileHandle.createWritable();
      await writableStream.write(content);
      await writableStream.close();
      
      return true;
    } catch (error) {
      // If File System Access API fails, fall back to download
      if (error.name === 'NotAllowedError') {
        throw new Error('Permission denied. Please grant file system access.');
      } else if (error.name === 'SecurityError') {
        throw new Error('Security error. File System Access API requires HTTPS.');
      }
      throw error;
    }
  }
  
  // Clean up Zone.Identifier files created by File System Access API
  async function cleanupIdentifierFile() {
    if (!window.selectedDirectoryHandle) {
      return; // No directory handle, nothing to clean
    }
    
    try {
      // Find all Zone.Identifier files in the directory
      const filesToClean = [];
      
      for await (const [name, handle] of window.selectedDirectoryHandle.entries()) {
        if (handle.kind === 'file') {
          // Match ANY identifier pattern - be very aggressive
          if (name.includes('Identifier') || 
              name.includes('identifier') || 
              name.includes(':Zone.') || 
              name.endsWith(':Zone.Identifier') || 
              name === '.identifier' ||
              name.match(/.*:Zone\.Identifier$/)) {
            filesToClean.push(name);
          }
        }
      }
      
      // Remove each Zone.Identifier file found
      for (const fileName of filesToClean) {
        try {
          await window.selectedDirectoryHandle.removeEntry(fileName, { recursive: false });
        } catch (error) {
          // Silently ignore errors - file might already be deleted
        }
      }
      
    } catch (error) {
      // Silently ignore cleanup errors
    }
  }
  
  // Download XML changes as instructions
  async function downloadXMLChanges(serverResults) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    let content = `XML Changes for ${selectedRepository.name}\n`;
    content += `Generated: ${new Date().toLocaleString()}\n`;
    content += `Total Changes: ${serverResults.length}\n\n`;
    content += '='.repeat(80) + '\n\n';
    
    // Get the original XML to include search/replace patterns
    const xml = xmlInput.value.trim();
    content += `Original XML:\n${xml}\n\n`;
    content += '='.repeat(80) + '\n\n';
    
    content += `INSTRUCTIONS:\n`;
    content += `1. The XML above contains the exact changes to apply\n`;
    content += `2. For MODIFY operations, find the "search" pattern and replace with "content"\n`;
    content += `3. For CREATE operations, create new files with the specified content\n`;
    content += `4. For UPDATE operations, replace entire file content\n\n`;
    content += '='.repeat(80) + '\n\n';
    
    for (const result of serverResults) {
      content += `File: ${result.path}\n`;
      content += `Operation: ${result.operation}\n`;
      content += `Status: ${result.success ? 'Validated' : 'Failed'}\n`;
      if (result.error) {
        content += `Error: ${result.error}\n`;
      }
      content += '\n' + '-'.repeat(40) + '\n\n';
    }
    
    // Create and download the file
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${selectedRepository.name}_xml_changes_${timestamp}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  function renderResults(results) {
    resultsListEl.innerHTML = '';
    
    if (!results || results.length === 0) {
      resultsListEl.innerHTML = '<p class="no-repos">No changes were applied.</p>';
      return;
    }
    
    results.forEach(result => {
      const resultItem = document.createElement('div');
      resultItem.className = `file-item ${result.success ? 'success' : 'error'}`;
      
      const header = document.createElement('div');
      header.className = 'file-header';
      
      const statusIcon = document.createElement('span');
      statusIcon.className = 'status-icon';
      statusIcon.textContent = result.success ? '‚úÖ' : '‚ùå';
      statusIcon.style.marginRight = '8px';
      
      const operationBadge = document.createElement('span');
      operationBadge.className = `badge ${result.operation.toLowerCase()}`;
      operationBadge.textContent = result.operation;

      // Apply inline styles directly
      operationBadge.style.display = 'inline-block';
      operationBadge.style.padding = '2px 8px';
      operationBadge.style.borderRadius = '4px';
      operationBadge.style.fontSize = '12px';
      operationBadge.style.fontWeight = '500';
      operationBadge.style.textTransform = 'uppercase';
      operationBadge.style.marginRight = '8px';
      operationBadge.style.color = 'white'; // Default text color

      // Set background color based on operation
      switch (result.operation.toLowerCase()) {
        case 'create':
          operationBadge.style.backgroundColor = '#28a745'; // Solid green
          break;
        case 'update':
          operationBadge.style.backgroundColor = '#007bff'; // Solid blue
          break;
        case 'delete':
          operationBadge.style.backgroundColor = '#dc3545'; // Solid red
          break;
      }
      
      const path = document.createElement('span');
      path.className = 'file-path';
      path.textContent = result.path;
      
      header.appendChild(statusIcon);
      header.appendChild(operationBadge);
      header.appendChild(path);
      resultItem.appendChild(header);
      
      // Add error message if present
      if (result.error) {
        const error = document.createElement('div');
        error.className = 'file-error';
        error.textContent = result.error;
        resultItem.appendChild(error);
      }
      
      resultsListEl.appendChild(resultItem);
    });
  }
  
  function backToStep1() {
    step1.classList.remove('hidden');
    step2.classList.add('hidden');
    step3.classList.add('hidden');
    
    // If step 1 was disabled (when we had selected repos), re-enable it
    step1.classList.remove('disabled');
    
    // If we're using a custom path, don't reset anything as the repos are already detected
    if (!customPath.classList.contains('hidden')) {
      // Just show step 1 but keep the custom path visible
      return;
    }
  }
  
  function backToStep2() {
    step2.classList.remove('hidden');
    step1.classList.add('hidden');
    step3.classList.add('hidden');
    
    // Clear selected repository state
    selectedRepository = null;
    
    // Clear any active radio buttons
    const radioButtons = document.querySelectorAll('input[name="repository"]');
    radioButtons.forEach(radio => {
        radio.checked = false;
    });
    
    // Clear XML input and results
    xmlInput.value = '';
    previewContainer.classList.add('hidden');
    resultsContainer.classList.add('hidden');
    applyBtn.disabled = true;
  }
  
  function showNotification(message, type = 'info') {
    const notification = document.getElementById('notification');
    const notificationMessage = document.getElementById('notification-message');
    
    // Remove all previous classes
    notification.className = 'notification';
    notification.classList.add(`notification-${type}`);
    
    notificationMessage.textContent = message;
    notification.classList.remove('hidden');
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      notification.classList.add('hidden');
    }, 5000);
  }
  
  function closeNotification() {
    document.getElementById('notification').classList.add('hidden');
  }
  
  // Enter edit mode for path input
  function enterEditMode() {
    // Get current selected path
    const currentPath = pathSelect.value;
    
    // Set input value to current path
    pathInput.value = currentPath;
    
    // Hide select, show input
    pathSelect.classList.add('hidden');
    pathInput.classList.remove('hidden');
    
    // Update button text
    editPathButton.textContent = 'Cancel Edit';
    
    // Update state
    isEditMode = true;
    
    // Focus on input
    pathInput.focus();
  }
  
  // Exit edit mode for path input
  function exitEditMode() {
    // Hide input, show select
    pathInput.classList.add('hidden');
    pathSelect.classList.remove('hidden');
    
    // Update button text
    editPathButton.textContent = 'Edit Path';
    
    // Update state
    isEditMode = false;
  }
  
  // Handle directory selection via browser's file dialog
  function handleDirectorySelection(e) {
    // Clear waiting flag since selection has been made
    window.waitingForFileSelection = false;
    
    if (e.target.files.length > 0) {
      const files = e.target.files;
      // Get the directory name
      const dirName = files[0].webkitRelativePath.split('/')[0];
      
      // Display the selected directory name
      selectedPathDisplay.textContent = `üìÇ ${dirName}`;
      customPath.classList.remove('hidden');
      
      // Disable the browse and scan buttons since we already have a selection
      browseButton.disabled = true;
      scanBtn.disabled = true;
      
      // Show loading indicator
      pathLoading.classList.remove('hidden');
      pathLoading.querySelector('p').textContent = 'Finding repositories in selected directory...';
      
      // Store files globally for XML parsing
      window.selectedDirectoryFiles = Array.from(files).map(file => ({
        path: file.webkitRelativePath,
        file: file
      }));
      
      // Wait a moment to allow UI to update
      setTimeout(() => {
        // Find repositories by looking for .git directories
        const foundRepos = findGitReposInFiles(files);
        
        // Hide loading indicator
        pathLoading.classList.add('hidden');
        
        if (foundRepos.length > 0) {
          // Process the found repositories directly
          processFoundRepositories(foundRepos, dirName);
        } else {
          showNotification(`No Git repositories found in "${dirName}"`, 'warning');
        }
      }, 100);
    }
  }
  
  // Find Git repositories in the selected files
  function findGitReposInFiles(files) {
    const repos = [];
    const repoMap = new Map(); // Use a Map to track unique repos by path
    
    // First pass: find all .git directories to identify repositories
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const path = file.webkitRelativePath;
      const pathParts = path.split('/');
      
      // Look for .git directories
      if (path.includes('/.git/') || path.endsWith('/.git')) {
        const gitDirIndex = pathParts.findIndex(part => part === '.git');
        if (gitDirIndex > 0) {
          // Get the repository path parts (all parts up to .git)
          const repoPathParts = pathParts.slice(0, gitDirIndex);
          const repoPath = repoPathParts.join('/');
          const repoName = repoPathParts[repoPathParts.length - 1];
          
          // Only add unique repositories
          if (!repoMap.has(repoPath)) {
            repoMap.set(repoPath, {
              id: `repo-${repos.length}`,
              name: repoName,
              path: repoPath,
              files: new Set()
            });
          }
        }
      }
    }
    
    // Second pass: add all files to their respective repositories
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const path = file.webkitRelativePath;
      
      // For each repository, check if this file belongs to it
      for (const [repoPath, repo] of repoMap.entries()) {
        if (path.startsWith(repoPath + '/')) {
          repo.files.add(file);
          break;
        }
      }
    }
    
    // Convert Map to array and convert file Sets to arrays
    repoMap.forEach(repo => {
      repos.push({
        ...repo,
        files: Array.from(repo.files)
      });
    });
    
    return repos;
  }
  
  // Process found repositories
  function processFoundRepositories(repos, dirName) {
    // Update repositories array with found repositories
    repositories = repos;
    
    // Clear previous checkboxes
    repoChecklist.innerHTML = '';
    
    // Render repositories
    populateRepositories();
    
    if (repositories.length > 0) {
      // Show success message
      showNotification(`Found ${repos.length} repositories in "${dirName}"`, 'success');
      
      // Disable step 1
      step1.classList.add('disabled');
      
      // Show step 2
      step2.classList.remove('hidden');
    }
  }
  
</script>
{% endblock %}
