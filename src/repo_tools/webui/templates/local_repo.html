{% extends "base.html" %}

{% block title %}Repo Tools - Local Repository{% endblock %}

{% block content %}
<div class="page-header">
    <h2>üì¶ Local Repository Context Copier</h2>
    <p>Copy code context from local repositories on your machine</p>
</div>

<div class="workflow-container">
    <div class="workflow-step" id="step-path-select">
        <h3>üîç Step 1: Select Path</h3>
        <div class="form-group">
            <label for="path-select">Choose a path to search for repositories:</label>
            <div class="path-input-container">
                <select id="path-select" class="select-dark"></select>
                <input type="text" id="path-input" class="path-input hidden" placeholder="Enter a path to search for repositories">
            </div>
            <div class="button-group">
                <button id="scan-button" class="btn">Scan Path for Repositories</button>
                <button id="edit-path-button" class="btn btn-orange">Edit Path</button>
                <button id="browse-button" class="btn btn-blue">Select from File Explorer</button>
                <input type="file" id="directory-input" webkitdirectory directory multiple style="display: none;" />
            </div>
        </div>
        <div id="custom-path" class="custom-path hidden">
            <div class="path-header">
                <p class="selected-path-label">Selected directory:</p>
                <button id="clear-path-button" class="clear-path-btn" title="Clear selection">√ó</button>
            </div>
            <p id="selected-path-display" class="selected-path"></p>
            <p class="path-info">Any git repositories inside this directory will be detected and processed.</p>
        </div>
        <div id="path-loading" class="loading-indicator hidden">
            <div class="spinner"></div>
            <p>Scanning for repositories...</p>
        </div>
    </div>
    
    <div class="workflow-step hidden" id="step-repo-select">
        <h3>üìã Step 2: Select Repositories <span id="repo-selection-count" class="selection-count hidden">0</span></h3>
        
        <!-- New section for displaying selected repositories with X buttons -->
        <div id="repo-select-summary" class="summary-section hidden">
            <h4>Selected Repositories:</h4>
            <div id="repo-select-list" class="repo-list">
                <!-- Selected repos will be shown here with X buttons -->
            </div>
        </div>
        
        <!-- Repository search and sort controls -->
        <div class="repo-controls">
            <div class="repo-search">
                <span class="repo-search-icon">üîç</span>
                <input type="text" id="repo-search-input" class="repo-search-input" placeholder="Search repositories...">
                <button id="repo-search-clear" class="repo-search-clear">√ó</button>
            </div>
            <div class="repo-sort">
                <label for="repo-sort-select">Sort by:</label>
                <select id="repo-sort-select" class="select-dark">
                    <option value="default">Default</option>
                    <option value="name-asc">Name (A-Z)</option>
                    <option value="name-desc">Name (Z-A)</option>
                </select>
            </div>
        </div>
        
        <div class="form-group">
            <label>Select one or more repositories:</label>
            <div id="repo-checklist" class="repo-checklist">
                <!-- Repositories will be populated here as checkboxes -->
            </div>
            <div class="button-group">
                <button id="load-repos-button" class="btn">Load Selected Repositories</button>
                <button id="back-to-path-button" class="btn btn-secondary">Back</button>
            </div>
        </div>
        <div id="repo-loading" class="loading-indicator hidden">
            <div class="spinner"></div>
            <p>Loading repository files...</p>
        </div>
    </div>
    
    <div class="workflow-step hidden" id="step-file-summary">
        <h3>üìä Step 3: File Summary</h3>
        
        <div id="selected-repos-summary" class="summary-section hidden">
            <h4>Selected Repositories (<span id="selected-repos-count">0</span>/50):</h4>
            <div id="selected-repos-list" class="repo-list">
                <!-- Selected repos will be shown here -->
            </div>
        </div>
        
        <!-- Files to be included section -->
        <div class="summary-box">
            <div class="summary-header included-header" id="included-files-header">
                <h4>Files to be included:</h4>
                <span id="included-count" class="count-badge">0 files</span>
                <button class="expand-collapse-btn">Collapse ‚ñ≤</button>
            </div>
            
            <!-- Included Files Content -->
            <div class="included-content">
                <!-- File Tree Search and Sort -->
                <div class="tree-controls">
                    <div class="tree-search">
                        <span class="tree-search-icon">üîç</span>
                        <input type="text" id="tree-search-input" class="tree-search-input" placeholder="Search files...">
                        <button id="tree-search-clear" class="tree-search-clear">√ó</button>
                    </div>
                    <div class="tree-sort">
                        <label for="tree-sort-select">Sort by:</label>
                        <select id="tree-sort-select" class="select-dark">
                            <option value="default">Default</option>
                            <option value="name-asc">Name (A-Z)</option>
                            <option value="name-desc">Name (Z-A)</option>
                            <option value="tokens-desc">Tokens (High to Low)</option>
                            <option value="tokens-asc">Tokens (Low to High)</option>
                        </select>
                    </div>
                </div>
                
                <!-- New File Tree View -->
                <div id="file-tree" class="file-tree">
                    <!-- File tree will be rendered here -->
                    <div class="tree-empty">
                        <div class="tree-empty-icon">üìÇ</div>
                        <p>No files loaded yet</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Files ignored section - collapsed by default -->
        <div class="summary-box ignored-files-section">
            <div class="summary-header ignored-header" id="ignored-files-header">
                <h4>Files ignored:</h4>
                <span id="ignored-count" class="count-badge">0 files</span>
                <button class="expand-collapse-btn">Expand ‚ñº</button>
            </div>
            
            <!-- Collapsed content -->
            <div class="ignored-content hidden">
                <!-- Ignored Files Tree Search -->
                <div class="tree-controls">
                    <div class="tree-search">
                        <span class="tree-search-icon">üîç</span>
                        <input type="text" id="ignored-tree-search-input" class="tree-search-input" placeholder="Search ignored files...">
                        <button id="ignored-tree-search-clear" class="tree-search-clear">√ó</button>
                    </div>
                    <div class="tree-sort">
                        <label for="ignored-tree-sort-select">Sort by:</label>
                        <select id="ignored-tree-sort-select" class="select-dark">
                            <option value="default">Default</option>
                            <option value="name-asc">Name (A-Z)</option>
                            <option value="name-desc">Name (Z-A)</option>
                        </select>
                    </div>
                </div>
                
                <!-- Ignored Files Tree View -->
                <div id="ignored-file-tree" class="file-tree">
                    <!-- Ignored file tree will be rendered here -->
                    <div class="tree-empty">
                        <div class="tree-empty-icon">üìÇ</div>
                        <p>No ignored files loaded yet</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="action-buttons">
            <!-- Add summary stats display above buttons -->
            <div class="copy-summary-stats">
                <div class="stats-item">
                    <span class="stats-label">Files:</span>
                    <span id="total-files-count" class="stats-value">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Tokens:</span>
                    <span id="total-tokens-count" class="stats-value">0</span>
                </div>
            </div>
            <button id="copy-button" class="btn btn-primary">üìã Copy to Clipboard</button>
            <button id="refresh-button" class="btn btn-info">üîÑ Refresh Files</button>
            <button id="back-to-select-button" class="btn btn-secondary">Back</button>
        </div>
    </div>
</div>

<!-- File Preview Modal -->
<div id="file-preview-modal" class="file-preview-modal">
    <div class="file-preview-content">
        <div class="file-preview-header">
            <div class="file-preview-title">
                <span class="file-preview-title-icon">üìÑ</span>
                <span id="file-preview-filename">filename.ext</span>
            </div>
            <button id="file-preview-close" class="file-preview-close">√ó</button>
        </div>
        <div class="file-preview-body">
            <pre id="file-preview-code" class="file-preview-code"></pre>
        </div>
    </div>
</div>

<!-- Create Prompt Section -->
<div class="workflow-step hidden" id="step-create-prompt">
    <h3>‚úçÔ∏è Optional: Create Prompt</h3>
    
    
    <!-- Copy Settings Panel -->
    <div class="summary-box">
        <div class="summary-header" id="copy-settings-header">
            <div style="display: flex; align-items: center; gap: 15px; width: 100%; justify-content: space-between;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <h4>Copy Settings</h4>
                    <button id="prompt-copy-button" class="btn btn-primary" style="margin: 0; padding: 10px 22px; font-size: 14px; margin-left: 10px;" onclick="event.stopPropagation();">üìã Copy to Clipboard</button>
                </div>
                <button class="expand-collapse-btn">Collapse ‚ñ≤</button>
            </div>
        </div>
        <div class="copy-settings-content">
            <div class="settings-group">
                <div class="setting-item">
                    <input type="checkbox" id="include-prompt" class="tree-checkbox" checked>
                    <div class="setting-info">
                        <div class="setting-label">Prompt Text</div>
                        <div class="setting-description">Include your custom prompt text</div>
                    </div>
                </div>
                <div class="setting-item">
                    <input type="checkbox" id="include-file-tree" class="tree-checkbox" checked>
                    <div class="setting-info">
                        <div class="setting-label">File Tree</div>
                        <div class="setting-description">Include hierarchical file structure</div>
                    </div>
                </div>
                <div class="setting-item">
                    <input type="checkbox" id="include-repo-context" class="tree-checkbox" checked>
                    <div class="setting-info">
                        <div class="setting-label">Repository Context</div>
                        <div class="setting-description">Include selected files and their contents</div>
                    </div>
                </div>
                <hr style="border: none; border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 10px 0;">
                <div class="setting-item">
                    <input type="checkbox" id="include-xml-diff" class="tree-checkbox">
                    <div class="setting-info">
                        <div class="setting-label">XML Diff</div>
                        <div class="setting-description">Include XML diff formatting instructions (mutually exclusive with XML Whole)</div>
                    </div>
                </div>
                <div class="setting-item">
                    <input type="checkbox" id="include-xml-whole" class="tree-checkbox">
                    <div class="setting-info">
                        <div class="setting-label">XML Whole</div>
                        <div class="setting-description">Include XML whole formatting instructions (mutually exclusive with XML Diff)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="form-group">
        <label for="prompt-input">Enter your prompt:</label>
        <textarea 
            id="prompt-input" 
            class="prompt-input" 
            placeholder="Enter your prompt here..."
            rows="10"
        ></textarea>
    </div>
</div>

<!-- XML Parser Section -->
<div class="workflow-step hidden" id="step-xml-parser">
    <h3>üîß Optional: XML Parser For Selected Repo</h3>
    
    <div class="summary-box">
        <div class="summary-header" id="xml-parser-header">
            <h4>XML Parser</h4>
            <button class="expand-collapse-btn">Collapse ‚ñ≤</button>
        </div>
        <div class="xml-parser-content">
            <!-- Repository selector (only shown if multiple repos are selected) -->
            <div id="xml-repo-select" class="form-group hidden">
                <label for="xml-repo-dropdown">Select Repository:</label>
                <select id="xml-repo-dropdown" class="select-dark"></select>
            </div>
            
            <div id="xml-repo-details" class="repo-details">
                <div id="xml-repo-name" class="repo-detail-item">
                    <span class="repo-detail-label">Repository:</span>
                    <span class="repo-detail-value">No repository selected</span>
                </div>
                <div id="xml-repo-path" class="repo-detail-item">
                    <span class="repo-detail-label">Path:</span>
                    <span class="repo-detail-value">N/A</span>
                </div>
            </div>
            
            <div class="form-group">
                <label for="xml-input">Paste XML content below:</label>
                <textarea 
                    id="xml-input" 
                    class="xml-input" 
                    placeholder="Paste your XML here..."
                    rows="10"
                    disabled
                ></textarea>
            </div>
            
            <div class="button-group">
                <button id="parse-btn" class="btn" disabled>Preview Changes</button>
                <button id="apply-btn" class="btn btn-primary" disabled>Apply Changes</button>
            </div>
            
            <!-- Preview container -->
            <div id="preview-container" class="summary-box hidden">
                <div class="summary-header">
                    <h4>Changes Preview</h4>
                    <span id="change-count" class="count-badge">0 changes</span>
                </div>
                <div id="preview-list" class="file-list">
                    <!-- Preview results will be listed here -->
                </div>
            </div>
            
            <!-- Results container -->
            <div id="results-container" class="summary-box hidden">
                <div class="summary-header">
                    <h4>Results</h4>
                    <span id="results-count" class="count-badge">
                        <span id="success-count">0</span> of <span id="total-count">0</span> changes applied
                    </span>
                </div>
                <div id="results-list" class="file-list">
                    <!-- Results will be listed here -->
                </div>
            </div>
        </div>
    </div>
</div>

<div id="notification" class="notification hidden">
    <div class="notification-content">
        <span id="notification-message"></span>
        <span class="notification-close">&times;</span>
    </div>
</div>

<div class="workflow-step hidden" id="step-prompt">
    <h3>üìù Optional: Create Prompt</h3>
    
    <div class="prompt-settings">
        <div class="settings-group">
            <h4>Copy Settings</h4>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="include-repo-context" checked>
                    Include repository context
                </label>
            </div>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="include-file-tree" checked>
                    Include file tree structure
                </label>
            </div>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="include-prompt" checked>
                    Include prompt text
                </label>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize socket.io
        const socket = io();
        
        // DOM elements
        const stepPathSelect = document.getElementById('step-path-select');
        const pathSelect = document.getElementById('path-select');
        const pathInput = document.getElementById('path-input');
        const editPathButton = document.getElementById('edit-path-button');
        const scanButton = document.getElementById('scan-button');
        const browseButton = document.getElementById('browse-button');
        const directoryInput = document.getElementById('directory-input');
        const customPath = document.getElementById('custom-path');
        const selectedPathDisplay = document.getElementById('selected-path-display');
        const pathLoading = document.getElementById('path-loading');
        
        const stepRepoSelect = document.getElementById('step-repo-select');
        const repoChecklist = document.getElementById('repo-checklist');
        const repoSelectionCount = document.getElementById('repo-selection-count');
        const loadReposButton = document.getElementById('load-repos-button');
        const backToPathButton = document.getElementById('back-to-path-button');
        const repoLoading = document.getElementById('repo-loading');
        
        const repoSelectSummary = document.getElementById('repo-select-summary');
        const repoSelectList = document.getElementById('repo-select-list');
        
        // Repository search and sort elements
        const repoSearchInput = document.getElementById('repo-search-input');
        const repoSearchClear = document.getElementById('repo-search-clear');
        const repoSortSelect = document.getElementById('repo-sort-select');
        
        const stepFileSummary = document.getElementById('step-file-summary');
        const stepCreatePrompt = document.getElementById('step-create-prompt');
        const includedCount = document.getElementById('included-count');
        const fileTree = document.getElementById('file-tree');
        const ignoredCount = document.getElementById('ignored-count');
        const ignoredHeader = document.getElementById('ignored-files-header');
        const ignoredContent = document.querySelector('.ignored-content');
        const includedHeader = document.getElementById('included-files-header');
        const includedContent = document.querySelector('.included-content');
        const expandCollapseBtn = document.querySelector('.ignored-files-section .expand-collapse-btn');
        const includedExpandCollapseBtn = includedHeader.querySelector('.expand-collapse-btn');
        const ignoredFileTree = document.getElementById('ignored-file-tree');
        const copyButton = document.getElementById('copy-button');
        const refreshButton = document.getElementById('refresh-button');
        const backToSelectButton = document.getElementById('back-to-select-button');
        const selectedReposSummary = document.getElementById('selected-repos-summary');
        const selectedReposCount = document.getElementById('selected-repos-count');
        const selectedReposList = document.getElementById('selected-repos-list');
        
        // Create Prompt section elements
        const promptInput = document.getElementById('prompt-input');
        const includeRepoContext = document.getElementById('include-repo-context');
        const includePrompt = document.getElementById('include-prompt');
        const promptCopyButton = document.getElementById('prompt-copy-button');
        
        // XML Parser elements
        const stepXmlParser = document.getElementById('step-xml-parser');
        const xmlParserHeader = document.getElementById('xml-parser-header');
        const xmlParserContent = document.querySelector('.xml-parser-content');
        const xmlParserExpandBtn = xmlParserHeader.querySelector('.expand-collapse-btn');
        const xmlRepoSelect = document.getElementById('xml-repo-select');
        const xmlRepoDropdown = document.getElementById('xml-repo-dropdown');
        const xmlRepoName = document.getElementById('xml-repo-name').querySelector('.repo-detail-value');
        const xmlRepoPath = document.getElementById('xml-repo-path').querySelector('.repo-detail-value');
        const xmlInput = document.getElementById('xml-input');
        const parseBtn = document.getElementById('parse-btn');
        const applyBtn = document.getElementById('apply-btn');
        const previewContainer = document.getElementById('preview-container');
        const previewList = document.getElementById('preview-list');
        const changeCountEl = document.getElementById('change-count');
        const resultsContainer = document.getElementById('results-container');
        const resultsListEl = document.getElementById('results-list');
        const successCountEl = document.getElementById('success-count');
        const totalCountEl = document.getElementById('total-count');
        
        // File tree search
        const treeSearchInput = document.getElementById('tree-search-input');
        const treeSearchClear = document.getElementById('tree-search-clear');
        const ignoredTreeSearchInput = document.getElementById('ignored-tree-search-input');
        const ignoredTreeSearchClear = document.getElementById('ignored-tree-search-clear');
        
        // File tree sorting
        const treeSortSelect = document.getElementById('tree-sort-select');
        const ignoredTreeSortSelect = document.getElementById('ignored-tree-sort-select');
        
        // File preview modal
        const filePreviewModal = document.getElementById('file-preview-modal');
        const filePreviewFilename = document.getElementById('file-preview-filename');
        const filePreviewCode = document.getElementById('file-preview-code');
        const filePreviewClose = document.getElementById('file-preview-close');
        
        const notification = document.getElementById('notification');
        const notificationMessage = document.getElementById('notification-message');
        const notificationClose = document.querySelector('.notification-close');
        
        // Repository data
        let availableRepos = [];
        let selectedRepoIds = []; // Store selected repo IDs
        let selectedRepos = [];
        let fileTreeData = []; // Store hierarchical file tree data for included files
        let ignoredTreeData = []; // Store hierarchical file tree data for ignored files
        let totalTokenCount = 0; // Track total tokens across all repos
        
        // XML Parser repository selection
        let xmlSelectedRepository = null;
        
        // Toggle ignored files section expand/collapse
        ignoredHeader.addEventListener('click', function(e) {
            // Don't toggle if clicking on the button directly (it has its own handler)
            if (e.target.classList.contains('expand-collapse-btn')) return;
            
            ignoredContent.classList.toggle('hidden');
            const btn = this.querySelector('.expand-collapse-btn');
            
            if (ignoredContent.classList.contains('hidden')) {
                btn.textContent = 'Expand ‚ñº';
            } else {
                btn.textContent = 'Collapse ‚ñ≤';
                // When expanding, re-render the ignored files tree
                renderIgnoredFileTree();
            }
        });
        
        // Toggle included files section expand/collapse
        includedHeader.addEventListener('click', function(e) {
            // Don't toggle if clicking on the button directly (it has its own handler)
            if (e.target.classList.contains('expand-collapse-btn')) return;
            
            includedContent.classList.toggle('hidden');
            const btn = this.querySelector('.expand-collapse-btn');
            
            if (includedContent.classList.contains('hidden')) {
                btn.textContent = 'Expand ‚ñº';
            } else {
                btn.textContent = 'Collapse ‚ñ≤';
                // When expanding, re-render the file tree
                renderFileTree();
            }
        });
        
        // Direct click handlers for the expand/collapse buttons
        includedExpandCollapseBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent the header click handler from firing
            includedContent.classList.toggle('hidden');
            
            if (includedContent.classList.contains('hidden')) {
                this.textContent = 'Expand ‚ñº';
            } else {
                this.textContent = 'Collapse ‚ñ≤';
                // When expanding, re-render the file tree
                renderFileTree();
            }
        });
        
        expandCollapseBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent the header click handler from firing
            ignoredContent.classList.toggle('hidden');
            
            if (ignoredContent.classList.contains('hidden')) {
                this.textContent = 'Expand ‚ñº';
            } else {
                this.textContent = 'Collapse ‚ñ≤';
                // When expanding, re-render the ignored files tree
                renderIgnoredFileTree();
            }
        });
        
        // Load paths
        function loadPaths() {
            axios.get('/api/paths')
                .then(response => {
                    pathSelect.innerHTML = '';
                    response.data.paths.forEach(path => {
                        const option = document.createElement('option');
                        option.value = path.path;
                        option.textContent = path.display;
                        
                        // Set selected if this is the default path (parent directory)
                        if (response.data.default && path.path === response.data.default) {
                            option.selected = true;
                        }
                        
                        pathSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    showNotification('Error loading paths: ' + error.message, 'error');
                });
        }
        
        // Scan for repositories
        function scanRepositories() {
            // Get the path based on current mode
            let path;
            
            if (!customPath.classList.contains('hidden')) {
                // If we've selected a directory via the file browser, don't scan - we've already processed it
                showNotification('Repositories have already been detected from the selected directory.', 'info');
                return;
            } else if (isEditMode) {
                // If in edit mode, get path from input
                path = pathInput.value.trim();
                if (!path) {
                    showNotification('Please enter a valid path', 'warning');
                    return;
                }
                
                // Exit edit mode after getting the path
                exitEditMode();
                
                // Check if path exists in dropdown, if not, add it
                let pathExists = false;
                Array.from(pathSelect.options).forEach(option => {
                    if (option.value === path) {
                        option.selected = true;
                        pathExists = true;
                    }
                });
                
                if (!pathExists) {
                    const newOption = document.createElement('option');
                    newOption.value = path;
                    newOption.textContent = path;
                    newOption.selected = true;
                    pathSelect.appendChild(newOption);
                }
            } else {
                // Use the path from the dropdown
                path = pathSelect.value;
            }
            
            if (!path) {
                showNotification('Please select a valid path', 'error');
                return;
            }
            
            pathLoading.classList.remove('hidden');
            pathLoading.querySelector('p').textContent = 'Scanning for repositories...';
            
            // Send the path to scan to the server
            socket.emit('scan_repos', { path: path });
        }
        
        // Handle directory selection via browser's file dialog
        function handleDirectorySelection(e) {
            // Clear waiting flag since selection has been made
            window.waitingForFileSelection = false;
            
            if (e.target.files.length > 0) {
                const files = e.target.files;
                // Get the directory name
                const dirName = files[0].webkitRelativePath.split('/')[0];
                
                // Display the selected directory name
                selectedPathDisplay.textContent = `üìÇ ${dirName}`;
                customPath.classList.remove('hidden');
                
                // Disable the browse and scan buttons since we already have a selection
                browseButton.disabled = true;
                scanButton.disabled = true;
                
                // Show loading indicator
                pathLoading.classList.remove('hidden');
                pathLoading.querySelector('p').textContent = 'Finding repositories in selected directory...';
                
                // Wait a moment to allow UI to update
                setTimeout(() => {
                    // Find repositories by looking for .git directories
                    const foundRepos = findGitReposInFiles(files);
                    
                    // Hide loading indicator
                    pathLoading.classList.add('hidden');
                    
                    if (foundRepos.length > 0) {
                        // Process the found repositories directly
                        processFoundRepositories(foundRepos, dirName);
                    } else {
                        showNotification(`No Git repositories found in "${dirName}"`, 'warning');
                    }
                }, 100);
            }
        }
        
        // Find Git repositories in the selected files
        function findGitReposInFiles(files) {
            const repos = [];
            const repoMap = new Map(); // Use a Map to track unique repos by path
            
            // First pass: find all .git directories to identify repositories
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const path = file.webkitRelativePath;
                const pathParts = path.split('/');
                
                // Look for .git directories
                if (path.includes('/.git/') || path.endsWith('/.git')) {
                    const gitDirIndex = pathParts.findIndex(part => part === '.git');
                    if (gitDirIndex > 0) {
                        // Get the repository path parts (all parts up to .git)
                        const repoPathParts = pathParts.slice(0, gitDirIndex);
                        const repoPath = repoPathParts.join('/');
                        const repoName = repoPathParts[repoPathParts.length - 1];
                        
                        // Only add unique repositories
                        if (!repoMap.has(repoPath)) {
                            repoMap.set(repoPath, {
                                id: `repo-${repos.length}`,
                                name: repoName,
                                path: repoPath,
                                files: new Set()
                            });
                        }
                    }
                }
            }
            
            // Second pass: add all files to their respective repositories
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const path = file.webkitRelativePath;
                
                // For each repository, check if this file belongs to it
                for (const [repoPath, repo] of repoMap.entries()) {
                    if (path.startsWith(repoPath + '/')) {
                        repo.files.add(file);
                        break;
                    }
                }
            }
            
            // Convert Map to array
            repoMap.forEach(repo => {
                repos.push(repo);
            });
            
            return repos;
        }
        
        // Process found repositories
        function processFoundRepositories(repos, dirName) {
            // Update availableRepos array with found repositories
            availableRepos = repos;
            
            // Clear previous checkboxes
            repoChecklist.innerHTML = '';
            
            // Reset selections
            selectedRepoIds = [];
            updateSelectionCount();
            
            // Render repositories
            renderRepositoryList();
            
            if (availableRepos.length > 0) {
                // Show success message
                showNotification(`Found ${repos.length} repositories in "${dirName}"`, 'success');
                
                // Disable step 1
                stepPathSelect.classList.add('disabled');
                
                // Show step 2
                stepRepoSelect.classList.remove('hidden');
            }
        }
        
        // Modified function to load selected repositories
        function loadSelectedRepositories() {
            if (selectedRepoIds.length === 0) {
                showNotification('Please select at least one repository', 'warning');
                return;
            }
            
            // Disable Step 2
            stepRepoSelect.classList.add('disabled');
            
            // Show loading indicator
            repoLoading.classList.remove('hidden');
            
            // Keep track of loaded repositories
            let loadedCount = 0;
            selectedRepos = [];
            fileTreeData = [];
            ignoredTreeData = [];
            
            // For each selected repository
            selectedRepoIds.forEach((repoId, index) => {
                const repo = availableRepos.find(r => r.id === repoId);
                if (!repo) return;
                
                setTimeout(() => {
                    try {
                        // If we have files from the browser (when using Browse for Path)
                        if (repo.files && repo.files.size > 0) {
                            // Process files directly in the browser
                            processRepositoryFiles(repo, (processedRepo) => {
                                // Add to selected repos
                                selectedRepos.push(processedRepo);
                                
                                // Convert the repository's included files into trees
                                const repoTreeData = buildFileTree(processedRepo.included, processedRepo.name, false);
                                fileTreeData.push(repoTreeData);
                                
                                const repoIgnoredTreeData = buildFileTree(
                                    processedRepo.ignored.map(path => ({ path, content: "" })), 
                                    processedRepo.name, 
                                    true
                                );
                                ignoredTreeData.push(repoIgnoredTreeData);
                                
                                // Track completion
                                loadedCount++;
                                finishLoading();
                            });
                        }
                        // If we don't have files (when using dropdown path)
                        else {
                            // Use the server API
                            axios.post('/api/repo-files', { repoPath: repo.path })
                                .then(response => {
                                    // Create repository object with data
                                    const loadedRepo = {
                                        name: repo.name,
                                        path: repo.path,
                                        included: response.data.included,
                                        ignored: response.data.ignored
                                    };
                                    
                                    // Add to selected repos
                                    selectedRepos.push(loadedRepo);
                                    
                                    // Convert the repository's included files into a hierarchical tree structure
                                    const repoTreeData = buildFileTree(loadedRepo.included, loadedRepo.name, false);
                                    fileTreeData.push(repoTreeData);
                                    
                                    // Convert the repository's ignored files into a hierarchical tree structure
                                    const repoIgnoredTreeData = buildFileTree(
                                        loadedRepo.ignored.map(path => ({ path, content: "" })), 
                                        loadedRepo.name, 
                                        true
                                    );
                                    ignoredTreeData.push(repoIgnoredTreeData);
                                    
                                    // Track completion
                                    loadedCount++;
                                    finishLoading();
                                })
                                .catch(error => {
                                    loadedCount++;
                                    showNotification(`Error loading repository ${repo.name}: ${error.message}`, 'error');
                                    finishLoading();
                                });
                        }
                    } catch (error) {
                        loadedCount++;
                        showNotification(`Error processing repository ${repo.name}: ${error.message}`, 'error');
                        finishLoading();
                    }
                }, index * 200); // Stagger processing
            });
            
            // Function to finish loading when all repos are processed
            function finishLoading() {
                if (loadedCount === selectedRepoIds.length) {
                    repoLoading.classList.add('hidden');
                    
                    if (selectedRepos.length > 0) {
                        // Update UI with file summary
                        updateFileSummary();
                        
                        // Render the file trees
                        renderFileTree();
                        
                        // Show both the file summary step and create prompt step
                        stepFileSummary.classList.remove('hidden');
                        stepCreatePrompt.classList.remove('hidden');
                        
                        // Show the XML Parser step
                        const stepXmlParser = document.getElementById('step-xml-parser');
                        if (stepXmlParser) {
                            stepXmlParser.classList.remove('hidden');
                            setupXmlParser();
                        }
                        
                        // Save initial selection state to localStorage
                        saveSelectionState();
                    } else {
                        // Re-enable Step 2 if no repos were loaded
                        stepRepoSelect.classList.remove('disabled');
                    }
                }
            }
        }
        
        // Process repository files directly in the browser
        function processRepositoryFiles(repo, callback) {
            const files = Array.from(repo.files);
            const includedFiles = [];
            const ignoredFiles = [];
            
            // Rules for files to ignore
            const ignorePatterns = [
                /node_modules/,
                /\.git\//,
                /venv\//,
                /virtualenv\//,
                /\.venv\//,
                /env\//,
                /\.env\//,
                /\.DS_Store/,
                /\.class$/,
                /\.pyc$/,
                /\.pyo$/,
                /\.log$/,
                /\.sqlite$/,
                /\.o$/,
                /\.a$/,
                /\.so$/,
                /\.dll$/,
                /\.exe$/,
                /\.bin$/,
                /\.lock$/,
                /\.tmp$/,
                /\.temp$/,
                /^thumbs\.db$/i,
                /\.svg$/,
                /\.jpg$/,
                /\.jpeg$/,
                /\.png$/,
                /\.gif$/,
                /\.ico$/,
                /\.pdf$/,
                /\.ttf$/,
                /\.woff$/,
                /\.woff2$/,
                /\.eot$/,
                /\.lock$/,
                /^package-lock\.json$/,
                /^yarn\.lock$/
            ];
            
            // First filter out directories and count how many actual files we'll process
            const filesToProcess = files.filter(file => !file.webkitRelativePath.endsWith('/'));
            const totalFiles = filesToProcess.length;
            let processedCount = 0;
            let totalToRead = 0;
            let readCount = 0;
            let processingComplete = false;
            
            // Update loading progress display
            function updateLoadingProgress() {
                if (repoLoading && repoLoading.querySelector('p')) {
                    const progress = Math.round((processedCount / totalFiles) * 100);
                    repoLoading.querySelector('p').textContent = 
                        `Processing ${repo.name}: ${progress}% (${processedCount}/${totalFiles} files)`;
                }
            }
            
            // Check if we're done and finish processing if so
            function checkCompletion() {
                if (processedCount === totalFiles && readCount === totalToRead && !processingComplete) {
                    processingComplete = true;
                    finishProcessing();
                }
            }
            
            // When all files are processed
            function finishProcessing() {
                // Create the processed repository object
                const processedRepo = {
                    name: repo.name,
                    path: repo.path,
                    included: includedFiles,
                    ignored: ignoredFiles
                };
                
                // Call the callback with the processed repository
                callback(processedRepo);
            }
            
            // Process all files in smaller batches to avoid UI blocking
            let currentBatch = 0;
            const batchSize = 100;
            
            function processBatch() {
                const startIndex = currentBatch * batchSize;
                const endIndex = Math.min(startIndex + batchSize, totalFiles);
                
                // Process this batch of files
                for (let i = startIndex; i < endIndex; i++) {
                    const file = filesToProcess[i];
                    const path = file.webkitRelativePath;
                    
                    // Check if file should be ignored
                    let shouldIgnore = false;
                    for (const pattern of ignorePatterns) {
                        if (pattern.test(path)) {
                            shouldIgnore = true;
                            break;
                        }
                    }
                    
                    if (shouldIgnore) {
                        ignoredFiles.push(path);
                        processedCount++;
                        updateLoadingProgress();
                    } else {
                        // Count files we'll actually read
                        totalToRead++;
                        
                        // Read the file content
                        const reader = new FileReader();
                        
                        reader.onload = (function(currentFile, filePath) {
                            return function(e) {
                                includedFiles.push({
                                    path: filePath,
                                    content: e.target.result
                                });
                                
                                processedCount++;
                                readCount++;
                                updateLoadingProgress();
                                checkCompletion();
                            };
                        })(file, path);
                        
                        reader.onerror = (function(currentFile, filePath) {
                            return function(e) {
                                console.error(`Error reading file ${filePath}:`, e);
                                // If error reading file, add to ignored
                                ignoredFiles.push(filePath);
                                
                                processedCount++;
                                readCount++;
                                updateLoadingProgress();
                                checkCompletion();
                            };
                        })(file, path);
                        
                        // Read as text
                        reader.readAsText(file);
                    }
                }
                
                // Process next batch if needed
                currentBatch++;
                if (endIndex < totalFiles) {
                    setTimeout(processBatch, 10); // Small delay to let UI update
                } else {
                    // We've queued all files for processing
                    // Check if we're already done (all files were ignored)
                    checkCompletion();
                }
            }
            
            // Start processing
            if (totalFiles > 0) {
                processBatch();
            } else {
                // No files to process
                finishProcessing();
            }
        }
        
        // Update selection count badge
        function updateSelectionCount() {
            const count = selectedRepoIds.length;
            repoSelectionCount.textContent = count;
            
            if (count > 0) {
                repoSelectionCount.classList.remove('hidden');
                repoSelectSummary.classList.remove('hidden');
            } else {
                repoSelectionCount.classList.add('hidden');
                repoSelectSummary.classList.add('hidden');
            }
            
            // Update the selected repositories display in Step 2
            updateRepoSelectList();
        }
        
        // Update the list of selected repositories in Step 2
        function updateRepoSelectList() {
            repoSelectList.innerHTML = '';
            
            // Create a select item for each selected repo
            selectedRepoIds.forEach(repoId => {
                const repo = availableRepos.find(r => r.id === repoId);
                if (!repo) return;
                
                const repoItem = document.createElement('div');
                repoItem.classList.add('repo-item');
                repoItem.innerHTML = `
                    <span class="repo-name">üìÇ ${repo.name}</span>
                    <button class="repo-remove-btn" data-repo-id="${repo.id}">√ó</button>
                `;
                repoSelectList.appendChild(repoItem);
                
                // Add event listener to the remove button
                const removeButton = repoItem.querySelector('.repo-remove-btn');
                removeButton.addEventListener('click', function() {
                    // Store current scroll position
                    const scrollTop = window.scrollY || document.documentElement.scrollTop;
                    
                    const repoId = this.dataset.repoId;
                    
                    // Remove from selectedRepoIds
                    const index = selectedRepoIds.indexOf(repoId);
                    if (index !== -1) {
                        selectedRepoIds.splice(index, 1);
                    }
                    
                    // Update the checkbox state
                    const checkbox = repoChecklist.querySelector(`input[id="${repoId}"]`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    
                    // Update UI
                    updateSelectionCount();
                    
                    // Restore scroll position
                    window.scrollTo(0, scrollTop);
                });
            });
        }
        
        // Go back to Step 1
        function backToPathSelection() {
            // Hide Step 2
            stepRepoSelect.classList.add('hidden');
            
            // Re-enable Step 1
            stepPathSelect.classList.remove('disabled');
            
            // Clear previous selections
            selectedRepoIds = [];
            availableRepos = [];
            repoChecklist.innerHTML = '';
            updateSelectionCount();
        }
        
        // Estimate tokens in text
        function estimateTokens(text) {
            if (!text) return 0;
            
            // Basic estimation: characters / 4 is a reasonable approximation
            // For more accuracy, we could use a proper tokenizer library
            const charCount = text.length;
            return Math.ceil(charCount / 4);
        }
        
        // Format token count with abbreviation
        function formatTokenCount(count) {
            if (count < 1000) {
                return count.toString();
            } else if (count < 1000000) {
                return (Math.round(count / 100) / 10).toFixed(1) + 'k';
            } else {
                return (Math.round(count / 100000) / 10).toFixed(1) + 'M';
            }
        }
        
        // Helper function to display "Unknown" for ignored files token counts
        function getTokenDisplay(file) {
            if (file.isIgnored) {
                return "Unknown";
            }
            return formatTokenCount(file.tokenCount || 0);
        }
        
        // Build a hierarchical file tree from flat file list
        function buildFileTree(files, repoName, isIgnored = false) {
            const root = { 
                name: repoName, 
                type: 'repo', 
                children: {}, 
                expanded: true,
                fileCount: 0, // Will be calculated below
                tokenCount: 0,
                selected: !isIgnored, // Default selected state (true for included, false for ignored)
                indeterminate: false,
                isIgnored: isIgnored
            };
            let totalFileCount = 0;

            files.forEach(file => {
                // Convert ignored files array format to match included files format
                const filePath = typeof file === 'string' ? file : file.path;
                const fileContent = typeof file === 'string' ? "" : file.content;
                
                // Estimate tokens in file content
                const tokenCount = estimateTokens(fileContent);
                totalFileCount++; // Increment total file count for the repo
                
                // Extract the relative path (remove repository path prefix if present)
                let relativePath = filePath;
                if (typeof relativePath === 'string' && relativePath.includes(repoName)) {
                    // Try to extract the relative path after the repository name
                    const parts = relativePath.split(repoName);
                    if (parts.length > 1) {
                        relativePath = parts[1].replace(/^[\/\\]/, ''); // Remove leading slash
                    }
                }
                
                // Split path into segments
                const pathSegments = relativePath.split(/[/\\]/);
                
                let currentLevelNode = root;
                const ancestorNodes = [root]; // Store ancestors, starting with root
                
                // Navigate through directories, creating as needed
                for (let i = 0; i < pathSegments.length - 1; i++) {
                    const segment = pathSegments[i];
                    if (!segment) continue; // Skip empty segments (e.g., from double slashes)
                    
                    // Build the directory path for this level (relative to repo root)
                    const dirPath = pathSegments.slice(0, i + 1).join('/');
                    
                    if (!currentLevelNode.children[segment]) {
                        currentLevelNode.children[segment] = { 
                            name: segment, 
                            type: 'directory',
                            children: {},
                            expanded: false,
                            fileCount: 0, // Initialize file count for new directory
                            tokenCount: 0, // Initialize token count for new directory
                            path: dirPath, // Store relative path for the directory
                            selected: !isIgnored, // Default selected state (true for included, false for ignored)
                            indeterminate: false,
                            isIgnored: isIgnored
                        };
                    }
                    // Increment file count for the directory containing this file/subdir
                    currentLevelNode.children[segment].fileCount++;
                    
                    // Move down to the next level node
                    currentLevelNode = currentLevelNode.children[segment];
                    ancestorNodes.push(currentLevelNode); // Add this directory to ancestors
                }
                
                // Add the file at the final level
                const fileName = pathSegments[pathSegments.length - 1];
                if (fileName) {
                    currentLevelNode.children[fileName] = { 
                        name: fileName, 
                        type: 'file',
                        path: filePath, // Store full original path
                        content: fileContent,
                        extension: getFileExtension(fileName),
                        tokenCount: tokenCount,
                        selected: !isIgnored, // Default selected state (true for included, false for ignored)
                        indeterminate: false,
                        isIgnored: isIgnored
                    };
                    
                    // Update token counts for all ancestors (directories and the root)
                    ancestorNodes.forEach(ancestor => {
                        ancestor.tokenCount += tokenCount;
                    });
                }
            });
            
            // Set the final file count for the root node
            root.fileCount = totalFileCount;

            // After building the tree, update all selection states from bottom to top
            // (This ensures indeterminate states are set correctly if loaded state is partially selected)
            updateSelectionStatesBottomUp(root);
            
            return root;
        }
        
        // Get file extension
        function getFileExtension(filename) {
            return filename.slice((filename.lastIndexOf('.') - 1 >>> 0) + 2);
        }
        
        // Get file icon based on extension
        function getFileIcon(extension) {
            const iconMap = {
                // Web
                'html': 'üìÑ',
                'css': 'üìÑ',
                'js': 'üìÑ',
                'jsx': 'üìÑ',
                'ts': 'üìÑ',
                'tsx': 'üìÑ',
                
                // Config
                'json': '‚öôÔ∏è',
                'yml': '‚öôÔ∏è',
                'yaml': '‚öôÔ∏è',
                'toml': '‚öôÔ∏è',
                'env': 'üîë',
                
                // Backend
                'py': 'üêç',
                'rb': 'üíé',
                'php': 'üêò',
                'java': '‚òï',
                'go': 'üöÄ',
                'rs': 'ü¶Ä',
                'c': 'üßÆ',
                'cpp': 'üßÆ',
                'cs': 'üßÆ',
                
                // Data
                'sql': 'üóÑÔ∏è',
                'csv': 'üìä',
                'xml': 'üìä',
                
                // Documents
                'md': 'üìù',
                'mdx': 'üìù',
                'txt': 'üìù',
                
                // Default
                'default': 'üìÑ'
            };
            
            return iconMap[extension.toLowerCase()] || iconMap.default;
        }
        
        // Render file tree
        function renderFileTree() {
            // Clear previous content
            fileTree.innerHTML = '';
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            let totalFileCount = 0;
            let selectedFileCount = 0;
            
            // Handle empty case
            if (fileTreeData.length === 0) {
                fileTree.innerHTML = `
                    <div class="tree-empty">
                        <div class="tree-empty-icon">üìÇ</div>
                        <p>No files loaded yet</p>
                    </div>
                `;
                return;
            }
            
            // Calculate counts first to ensure accuracy
            fileTreeData.forEach(repo => {
                totalTokenCount += repo.tokenCount;
                totalFileCount += repo.fileCount;
                
                // Count selected items
                if (repo.selected) {
                    selectedTokenCount += repo.tokenCount;
                    selectedFileCount += repo.fileCount;
                } else if (repo.indeterminate) {
                    // For indeterminate state, count only selected children
                    selectedTokenCount += getSelectedTokenCount(repo);
                    selectedFileCount += getSelectedFileCount(repo);
                }
            });

            // Now render the tree with accurate counts
            fileTreeData.forEach(repo => {
                const repoElement = document.createElement('div');
                repoElement.classList.add('tree-repo');
                // By default, repositories start collapsed
                // We're removing the expanded class by default
                repoElement.dataset.name = repo.name;
                
                // Repository header
                const repoHeader = document.createElement('div');
                repoHeader.classList.add('tree-repo-header');
                
                // Create checkbox wrapper
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.classList.add('checkbox-wrapper');
                
                // Create checkbox for repository
                const repoCheckbox = document.createElement('input');
                repoCheckbox.type = 'checkbox';
                repoCheckbox.checked = repo.selected;
                repoCheckbox.classList.add('tree-checkbox');
                
                // Add indeterminate state if needed
                if (repo.indeterminate) {
                    repoCheckbox.classList.add('indeterminate');
                    repoCheckbox.dataset.indeterminate = 'true';
                }
                
                // Stop event propagation on the checkbox
                repoCheckbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                repoCheckbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    
                    // Save expansion state before making changes
                    const expandedDirs = getExpansionState(repo.name);
                    const isRepoExpanded = !repoElement.querySelector('.tree-repo-content').classList.contains('hidden');
                    
                    // Apply selection state to repo and all its children
                    const isSelected = e.target.checked;
                    updateSelectionState(repo, isSelected);
                    
                    // Store expansion state in a temporary variable that will be accessed during rendering
                    window._pendingExpansionState = {
                        repoName: repo.name,
                        isRepoExpanded: isRepoExpanded,
                        expandedDirs: expandedDirs
                    };
                    
                    // Re-render tree immediately to reflect changes
                    renderFileTree();
                    
                    // Clear the temporary variable
                    window._pendingExpansionState = null;
                    
                    // Update the summary counts
                    updateFileSummary();
                    
                    // Save selection state to localStorage
                    saveSelectionState();
                });
                
                checkboxWrapper.appendChild(repoCheckbox);
                
                // Add collapse/expand indicator
                const collapseExpandIndicator = document.createElement('span');
                collapseExpandIndicator.classList.add('tree-repo-collapse-indicator');
                collapseExpandIndicator.textContent = '‚ñ∂'; // Collapsed state (triangle pointing right)
                
                repoHeader.innerHTML = `
                    <div class="tree-repo-name">
                        <span class="tree-repo-icon">üì¶</span>
                        ${repo.name}
                    </div>
                    <div class="tree-repo-stats">
                        ${repo.fileCount} files ¬∑ ~${formatTokenCount(repo.tokenCount)} tokens
                    </div>
                    <div class="tree-repo-actions">
                        <button class="tree-action-button copy-repo">Copy Selected</button>
                        <button class="tree-action-button expand-all">Expand All</button>
                        <button class="tree-action-button collapse-all">Collapse All</button>
                    </div>
                `;
                
                // Insert checkbox wrapper as first child
                repoHeader.insertBefore(checkboxWrapper, repoHeader.firstChild);
                
                // Insert collapse/expand indicator after checkbox
                repoHeader.querySelector('.tree-repo-name').insertBefore(collapseExpandIndicator, repoHeader.querySelector('.tree-repo-name').firstChild);
                
                // Repository content
                const repoContent = document.createElement('div');
                repoContent.classList.add('tree-repo-content');
                repoContent.classList.add('hidden'); // Initially hidden
                
                // Check if we should expand this repo based on pending expansion state
                const repoExpandState = window._pendingExpansionState;
                if (repoExpandState && repoExpandState.repoName === repo.name && repoExpandState.isRepoExpanded) {
                    repoContent.classList.remove('hidden');
                    collapseExpandIndicator.textContent = '‚ñº'; // Expanded state
                }
                
                // Get all top-level children (files and directories)
                const sortedChildren = Object.values(repo.children)
                    .sort((a, b) => {
                        // Apply sorting based on the selected option
                        const sortOption = treeSortSelect.value;
                        
                        switch (sortOption) {
                            case 'name-asc':
                                return a.name.localeCompare(b.name);
                            case 'name-desc':
                                return b.name.localeCompare(a.name);
                            case 'tokens-desc':
                                return b.tokenCount - a.tokenCount;
                            case 'tokens-asc':
                                return a.tokenCount - b.tokenCount;
                            case 'default':
                            default:
                                // Default sorting: directories first, then files alphabetically
                                if (a.type !== b.type) {
                                    return a.type === 'directory' ? -1 : 1;
                                }
                                return a.name.localeCompare(b.name);
                        }
                    });
                
                sortedChildren.forEach(child => {
                    if (child.type === 'directory') {
                        repoContent.appendChild(renderDirectory(child, repo.name));
                    } else {
                        repoContent.appendChild(renderFile(child, repo.name));
                    }
                });
                
                // Keep existing event listeners for expand/collapse all
                const expandAllBtn = repoHeader.querySelector('.expand-all');
                expandAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // First expand this repo
                    repoContent.classList.remove('hidden');
                    collapseExpandIndicator.textContent = '‚ñº'; // Expanded state
                    
                    // Then expand all directories within
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.add('expanded');
                        dir.querySelector('.tree-directory-icon').textContent = '‚ñº';
                    });
                });
                
                const collapseAllBtn = repoHeader.querySelector('.collapse-all');
                collapseAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Collapse all directories, but leave the repo itself expanded
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.remove('expanded');
                        dir.querySelector('.tree-directory-icon').textContent = '‚ñ∂';
                    });
                });
                
                // Add copy repository button functionality
                const copyRepoBtn = repoHeader.querySelector('.copy-repo');
                copyRepoBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    copyRepoContents(repo);
                });
                
                // Toggle repository content on header click
                repoHeader.addEventListener('click', (e) => {
                    // Only toggle if not clicking on checkbox, its wrapper, or action buttons
                    if (!e.target.closest('.checkbox-wrapper') && !e.target.closest('.tree-action-button')) {
                        repoContent.classList.toggle('hidden');
                        // Update the collapse/expand indicator
                        if (repoContent.classList.contains('hidden')) {
                            collapseExpandIndicator.textContent = '‚ñ∂'; // Collapsed state
                        } else {
                            collapseExpandIndicator.textContent = '‚ñº'; // Expanded state
                        }
                    }
                });
                
                repoElement.appendChild(repoHeader);
                repoElement.appendChild(repoContent);
                fileTree.appendChild(repoElement);
                
                // Apply expanded directories from pending state (if any)
                const pendingDirState = window._pendingExpansionState;
                if (pendingDirState && pendingDirState.repoName === repo.name && pendingDirState.expandedDirs && pendingDirState.expandedDirs.length > 0) {
                    pendingDirState.expandedDirs.forEach(path => {
                        applyExpansionPath(repoElement, path);
                    });
                }
            });
            
            // Update the included count with selected token information
            includedCount.textContent = `${selectedFileCount} of ${totalFileCount} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens`;

            // Update total tokens count above the Copy button
            const totalTokensCount = document.getElementById('total-tokens-count');
            if (totalTokensCount) {
                totalTokensCount.textContent = formatTokenCount(selectedTokenCount);
            }

            // Apply search filter if search input has value
            applySearchFilter();
        }
        
        // Render ignored file tree - similar to renderFileTree but for ignored files
        function renderIgnoredFileTree() {
            // Clear previous content
            ignoredFileTree.innerHTML = '';
            let totalIgnoredFileCount = 0;
            let selectedIgnoredFileCount = 0;
            
            // Handle empty case
            if (ignoredTreeData.length === 0) {
                ignoredFileTree.innerHTML = `
                    <div class="tree-empty">
                        <div class="tree-empty-icon">üìÇ</div>
                        <p>No ignored files loaded yet</p>
                    </div>
                `;
                return;
            }
            
            // Calculate counts first to ensure accuracy
            ignoredTreeData.forEach(repo => {
                totalIgnoredFileCount += repo.fileCount;
                
                // Count selected items
                if (repo.selected) {
                    selectedIgnoredFileCount += repo.fileCount;
                } else if (repo.indeterminate) {
                    // For indeterminate state, count only selected children
                    selectedIgnoredFileCount += getSelectedFileCount(repo);
                }
            });

            // Now render the tree with accurate counts
            ignoredTreeData.forEach(repo => {
                const repoElement = document.createElement('div');
                repoElement.classList.add('tree-repo');
                // By default, repositories start collapsed
                repoElement.dataset.name = repo.name;
                
                // Repository header
                const repoHeader = document.createElement('div');
                repoHeader.classList.add('tree-repo-header');
                
                // Create checkbox wrapper
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.classList.add('checkbox-wrapper');
                
                // Create checkbox for repository
                const repoCheckbox = document.createElement('input');
                repoCheckbox.type = 'checkbox';
                repoCheckbox.checked = repo.selected;
                repoCheckbox.classList.add('tree-checkbox');
                
                // Add indeterminate state if needed
                if (repo.indeterminate) {
                    repoCheckbox.classList.add('indeterminate');
                    repoCheckbox.dataset.indeterminate = 'true';
                }
                
                // Stop event propagation on the checkbox
                repoCheckbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                repoCheckbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    
                    // Save expansion state before making changes
                    const expandedDirs = getExpansionState(repo.name, true);
                    const isRepoExpanded = !repoElement.querySelector('.tree-repo-content').classList.contains('hidden');
                    
                    // Apply selection state to repo and all its children
                    const isSelected = e.target.checked;
                    updateSelectionState(repo, isSelected);
                    
                    // Store expansion state in a temporary variable that will be accessed during rendering
                    window._pendingExpansionState = {
                        repoName: repo.name,
                        isRepoExpanded: isRepoExpanded,
                        expandedDirs: expandedDirs
                    };
                    
                    // Re-render tree immediately to reflect changes
                    renderIgnoredFileTree();
                    
                    // Clear the temporary variable
                    window._pendingExpansionState = null;
                    
                    // Update the summary counts
                    updateFileSummary();
                    
                    // Save selection state to localStorage
                    saveSelectionState();
                });
                
                checkboxWrapper.appendChild(repoCheckbox);
                
                // Add collapse/expand indicator
                const collapseExpandIndicator = document.createElement('span');
                collapseExpandIndicator.classList.add('tree-repo-collapse-indicator');
                collapseExpandIndicator.textContent = '‚ñ∂'; // Collapsed state (triangle pointing right)
                
                repoHeader.innerHTML = `
                    <div class="tree-repo-name">
                        <span class="tree-repo-icon">üì¶</span>
                        ${repo.name}
                    </div>
                    <div class="tree-repo-stats">
                        ${repo.fileCount} files
                    </div>
                    <div class="tree-repo-actions">
                        <button class="tree-action-button copy-repo">Copy Selected</button>
                        <button class="tree-action-button expand-all">Expand All</button>
                        <button class="tree-action-button collapse-all">Collapse All</button>
                    </div>
                `;
                
                // Insert checkbox wrapper as first child
                repoHeader.insertBefore(checkboxWrapper, repoHeader.firstChild);
                
                // Insert collapse/expand indicator after checkbox
                repoHeader.querySelector('.tree-repo-name').insertBefore(collapseExpandIndicator, repoHeader.querySelector('.tree-repo-name').firstChild);
                
                // Repository content
                const repoContent = document.createElement('div');
                repoContent.classList.add('tree-repo-content');
                repoContent.classList.add('hidden'); // Initially hidden
                
                // Check if we should expand this repo based on pending expansion state
                const repoExpandState = window._pendingExpansionState;
                if (repoExpandState && repoExpandState.repoName === repo.name && repoExpandState.isRepoExpanded) {
                    repoContent.classList.remove('hidden');
                    collapseExpandIndicator.textContent = '‚ñº'; // Expanded state
                }
                
                // Get all top-level children
                const sortedChildren = Object.values(repo.children)
                    .sort((a, b) => {
                        // Apply sorting based on the selected option
                        const sortOption = ignoredTreeSortSelect.value;
                        
                        switch (sortOption) {
                            case 'name-asc':
                                return a.name.localeCompare(b.name);
                            case 'name-desc':
                                return b.name.localeCompare(a.name);
                            case 'default':
                            default:
                                // Default sorting: directories first, then files alphabetically
                                if (a.type !== b.type) {
                                    return a.type === 'directory' ? -1 : 1;
                                }
                                return a.name.localeCompare(b.name);
                        }
                    });
                
                sortedChildren.forEach(child => {
                    if (child.type === 'directory') {
                        repoContent.appendChild(renderDirectory(child, repo.name));
                    } else {
                        repoContent.appendChild(renderFile(child, repo.name));
                    }
                });
                
                // Keep existing event listeners for expand/collapse all
                const expandAllBtn = repoHeader.querySelector('.expand-all');
                expandAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // First expand this repo
                    repoContent.classList.remove('hidden');
                    collapseExpandIndicator.textContent = '‚ñº'; // Expanded state
                    
                    // Then expand all directories within
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.add('expanded');
                        dir.querySelector('.tree-directory-icon').textContent = '‚ñº';
                    });
                });
                
                const collapseAllBtn = repoHeader.querySelector('.collapse-all');
                collapseAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Collapse all directories, but leave the repo itself expanded
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.remove('expanded');
                        dir.querySelector('.tree-directory-icon').textContent = '‚ñ∂';
                    });
                });
                
                // Add copy repository button functionality
                const copyRepoBtn = repoHeader.querySelector('.copy-repo');
                copyRepoBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // For ignored trees we need to use the ignored data
                    copyRepoContents(repo, true);
                });
                
                // Toggle repository content on header click
                repoHeader.addEventListener('click', (e) => {
                    // Only toggle if not clicking on checkbox, its wrapper, or action buttons
                    if (!e.target.closest('.checkbox-wrapper') && !e.target.closest('.tree-action-button')) {
                        repoContent.classList.toggle('hidden');
                        // Update the collapse/expand indicator
                        if (repoContent.classList.contains('hidden')) {
                            collapseExpandIndicator.textContent = '‚ñ∂'; // Collapsed state
                        } else {
                            collapseExpandIndicator.textContent = '‚ñº'; // Expanded state
                        }
                    }
                });
                
                repoElement.appendChild(repoHeader);
                repoElement.appendChild(repoContent);
                ignoredFileTree.appendChild(repoElement);
                
                // Apply expanded directories from pending state (if any)
                const pendingDirState = window._pendingExpansionState;
                if (pendingDirState && pendingDirState.repoName === repo.name && pendingDirState.expandedDirs && pendingDirState.expandedDirs.length > 0) {
                    pendingDirState.expandedDirs.forEach(path => {
                        applyExpansionPath(repoElement, path);
                    });
                }
            });
            
            // Update the ignored count with selected file information
            ignoredCount.textContent = `${selectedIgnoredFileCount} of ${totalIgnoredFileCount} files`;

            // Apply search filter if search input has value
            applyIgnoredSearchFilter();
        }
        
        // Get selected file count from a node (repo or directory)
        function getSelectedFileCount(node) {
            if (node.type === 'file') {
                return node.selected ? 1 : 0;
            }
            
            // Removed the faulty check: if (!node.selected) return 0;
            // Always recurse down. If a directory/repo is truly deselected 
            // (selected=false, indeterminate=false), the recursive calls 
            // to its children will correctly return 0.
            
            let count = 0;
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    count += getSelectedFileCount(child);
                });
            }
            return count;
        }
        
        // Update selection state recursively
        function updateSelectionState(node, isSelected) {
            // Update this node's selection state
            node.selected = isSelected;
            // Clear indeterminate state when explicitly selected/deselected
            node.indeterminate = false;
            
            // Apply to all children recursively
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    updateSelectionState(child, isSelected);
                });
            }
        }
        
        // Check if all children of a node are selected
        function areAllChildrenSelected(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return true;
            }
            
            return Object.values(node.children).every(child => {
                return child.selected && (child.type === 'file' || areAllChildrenSelected(child));
            });
        }
        
        // Check if any children of a node are selected
        function areAnyChildrenSelected(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return false;
            }
            
            return Object.values(node.children).some(child => {
                return child.selected || (child.type !== 'file' && areAnyChildrenSelected(child));
            });
        }
        
        // Update parent selection states based on children
        function updateParentSelectionState(parentNode) {
            if (!parentNode.children || Object.keys(parentNode.children).length === 0) {
                return;
            }
            
            const allSelected = areAllChildrenSelected(parentNode);
            const anySelected = areAnyChildrenSelected(parentNode);
            
            // Set the node's selected state based on children
            if (allSelected) {
                parentNode.selected = true;
                parentNode.indeterminate = false;
            } else if (!anySelected) {
                parentNode.selected = false;
                parentNode.indeterminate = false;
            } else {
                // Some but not all children are selected
                parentNode.selected = false;
                parentNode.indeterminate = true;
            }
            
            return { allSelected, anySelected, indeterminate: parentNode.indeterminate };
        }
        
        // Update selection states from bottom to top
        function updateSelectionStatesBottomUp(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return;
            }
            
            // First update all children recursively
            Object.values(node.children).forEach(child => {
                if (child.type === 'directory') {
                    updateSelectionStatesBottomUp(child);
                }
            });
            
            // Then update this node based on its children
            const allSelected = areAllChildrenSelected(node);
            const anySelected = areAnyChildrenSelected(node);
            
            // Update selection state
            if (allSelected) {
                node.selected = true;
                node.indeterminate = false;
            } else if (!anySelected) {
                node.selected = false;
                node.indeterminate = false;
            } else {
                // Some but not all children are selected
                node.selected = false;
                node.indeterminate = true;
            }
        }
        
        // Render directory
        function renderDirectory(directory, repoName) {
            const dirElement = document.createElement('div');
            dirElement.classList.add('tree-directory');
            dirElement.dataset.name = directory.name;
            
            // Directory header
            const dirHeader = document.createElement('div');
            dirHeader.classList.add('tree-directory-header');
            
            // Create checkbox wrapper
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.classList.add('checkbox-wrapper');
            
            // Create checkbox for directory
            const dirCheckbox = document.createElement('input');
            dirCheckbox.type = 'checkbox';
            dirCheckbox.checked = directory.selected;
            dirCheckbox.classList.add('tree-checkbox');
            
            // Add indeterminate state if needed
            if (directory.indeterminate) {
                dirCheckbox.indeterminate = true;
                dirCheckbox.classList.add('indeterminate');
                dirCheckbox.dataset.indeterminate = 'true';
            }
            
            // Handle checkbox directly - IMPORTANT: Stop both click and change events
            dirCheckbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop event from reaching dirHeader
            });
            
            dirCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Get the new selection state
                const isSelected = e.target.checked;
                
                // Apply selection state to directory and ALL its children recursively
                updateSelectionState(directory, isSelected);
                
                // Track if this directory was expanded before the change
                const wasExpanded = dirElement.classList.contains('expanded');
                
                // Update the directory's visuals without replacing the whole element
                // Just update the checkbox state and any visual indicators
                dirCheckbox.checked = directory.selected;
                dirCheckbox.indeterminate = directory.indeterminate;
                
                if (directory.indeterminate) {
                    dirCheckbox.classList.add('indeterminate');
                    dirCheckbox.dataset.indeterminate = 'true';
                } else {
                    dirCheckbox.classList.remove('indeterminate');
                    dirCheckbox.dataset.indeterminate = 'false';
                }
                
                // Recursively update child checkboxes
                updateChildCheckboxes(dirElement, directory.selected);
                
                // Make sure expanded state is preserved
                if (wasExpanded) {
                    dirElement.classList.add('expanded');
                }
                
                // Update parent selection states bottom-up
                updateTreeSelectionStates();
                
                // Update the summary counts only - no need to rebuild the entire tree
                updateFileSummaryWithoutRender();
                
                // Save selection state to localStorage
                saveSelectionState();
            });
            
            checkboxWrapper.appendChild(dirCheckbox);
            
            // Directory header with name and stats
            const dirHeaderContent = document.createElement('div');
            dirHeaderContent.classList.add('directory-header-content');
            dirHeaderContent.innerHTML = `
                <div class="tree-directory-name">
                    <span class="tree-directory-icon">‚ñ∂</span>
                    <span>üìÇ ${directory.name}</span>
                </div>
                <div class="tree-directory-stats">
                    <span class="tree-directory-file-count">${directory.fileCount} files</span>
                    <span class="tree-directory-token-count">~${directory.isIgnored ? "Unknown" : formatTokenCount(directory.tokenCount)} tokens</span>
                </div>
            `;
            
            // Create action buttons container
            const actionBtns = document.createElement('div');
            actionBtns.classList.add('tree-item-actions');
            
            // Add copy button
            const copyBtn = document.createElement('button');
            copyBtn.classList.add('tree-action-icon', 'copy-btn');
            copyBtn.title = "Copy directory contents";
            copyBtn.innerHTML = "üìã";
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                copyDirectoryContents(directory, repoName);
            });
            
            actionBtns.appendChild(copyBtn);
            
            // Add elements to header in correct order
            dirHeader.appendChild(checkboxWrapper);
            dirHeader.appendChild(dirHeaderContent);
            dirHeader.appendChild(actionBtns);
            
            // Directory content
            const dirContent = document.createElement('div');
            dirContent.classList.add('tree-directory-content');
            
            // Add directory children (subdirectories and files)
            const sortedChildren = Object.values(directory.children)
                .sort((a, b) => {
                    // Directories first, then files
                    if (a.type !== b.type) {
                        return a.type === 'directory' ? -1 : 1;
                    }
                    // Alphabetical within same type
                    return a.name.localeCompare(b.name);
                });
            
            sortedChildren.forEach(child => {
                if (child.type === 'directory') {
                    dirContent.appendChild(renderDirectory(child, repoName));
                } else {
                    dirContent.appendChild(renderFile(child, repoName));
                }
            });
            
            // Toggle directory expansion on header click (but not on action buttons)
            dirHeaderContent.addEventListener('click', (e) => {
                // Only toggle if not clicking on checkbox or its wrapper
                if (!e.target.closest('.checkbox-wrapper')) {
                    e.stopPropagation();
                    dirElement.classList.toggle('expanded');
                    
                    // Update the icon
                    const icon = dirHeaderContent.querySelector('.tree-directory-icon');
                    if (dirElement.classList.contains('expanded')) {
                        icon.textContent = '‚ñº'; // Expanded state
                    } else {
                        icon.textContent = '‚ñ∂'; // Collapsed state
                    }
                }
            });
            
            dirElement.appendChild(dirHeader);
            dirElement.appendChild(dirContent);
            return dirElement;
        }
        
        // Update all child checkboxes in the DOM
        function updateChildCheckboxes(parentElement, isSelected) {
            const childCheckboxes = parentElement.querySelectorAll('.tree-checkbox');
            childCheckboxes.forEach(checkbox => {
                checkbox.checked = isSelected;
                checkbox.indeterminate = false;
                checkbox.classList.remove('indeterminate');
                checkbox.dataset.indeterminate = 'false';
            });
        }
        
        // Render file
        function renderFile(file, repoName) {
            const fileElement = document.createElement('div');
            fileElement.classList.add('tree-file');
            if (file.extension) {
                fileElement.classList.add(file.extension.toLowerCase());
            }
            fileElement.dataset.name = file.name;
            fileElement.dataset.path = file.path;
            fileElement.dataset.repo = repoName;
            fileElement.dataset.tokens = file.tokenCount || 0;
            
            // File name parts
            const nameParts = file.name.split('.');
            const baseName = nameParts.length > 1 ? nameParts.slice(0, -1).join('.') : nameParts[0];
            const extension = nameParts.length > 1 ? nameParts[nameParts.length - 1] : '';
            
            // File icon
            const fileIcon = getFileIcon(file.extension || '');
            
            // Create checkbox wrapper
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.classList.add('checkbox-wrapper');
            
            // Create checkbox for file
            const fileCheckbox = document.createElement('input');
            fileCheckbox.type = 'checkbox';
            fileCheckbox.checked = file.selected;
            fileCheckbox.classList.add('tree-checkbox');
            
            // Handle checkbox directly
            fileCheckbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop event from propagating
            });
            
            fileCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Update this file's selection state
                file.selected = e.target.checked;
                
                // Find parent directory and update up the tree
                updateTreeSelectionStates();
                
                // Update just the checkbox appearance
                applyCheckboxState(fileCheckbox, file);
                
                // Update the summary counts
                updateFileSummaryWithoutRender();
                
                // Save selection state to localStorage
                saveSelectionState();
            });
            
            checkboxWrapper.appendChild(fileCheckbox);
            
            // Create file info content (filename and tokens)
            const fileInfo = document.createElement('div');
            fileInfo.classList.add('file-info');
            fileInfo.innerHTML = `
                <span class="tree-file-icon">${fileIcon}</span>
                <span class="tree-file-name">${baseName}<span class="tree-file-ext">.${extension}</span></span>
                <span class="tree-file-tokens">~${file.isIgnored ? "Unknown" : formatTokenCount(file.tokenCount || 0)}</span>
            `;
            
            // Create action buttons container
            const actionBtns = document.createElement('div');
            actionBtns.classList.add('tree-item-actions');
            
            // Add preview button
            const previewBtn = document.createElement('button');
            previewBtn.classList.add('tree-action-icon', 'preview-btn');
            previewBtn.title = "Preview file";
            previewBtn.innerHTML = "üëÅÔ∏è";
            previewBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (file.content) {
                    showFilePreview(file);
                } else if (file.isIgnored) {
                    showNotification('Cannot preview ignored file content', 'info');
                }
            });
            
            // Add copy button
            const copyBtn = document.createElement('button');
            copyBtn.classList.add('tree-action-icon', 'copy-btn');
            copyBtn.title = "Copy file contents";
            copyBtn.innerHTML = "üìã";
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                copyFileContents(file, repoName);
            });
            
            // Add buttons to the actions container
            actionBtns.appendChild(previewBtn);
            actionBtns.appendChild(copyBtn);
            
            // Create file element structure
            const fileContent = document.createElement('div');
            fileContent.classList.add('tree-file-content');
            
            // Add all elements to file content
            fileContent.appendChild(checkboxWrapper);
            fileContent.appendChild(fileInfo);
            fileContent.appendChild(actionBtns);
            
            fileElement.appendChild(fileContent);
            
            return fileElement;
        }
        
        // Function to copy file contents
        function copyFileContents(file, repoName) {
            if (!file.content && file.isIgnored) {
                showNotification('Cannot copy ignored file content (content not loaded)', 'info');
                return;
            }
            
            const repo = selectedRepos.find(r => r.name === repoName);
            if (!repo) return;
            
            const content = `Repository: ${repoName}\nAbsolute Path: ${file.path} :\n${file.content || ""}`;
            
            // Try to copy to clipboard using the browser API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content)
                    .then(() => {
                        showNotification(`üìã File "${file.name}" copied to clipboard!`, 'success');
                    })
                    .catch(err => {
                        // Fall back to the server-side API if browser API fails
                        fallbackCopyToClipboard([{
                            name: repoName,
                            path: repo.path,
                            files: [{
                                path: file.path,
                                content: file.content || ""
                            }]
                        }]);
                    });
            } else {
                // Fall back to the server-side API if browser API is not available
                fallbackCopyToClipboard([{
                    name: repoName,
                    path: repo.path,
                    files: [{
                        path: file.path,
                        content: file.content || ""
                    }]
                }]);
            }
        }
        
        // Function to copy directory contents
        function copyDirectoryContents(directory, repoName) {
            // Get all selected files in this directory
            const files = getSelectedFiles(directory);
            if (files.length === 0) {
                showNotification(`No files to copy in "${directory.name}"`, 'info');
                return;
            }
            
            const repo = selectedRepos.find(r => r.name === repoName);
            if (!repo) return;
            
            // Format content in the same format as the main copy functionality
            const content = files.map(file => 
                `Repository: ${repoName}\nAbsolute Path: ${file.path} :\n${file.content || ""}`
            ).join('\n\n');
            
            // Try to copy to clipboard using the browser API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content)
                    .then(() => {
                        showNotification(`üìã Directory "${directory.name}" contents (${files.length} files) copied to clipboard!`, 'success');
                    })
                    .catch(err => {
                        // Fall back to the server-side API if browser API fails
                        fallbackCopyToClipboard([{
                            name: repoName,
                            path: repo.path,
                            files: files
                        }]);
                    });
            } else {
                // Fall back to the server-side API if browser API is not available
                fallbackCopyToClipboard([{
                    name: repoName,
                    path: repo.path,
                    files: files
                }]);
            }
        }
        
        // Fallback to the server-side copy API
        function fallbackCopyToClipboard(data) {
            axios.post('/api/copy-to-clipboard', { selectedRepos: data })
                .then(response => {
                    let totalFiles = 0;
                    data.forEach(repo => {
                        totalFiles += repo.files.length;
                    });
                    
                    showNotification(`üìã ${totalFiles} files copied to clipboard!`, 'success');
                })
                .catch(error => {
                    showNotification('Error copying to clipboard: ' + error.message, 'error');
                });
        }
        
        // Get current selection state
        function getSelectionState() {
            if ((!fileTreeData || fileTreeData.length === 0) && 
                (!ignoredTreeData || ignoredTreeData.length === 0)) return null;
            
            const state = {
                included: {},
                ignored: {}
            };
            
            // Save included files selection state
            fileTreeData.forEach(repo => {
                state.included[repo.name] = {
                    deselectedPaths: getNodeSelectionPaths(repo),
                    expansionState: getExpansionState(repo.name, false)
                };
            });
            
            // Save ignored files selection state
            ignoredTreeData.forEach(repo => {
                state.ignored[repo.name] = {
                    selectedPaths: getNodeSelectionPaths(repo, '', true),
                    expansionState: getExpansionState(repo.name, true)
                };
            });
            
            return state;
        }
        
        // Get all paths that are NOT selected for included files,
        // or paths that ARE selected for ignored files
        function getNodeSelectionPaths(node, basePath = '', isIgnored = false) {
            let paths = [];
            
            // For files
            if (node.type === 'file') {
                // For included files, store deselected paths
                // For ignored files, store selected paths
                if ((!isIgnored && !node.selected) || (isIgnored && node.selected)) {
                    // Use the full file path instead of just the name
                    paths.push(node.path);
                }
            } 
            // For directories
            else if (node.type === 'directory' || node.type === 'repo') {
                // For completely deselected directories in included files
                // or completely selected directories in ignored files
                if (((!isIgnored && !node.selected && !node.indeterminate) || 
                     (isIgnored && node.selected && !node.indeterminate)) && 
                    node.type === 'directory') {
                    
                    // For directories, use relative path within the repo
                    paths.push(basePath + (node.name || ''));
                } 
                // For directories with mixed selection, check children
                else if (node.children) {
                    Object.entries(node.children).forEach(([childName, child]) => {
                        const childPath = basePath + (node.name && node.type === 'directory' ? node.name + '/' : '') + childName;
                        paths = paths.concat(getNodeSelectionPaths(child, childPath, isIgnored));
                    });
                }
            }
            
            return paths;
        }
        
        // Get current expansion state (which directories are expanded)
        function getExpansionState(repoName, isIgnored = false) {
            const expandedDirs = [];
            const treeContainer = isIgnored ? ignoredFileTree : fileTree;
            const repoElement = treeContainer.querySelector(`.tree-repo[data-name="${repoName}"]`);
            
            if (repoElement) {
                // Get all expanded directories
                const dirs = repoElement.querySelectorAll('.tree-directory.expanded');
                dirs.forEach(dir => {
                    // Build path from repo name to this directory
                    let path = dir.dataset.name;
                    let parent = dir.parentElement.closest('.tree-directory');
                    
                    while (parent) {
                        path = parent.dataset.name + '/' + path;
                        parent = parent.parentElement.closest('.tree-directory');
                    }
                    
                    expandedDirs.push(path);
                });
            }
            
            return expandedDirs;
        }
        
        // Apply selection state saved previously
        function applySelectionState(state) {
            if (!state) return;
            
            // Apply to included files
            if (state.included && fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    const repoState = state.included[repo.name];
                    if (!repoState) return;
                    
                    // First reset all selections to true (default state for included files)
                    resetSelectionState(repo, true);
                    
                    // Apply deselected paths
                    if (repoState.deselectedPaths) {
                        repoState.deselectedPaths.forEach(path => {
                            applySelectionPath(repo, path, false);
                        });
                    }
                });
                
                // Update all parent selection states bottom-up
                fileTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
            }
            
            // Apply to ignored files
            if (state.ignored && ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    const repoState = state.ignored[repo.name];
                    if (!repoState) return;
                    
                    // First reset all selections to false (default state for ignored files)
                    resetSelectionState(repo, false);
                    
                    // Apply selected paths
                    if (repoState.selectedPaths) {
                        repoState.selectedPaths.forEach(path => {
                            applySelectionPath(repo, path, true);
                        });
                    }
                });
                
                // Update all parent selection states bottom-up
                ignoredTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
            }
        }
        
        // Apply selection to a specific path
        function applySelectionPath(node, path, value) {
            // Direct match for file paths - handles both stored relative and absolute paths
            if (node.type === 'file' && (path === node.path || path === node.name)) {
                node.selected = value;
                return true;
            }
            
            // Direct match for directory names
            if ((node.type === 'directory' || node.type === 'repo') && path === node.name) {
                node.selected = value;
                if (node.children) {
                    Object.values(node.children).forEach(child => {
                        resetSelectionState(child, value);
                    });
                }
                return true;
            }
            
            // Handle nested paths for directories
            if (path.startsWith(node.name + '/') && node.children) {
                const remainingPath = path.substring(node.name.length + 1);
                const nextSegment = remainingPath.split('/')[0];
                
                if (node.children[nextSegment]) {
                    return applySelectionPath(node.children[nextSegment], remainingPath, value);
                }
            }
            
            // Handle absolute file paths match - traverse all children looking for matching path
            if (node.children && node.type !== 'file') {
                for (const child of Object.values(node.children)) {
                    if (child.type === 'file' && child.path === path) {
                        child.selected = value;
                        return true;
                    }
                    
                    // Recursively search directories
                    if (child.type !== 'file' && applySelectionPath(child, path, value)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Reset selection state of node and all children
        function resetSelectionState(node, value) {
            node.selected = value;
            node.indeterminate = false;
            
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    resetSelectionState(child, value);
                });
            }
        }
        
        // Apply expansion state
        function applyExpansionState(state) {
            if (!state) return;
            
            // Apply after the trees have been rendered
            setTimeout(() => {
                // Apply to included files
                if (state.included) {
                    Object.keys(state.included).forEach(repoName => {
                        const repoState = state.included[repoName];
                        if (!repoState || !repoState.expansionState) return;
                        
                        const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repoName}"]`);
                        if (!repoElement) return;
                        
                        // Apply each expanded directory path
                        repoState.expansionState.forEach(path => {
                            applyExpansionPath(repoElement, path);
                        });
                    });
                }
                
                // Apply to ignored files
                if (state.ignored) {
                    Object.keys(state.ignored).forEach(repoName => {
                        const repoState = state.ignored[repoName];
                        if (!repoState || !repoState.expansionState) return;
                        
                        const repoElement = ignoredFileTree.querySelector(`.tree-repo[data-name="${repoName}"]`);
                        if (!repoElement) return;
                        
                        // Apply each expanded directory path
                        repoState.expansionState.forEach(path => {
                            applyExpansionPath(repoElement, path);
                        });
                    });
                }
            }, 100);
        }
        
        // Apply expansion to a specific path
        function applyExpansionPath(repoElement, path) {
            const segments = path.split('/');
            let currentElement = repoElement;
            
            // Navigate through segments to find the directory
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const dirElement = currentElement.querySelector(`.tree-directory[data-name="${segment}"]`);
                
                if (dirElement) {
                    dirElement.classList.add('expanded');
                    currentElement = dirElement;
                } else {
                    break;
                }
            }
        }
        
        // Update tree selection states bottom-up
        function updateTreeSelectionStates() {
            // Update both included and ignored trees
            
            // Update included files tree from bottom to top
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
                
                // Update tree UI to reflect new states
                updateTreeCheckboxes(fileTree, fileTreeData);
            }
            
            // Update ignored files tree from bottom to top
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
                
                // Update tree UI to reflect new states if the ignored tree is expanded
                if (!ignoredContent.classList.contains('hidden')) {
                    updateTreeCheckboxes(ignoredFileTree, ignoredTreeData);
                }
            }
            
            // Save selection state
            saveSelectionState();
        }
        
        // Update all checkboxes in a tree to match data model
        function updateTreeCheckboxes(treeContainer, treeData) {
            const checkboxes = treeContainer.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => {
                const parentElement = checkbox.closest('.tree-repo, .tree-directory, .tree-file');
                
                if (parentElement) {
                    // Find matching node in data
                    let node = null;
                    
                    if (parentElement.classList.contains('tree-repo')) {
                        const repoName = parentElement.dataset.name;
                        node = treeData.find(r => r.name === repoName);
                    }
                    else if (parentElement.classList.contains('tree-directory')) {
                        const dirName = parentElement.dataset.name;
                        const repoElement = parentElement.closest('.tree-repo');
                        if (repoElement) {
                            const repoName = repoElement.dataset.name;
                            const repo = treeData.find(r => r.name === repoName);
                            if (repo) {
                                // Find directory by name
                                node = findNodeByName(repo, dirName);
                            }
                        }
                    }
                    else if (parentElement.classList.contains('tree-file')) {
                        const filePath = parentElement.dataset.path;
                        const repoName = parentElement.dataset.repo;
                        if (repoName) {
                            const repo = treeData.find(r => r.name === repoName);
                            if (repo) {
                                // Find file by path
                                node = findNodeByPath(repo, filePath);
                            }
                        }
                    }
                    
                    // Update checkbox state to match data
                    if (node) {
                        applyCheckboxState(checkbox, node);
                    }
                }
            });
        }
        
        // Find a node by name in a tree
        function findNodeByName(root, name) {
            if (root.name === name) {
                return root;
            }
            
            if (root.children) {
                for (const child of Object.values(root.children)) {
                    const found = findNodeByName(child, name);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // Find a node by path in a tree
        function findNodeByPath(root, path) {
            if (root.path === path) {
                return root;
            }
            
            if (root.children) {
                for (const child of Object.values(root.children)) {
                    const found = findNodeByPath(child, path);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // Apply checkbox state based on node
        function applyCheckboxState(checkbox, node) {
            checkbox.checked = node.selected;
            
            if (node.indeterminate) {
                checkbox.indeterminate = true;
                checkbox.classList.add('indeterminate');
                checkbox.dataset.indeterminate = 'true';
            } else {
                checkbox.indeterminate = false;
                checkbox.classList.remove('indeterminate');
                checkbox.dataset.indeterminate = 'false';
            }
        }
        
        // Save selection state to localStorage
        function saveSelectionState() {
            if ((!fileTreeData || fileTreeData.length === 0) && 
                (!ignoredTreeData || ignoredTreeData.length === 0)) return;
            
            try {
                // Get current state for included and ignored files
                const state = {
                    included: {},
                    ignored: {}
                };
                
                // Save included files state
                if (fileTreeData && fileTreeData.length > 0) {
                    fileTreeData.forEach(repo => {
                        state.included[repo.name] = {
                            deselectedPaths: getNodeSelectionPaths(repo),
                            expansionState: getExpansionState(repo.name, false)
                        };
                    });
                }
                
                // Save ignored files state
                if (ignoredTreeData && ignoredTreeData.length > 0) {
                    ignoredTreeData.forEach(repo => {
                        state.ignored[repo.name] = {
                            selectedPaths: getNodeSelectionPaths(repo, '', true),
                            expansionState: getExpansionState(repo.name, true)
                        };
                    });
                }
                
                // Save to localStorage with a key that includes the repository paths
                const repoKey = selectedRepos.map(r => r.path).sort().join(',');
                localStorage.setItem(`repo_selection_${repoKey}`, JSON.stringify(state));
            } catch (e) {
                console.error('Error saving selection state:', e);
            }
        }
        
        // Restore selection state from localStorage on page load
        function restoreSelectionState() {
            try {
                if (!selectedRepos || selectedRepos.length === 0) return;
                
                // Generate key from repository paths
                const repoKey = selectedRepos.map(r => r.path).sort().join(',');
                const savedState = localStorage.getItem(`repo_selection_${repoKey}`);
                
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    // Convert old format to new format if needed (compatibility)
                    if (!state.included && !state.ignored) {
                        // Old format - convert to new format
                        const newState = {
                            included: {},
                            ignored: {}
                        };
                        
                        Object.keys(state).forEach(repoName => {
                            if (Array.isArray(state[repoName])) {
                                // Old format - just deselected paths for included files
                                newState.included[repoName] = {
                                    deselectedPaths: state[repoName],
                                    expansionState: []
                                };
                            } else {
                                // Newer format with nested structure but not separate included/ignored
                                newState.included[repoName] = state[repoName];
                            }
                        });
                        
                        // Apply the converted state
                        applySelectionState(newState);
                        applyExpansionState(newState);
                    } else {
                        // New format with separate included/ignored sections
                        applySelectionState(state);
                        applyExpansionState(state);
                    }
                    
                    // Re-render trees with updated selections
                    updateFileSummaryWithoutRender();
                }
            } catch (e) {
                console.error('Error restoring selection state:', e);
            }
        }
        
        // Update file summary without re-rendering the tree
        function updateFileSummaryWithoutRender() {
            // Calculate total files and selected files
            let totalIncludedFiles = 0;
            let totalSelectedFiles = 0;
            let totalIgnoredFiles = 0;
            let totalSelectedIgnoredFiles = 0;
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            
            // Calculate included files stats
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    totalIncludedFiles += repo.fileCount;
                    totalTokenCount += repo.tokenCount;
                    selectedTokenCount += getSelectedTokenCount(repo);
                    totalSelectedFiles += getSelectedFileCount(repo);
                });
            }
            
            // Calculate ignored files stats
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    totalIgnoredFiles += repo.fileCount;
                    totalSelectedIgnoredFiles += getSelectedFileCount(repo);
                    // Add tokens from selected ignored files
                    selectedTokenCount += getSelectedTokenCount(repo);
                });
            }
            
            // Update counts
            includedCount.textContent = `${totalSelectedFiles} of ${totalIncludedFiles} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens`;
            ignoredCount.textContent = `${totalSelectedIgnoredFiles} of ${totalIgnoredFiles} files`;
            selectedReposCount.textContent = selectedRepos.length;

            // Update total tokens count above the Copy button
            const totalTokensCount = document.getElementById('total-tokens-count');
            if (totalTokensCount) {
                totalTokensCount.textContent = formatTokenCount(selectedTokenCount);
            }
            
            // Update total files count
            const totalFilesCount = document.getElementById('total-files-count');
            if (totalFilesCount) {
                const totalSelectedFilesCount = totalSelectedFiles + totalSelectedIgnoredFiles;
                totalFilesCount.textContent = totalSelectedFilesCount;
            }

            // Show the selected repos section
            selectedReposSummary.classList.remove('hidden');
            
            // Update the selected repos list
            updateSelectedReposList();
        }
        
        // Update file summary UI
        function updateFileSummary() {
            // Calculate total files and selected files
            let totalIncludedFiles = 0;
            let totalSelectedFiles = 0;
            let totalIgnoredFiles = 0;
            let totalSelectedIgnoredFiles = 0;
            totalTokenCount = 0;
            let selectedTokenCount = 0;

            // Calculate included files stats
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    totalIncludedFiles += repo.fileCount;
                    totalTokenCount += repo.tokenCount;
                    selectedTokenCount += getSelectedTokenCount(repo);
                    totalSelectedFiles += getSelectedFileCount(repo);
                });
            }
            
            // Calculate ignored files stats
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    totalIgnoredFiles += repo.fileCount;
                    totalSelectedIgnoredFiles += getSelectedFileCount(repo);
                    // Add tokens from selected ignored files
                    selectedTokenCount += getSelectedTokenCount(repo);
                });
            }

            // Update counts
            includedCount.textContent = `${totalSelectedFiles} of ${totalIncludedFiles} files ¬∑ ~${formatTokenCount(selectedTokenCount)} tokens`;
            ignoredCount.textContent = `${totalSelectedIgnoredFiles} of ${totalIgnoredFiles} files`;
            selectedReposCount.textContent = selectedRepos.length;

            // Update total tokens count above the Copy button
            const totalTokensCount = document.getElementById('total-tokens-count');
            if (totalTokensCount) {
                totalTokensCount.textContent = formatTokenCount(selectedTokenCount);
            }
            
            // Update total files count
            const totalFilesCount = document.getElementById('total-files-count');
            if (totalFilesCount) {
                const totalSelectedFilesCount = totalSelectedFiles + totalSelectedIgnoredFiles;
                totalFilesCount.textContent = totalSelectedFilesCount;
            }

            // Show the selected repos section
            selectedReposSummary.classList.remove('hidden');

            // Update the selected repos list
            updateSelectedReposList();
        }

        // Show file preview
        function showFilePreview(file) {
            filePreviewFilename.textContent = `${file.name} (~${file.isIgnored ? "Unknown" : formatTokenCount(file.tokenCount || 0)} tokens)`;
            filePreviewCode.textContent = file.content || "Preview not available for ignored files";
            filePreviewModal.classList.add('visible');
        }
        
        // Close file preview
        function closeFilePreview() {
            filePreviewModal.classList.remove('visible');
        }
        
        // Search file tree
        function searchFileTree(query) {
            if (!query) {
                // Clear search
                resetTreeSearch();
                return;
            }
            
            const lowerQuery = query.toLowerCase();
            let foundAny = false;
            
            // Search in each repo
            const repoElements = fileTree.querySelectorAll('.tree-repo');
            repoElements.forEach(repoEl => {
                let foundInRepo = false;
                
                // Search files in this repo
                const fileElements = repoEl.querySelectorAll('.tree-file');
                fileElements.forEach(fileEl => {
                    const fileName = fileEl.dataset.name.toLowerCase();
                    const filePath = fileEl.dataset.path.toLowerCase();
                    
                    if (fileName.includes(lowerQuery) || filePath.includes(lowerQuery)) {
                        fileEl.style.display = 'flex';
                        highlightMatch(fileEl, lowerQuery);
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make sure parent directories are expanded and visible
                        let parent = fileEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else {
                        fileEl.style.display = 'none';
                    }
                });
                
                // Search directories
                const dirElements = repoEl.querySelectorAll('.tree-directory');
                dirElements.forEach(dirEl => {
                    const dirName = dirEl.dataset.name.toLowerCase();
                    const hasVisibleChildren = dirEl.querySelector('.tree-file[style*="display: flex"]');
                    
                    if (dirName.includes(lowerQuery)) {
                        // Highlight the directory name and make it visible
                        const nameElement = dirEl.querySelector('.tree-directory-name span:last-child');
                        nameElement.innerHTML = nameElement.textContent.replace(
                            new RegExp(lowerQuery, 'ig'),
                            match => `<span class="match-highlight">${match}</span>`
                        );
                        
                        // Show and expand the directory
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make parent directories visible and expanded
                        let parent = dirEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else if (hasVisibleChildren) {
                        // Directory has matching files, keep it visible and expanded
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                    } else if (!hasVisibleChildren && !dirName.includes(lowerQuery)) {
                        // Hide the directory if it neither matches nor has matching children
                        dirEl.style.display = 'none';
                    }
                });
                
                // Show/hide the entire repo based on matches
                if (foundInRepo) {
                    repoEl.style.display = 'block';
                    repoEl.classList.add('expanded');
                } else {
                    repoEl.style.display = 'none';
                }
            });
            
            // Show no results message if nothing found
            if (!foundAny) {
                if (!fileTree.querySelector('.tree-empty')) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.classList.add('tree-empty');
                    emptyMessage.innerHTML = `
                        <div class="tree-empty-icon">üîç</div>
                        <p>No files match your search</p>
                    `;
                    fileTree.appendChild(emptyMessage);
                }
            } else {
                const emptyMessage = fileTree.querySelector('.tree-empty');
                if (emptyMessage) {
                    emptyMessage.remove();
                }
            }
        }
        
        // Search ignored file tree - nearly identical to searchFileTree but for ignored files
        function searchIgnoredFileTree(query) {
            if (!query) {
                // Clear search
                resetIgnoredTreeSearch();
                return;
            }
            
            const lowerQuery = query.toLowerCase();
            let foundAny = false;
            
            // Search in each repo
            const repoElements = ignoredFileTree.querySelectorAll('.tree-repo');
            repoElements.forEach(repoEl => {
                let foundInRepo = false;
                
                // Search files in this repo
                const fileElements = repoEl.querySelectorAll('.tree-file');
                fileElements.forEach(fileEl => {
                    const fileName = fileEl.dataset.name.toLowerCase();
                    const filePath = fileEl.dataset.path.toLowerCase();
                    
                    if (fileName.includes(lowerQuery) || filePath.includes(lowerQuery)) {
                        fileEl.style.display = 'flex';
                        highlightMatch(fileEl, lowerQuery);
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make sure parent directories are expanded and visible
                        let parent = fileEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else {
                        fileEl.style.display = 'none';
                    }
                });
                
                // Search directories
                const dirElements = repoEl.querySelectorAll('.tree-directory');
                dirElements.forEach(dirEl => {
                    const dirName = dirEl.dataset.name.toLowerCase();
                    const hasVisibleChildren = dirEl.querySelector('.tree-file[style*="display: flex"]');
                    
                    if (dirName.includes(lowerQuery)) {
                        // Highlight the directory name and make it visible
                        const nameElement = dirEl.querySelector('.tree-directory-name span:last-child');
                        nameElement.innerHTML = nameElement.textContent.replace(
                            new RegExp(lowerQuery, 'ig'),
                            match => `<span class="match-highlight">${match}</span>`
                        );
                        
                        // Show and expand the directory
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make parent directories visible and expanded
                        let parent = dirEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else if (hasVisibleChildren) {
                        // Directory has matching files, keep it visible and expanded
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                    } else if (!hasVisibleChildren && !dirName.includes(lowerQuery)) {
                        // Hide the directory if it neither matches nor has matching children
                        dirEl.style.display = 'none';
                    }
                });
                
                // Show/hide the entire repo based on matches
                if (foundInRepo) {
                    repoEl.style.display = 'block';
                    repoEl.classList.add('expanded');
                } else {
                    repoEl.style.display = 'none';
                }
            });
            
            // Show no results message if nothing found
            if (!foundAny) {
                if (!ignoredFileTree.querySelector('.tree-empty')) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.classList.add('tree-empty');
                    emptyMessage.innerHTML = `
                        <div class="tree-empty-icon">üîç</div>
                        <p>No ignored files match your search</p>
                    `;
                    ignoredFileTree.appendChild(emptyMessage);
                }
            } else {
                const emptyMessage = ignoredFileTree.querySelector('.tree-empty');
                if (emptyMessage) {
                    emptyMessage.remove();
                }
            }
        }
        
        // Highlight search matches
        function highlightMatch(element, query) {
            // Highlight in the file name
            const nameElement = element.querySelector('.tree-file-name');
            const originalText = nameElement.textContent;
            
            // Only replace in the text nodes to avoid messing up the extension styling
            const textNode = Array.from(nameElement.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
            const extNode = nameElement.querySelector('.tree-file-ext');
            
            if (textNode && originalText.toLowerCase().includes(query)) {
                const baseName = textNode.textContent;
                textNode.textContent = '';
                
                // Create a new span with highlighted text
                const newSpan = document.createElement('span');
                newSpan.innerHTML = baseName.replace(
                    new RegExp(query, 'ig'),
                    match => `<span class="match-highlight">${match}</span>`
                );
                
                // Insert the highlighted text before the extension
                nameElement.insertBefore(newSpan, extNode);
            }
            
            // Also check if the extension contains the query
            if (extNode && extNode.textContent.toLowerCase().includes(query)) {
                extNode.innerHTML = extNode.textContent.replace(
                    new RegExp(query, 'ig'),
                    match => `<span class="match-highlight">${match}</span>`
                );
            }
        }
        
        // Reset tree search
        function resetTreeSearch() {
            // Show all elements
            const allRepos = fileTree.querySelectorAll('.tree-repo');
            const allDirs = fileTree.querySelectorAll('.tree-directory');
            const allFiles = fileTree.querySelectorAll('.tree-file');
            
            allRepos.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allDirs.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allFiles.forEach(el => {
                el.style.display = 'flex';
                
                // Remove highlights
                const nameElement = el.querySelector('.tree-file-name');
                if (nameElement) {
                    nameElement.innerHTML = `${nameElement.textContent.split('.')[0]}<span class="tree-file-ext">.${nameElement.textContent.split('.')[1] || ''}</span>`;
                }
            });
            
            // Remove empty message if present
            const emptyMessage = fileTree.querySelector('.tree-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Re-expand first level directories if needed
            renderFileTree();
        }
        
        // Reset ignored tree search
        function resetIgnoredTreeSearch() {
            // Show all elements
            const allRepos = ignoredFileTree.querySelectorAll('.tree-repo');
            const allDirs = ignoredFileTree.querySelectorAll('.tree-directory');
            const allFiles = ignoredFileTree.querySelectorAll('.tree-file');
            
            allRepos.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allDirs.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allFiles.forEach(el => {
                el.style.display = 'flex';
                
                // Remove highlights
                const nameElement = el.querySelector('.tree-file-name');
                if (nameElement) {
                    nameElement.innerHTML = `${nameElement.textContent.split('.')[0]}<span class="tree-file-ext">.${nameElement.textContent.split('.')[1] || ''}</span>`;
                }
            });
            
            // Remove empty message if present
            const emptyMessage = ignoredFileTree.querySelector('.tree-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Re-expand first level directories if needed
            renderIgnoredFileTree();
        }
        
        // Apply current search filter
        function applySearchFilter() {
            const query = treeSearchInput.value.trim();
            if (query) {
                searchFileTree(query);
            }
        }
        
        // Apply current search filter for ignored files
        function applyIgnoredSearchFilter() {
            const query = ignoredTreeSearchInput.value.trim();
            if (query) {
                searchIgnoredFileTree(query);
            }
        }
        
        // Get selected token count for a node (recursive)
        function getSelectedTokenCount(node) {
            if (node.type === 'file') {
                // Base case: file
                return node.selected ? (node.tokenCount || 0) : 0;
            }

            // If the directory/repo itself is completely deselected, return 0
            // (A node is completely deselected if selected is false and indeterminate is false)
            if (!node.selected && !node.indeterminate) {
                 return 0;
            }

            // Recursive case: directory or repo
            // If it's selected (fully or partially), always sum the selected token counts of its children.
            // This replaces the previous optimization which could return a stale node.tokenCount.
            let count = 0;
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    count += getSelectedTokenCount(child);
                });
            }
            return count;
        }
        
        // Get selected files from a node (recursive)
        function getSelectedFiles(node) {
            const files = [];
            
            if (node.type === 'file') {
                // Only add this file if it's selected
                if (node.selected) {
                    files.push({
                        path: node.path,
                        content: node.content || "",
                        name: node.name,
                        type: 'file',
                        tokenCount: node.tokenCount
                    });
                }
                return files;
            }
            
            // For directories and repos, collect from all children
            if (node.children) {
                // Skip completely deselected directories/repos
                if (!node.selected && !node.indeterminate) {
                    return files;
                }
                
                // Process each child recursively
                Object.values(node.children).forEach(child => {
                    if (child.type === 'directory') {
                        // For directories, include their path and recursively get their contents
                        const dirFiles = getSelectedFiles(child);
                        if (dirFiles.length > 0) {
                            files.push(...dirFiles);
                        }
                    } else {
                        files.push(...getSelectedFiles(child));
                    }
                });
            }
            
            return files;
        }
        
        // Update the list of selected repositories
        function updateSelectedReposList() {
            selectedReposList.innerHTML = '';
            
            selectedRepos.forEach(repo => {
                // Find the corresponding repo in fileTreeData to get token count
                const repoData = fileTreeData.find(r => r.name === repo.name);
                const ignoredRepoData = ignoredTreeData.find(r => r.name === repo.name);
                
                // Calculate included files stats
                const includedTotal = repoData ? repoData.fileCount : 0;
                const includedSelected = repoData ? getSelectedFileCount(repoData) : 0;
                
                // Calculate ignored files stats
                const ignoredTotal = ignoredRepoData ? ignoredRepoData.fileCount : 0;
                const ignoredSelected = ignoredRepoData ? getSelectedFileCount(ignoredRepoData) : 0;
                
                // Calculate tokens
                const selectedTokenCount = (repoData ? getSelectedTokenCount(repoData) : 0) + 
                                          (ignoredRepoData ? getSelectedTokenCount(ignoredRepoData) : 0);
                
                const repoItem = document.createElement('div');
                repoItem.classList.add('repo-item');
                repoItem.innerHTML = `
                    <span class="repo-name">üìÇ ${repo.name}</span>
                    <span class="repo-files">
                        ${includedSelected} of ${includedTotal} included files ¬∑ 
                        ${ignoredSelected} of ${ignoredTotal} ignored files ¬∑ 
                        ~${formatTokenCount(selectedTokenCount)} tokens
                    </span>
                `;
                selectedReposList.appendChild(repoItem);
            });
        }
        // Copy to clipboard
        async function copyToClipboard() {
            try {
                // Format the data for the API using our existing tree structure
                const selectedFilesData = [];
                
                // Get selected files from included files tree
                if (fileTreeData && fileTreeData.length > 0) {
                    fileTreeData.forEach(repo => {
                        const repoFiles = getSelectedFiles(repo);
                        if (repoFiles.length > 0) {
                            selectedFilesData.push({
                                name: repo.name,
                                files: repoFiles,
                                treeData: repo  // Include the full tree data structure
                            });
                        }
                    });
                }
                
                // Get selected files from ignored files tree
                if (ignoredTreeData && ignoredTreeData.length > 0) {
                    ignoredTreeData.forEach(repo => {
                        const ignoredRepoFiles = getSelectedFiles(repo);
                        if (ignoredRepoFiles.length > 0) {
                            // Find if we already have this repo
                            let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                            if (!repoEntry) {
                                repoEntry = {
                                    name: repo.name,
                                    files: [],
                                    treeData: repo  // Include the full tree data structure
                                };
                                selectedFilesData.push(repoEntry);
                            }
                            repoEntry.files = repoEntry.files.concat(ignoredRepoFiles);
                        }
                    });
                }

                if (selectedFilesData.length === 0) {
                    showNotification('No files selected to copy', 'warning');
                    return;
                }
                
                // Make API call to copy to clipboard
                const response = await fetch('/api/copy-to-clipboard', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ selectedRepos: selectedFilesData })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                showNotification(result.message, 'success');
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                showNotification('Error copying to clipboard: ' + error.message, 'error');
            }
        }
        
        // Copy prompt with settings
        function copyPromptWithSettings() {
            try {
                // Get correct references to the checkbox elements
                const includeRepoContextCheckbox = document.querySelector('#step-create-prompt #include-repo-context');
                const includeFileTreeCheckbox = document.querySelector('#step-create-prompt #include-file-tree');
                const includePromptCheckbox = document.querySelector('#step-create-prompt #include-prompt');
                const promptInputElement = document.querySelector('#step-create-prompt #prompt-input');
                
                console.log("Copy prompt function called", {
                    includeRepoContext: includeRepoContextCheckbox?.checked,
                    includeFileTree: includeFileTreeCheckbox?.checked,
                    includePrompt: includePromptCheckbox?.checked
                });
                
                if (!includeRepoContextCheckbox || !includeFileTreeCheckbox || !includePromptCheckbox || !promptInputElement) {
                    throw new Error("Required elements not found");
                }

                let content = '';
                const selectedFilesData = [];
                
                // Collect selected files data first
                if (fileTreeData && fileTreeData.length > 0) {
                    fileTreeData.forEach(repo => {
                        const repoFiles = getSelectedFiles(repo);
                        if (repoFiles.length > 0) {
                            let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                            if (!repoEntry) {
                                repoEntry = {
                                    name: repo.name,
                                    path: selectedRepos.find(r => r.name === repo.name)?.path || '',
                                    files: [],
                                    treeData: repo,
                                    fileCount: repoFiles.length,
                                    tokenCount: repo.tokenCount
                                };
                                selectedFilesData.push(repoEntry);
                            }
                            repoEntry.files = repoEntry.files.concat(repoFiles);
                        }
                    });
                }
                
                // Get selected files from ignored files tree
                if (ignoredTreeData && ignoredTreeData.length > 0) {
                    ignoredTreeData.forEach(repo => {
                        const ignoredRepoFiles = getSelectedFiles(repo);
                        if (ignoredRepoFiles.length > 0) {
                            let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                            if (!repoEntry) {
                                const originalRepo = selectedRepos.find(r => r.name === repo.name);
                                repoEntry = {
                                    name: repo.name,
                                    path: originalRepo?.path || '',
                                    files: [],
                                    treeData: repo,
                                    fileCount: ignoredRepoFiles.length,
                                    tokenCount: repo.tokenCount
                                };
                                selectedFilesData.push(repoEntry);
                            }
                            repoEntry.files = repoEntry.files.concat(ignoredRepoFiles);
                        }
                    });
                }
                
                // Add content in the specified order
                
                // 1. Prompt Text (highest level) - if selected
                if (includePromptCheckbox.checked && promptInputElement.value.trim()) {
                    content += 'USER PROMPT:\n';
                    content += '='.repeat(80) + '\n\n';
                    content += promptInputElement.value.trim();
                    // Add a separator after the prompt text if there's more content coming
                    if (includeFileTreeCheckbox.checked || includeRepoContextCheckbox.checked || 
                        includeXmlDiffCheckbox.checked || includeXmlWholeCheckbox.checked) {
                        content += `\n\n${'='.repeat(80)}\n\n`;
                    }
                }
                
                // 2. File Tree (next level) - if selected
                if (includeFileTreeCheckbox.checked && selectedFilesData.length > 0) {
                    content += 'FILE TREE STRUCTURE:\n';
                    content += '='.repeat(80) + '\n\n';
                    content += generateFileTree(selectedFilesData);
                    // Add a separator after the file tree if repository context is coming
                    if (includeRepoContextCheckbox.checked) {
                        content += '='.repeat(80) + '\n\n';
                    }
                }
                
                // 3. Repository Context (comes last) - if selected
                if (includeRepoContextCheckbox.checked && selectedFilesData.length > 0) {
                    selectedFilesData.forEach(repo => {
                        content += `REPOSITORY: ${repo.name}\n`;
                        content += '='.repeat(80) + '\n\n';
                        
                        repo.files.forEach(file => {
                            content += `${file.path}:\n${file.content || ''}\n\n`;
                        });
                    });
                }
                
                if (content.trim() === '') {
                    showNotification('No content to copy. Select copy options and ensure files are selected.', 'warning');
                    return;
                }
                
                // Copy to clipboard - try browser API first
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(content)
                        .then(() => {
                            // Create a custom success message based on enabled options
                            const enabledOptions = [];
                            if (includePromptCheckbox.checked) enabledOptions.push("Prompt Text");
                            if (includeFileTreeCheckbox.checked) enabledOptions.push("File Tree");
                            if (includeRepoContextCheckbox.checked) enabledOptions.push("Repository Context");
                            if (includeXmlDiffCheckbox.checked) enabledOptions.push("XML Diff");
                            if (includeXmlWholeCheckbox.checked) enabledOptions.push("XML Whole");
                            
                            const successMessage = enabledOptions.length > 0 
                                ? `üìã ${enabledOptions.join(' + ')} copied to clipboard!`
                                : 'üìã Content copied to clipboard!';
                                
                            showNotification(successMessage, 'success');
                        })
                        .catch(err => {
                            console.error('Clipboard API error:', err);
                            // Fall back to the server-side API if browser API fails
                            fallbackCopyToClipboard({ text: content });
                        });
                } else {
                    // Fall back to server-side API if browser API is not available
                    fallbackCopyToClipboard({ text: content });
                }
            } catch (error) {
                console.error('Error in copyPromptWithSettings:', error);
                showNotification('Error copying to clipboard: ' + error.message, 'error');
            }
        }
        
        // Update the fallback function to handle direct text copying
        function fallbackCopyToClipboard(data) {
            // Check if we're copying raw text or repo data
            if (data.text) {
                // Check if we're in the prompt view and need to create a custom message
                const includeRepoContextCheckbox = document.querySelector('#step-create-prompt #include-repo-context');
                const includeFileTreeCheckbox = document.querySelector('#step-create-prompt #include-file-tree');
                const includePromptCheckbox = document.querySelector('#step-create-prompt #include-prompt');
                const includeXmlDiffCheckbox = document.querySelector('#step-create-prompt #include-xml-diff');
                const includeXmlWholeCheckbox = document.querySelector('#step-create-prompt #include-xml-whole');
                
                // Direct text copy
                axios.post('/api/copy-to-clipboard', { text: data.text })
                    .then(response => {
                        // Create a custom success message if we're in the prompt view
                        if (includeRepoContextCheckbox && includeFileTreeCheckbox && includePromptCheckbox && 
                            includeXmlDiffCheckbox && includeXmlWholeCheckbox) {
                            const enabledOptions = [];
                            if (includePromptCheckbox.checked) enabledOptions.push("Prompt Text");
                            if (includeFileTreeCheckbox.checked) enabledOptions.push("File Tree");
                            if (includeRepoContextCheckbox.checked) enabledOptions.push("Repository Context");
                            if (includeXmlDiffCheckbox.checked) enabledOptions.push("XML Diff");
                            if (includeXmlWholeCheckbox.checked) enabledOptions.push("XML Whole");
                            
                            const successMessage = enabledOptions.length > 0 
                                ? `üìã ${enabledOptions.join(' + ')} copied to clipboard!`
                                : 'üìã Content copied to clipboard!';
                                
                            showNotification(successMessage, 'success');
                        } else {
                            showNotification('üìã Content copied to clipboard!', 'success');
                        }
                    })
                    .catch(error => {
                        console.error('Server clipboard API error:', error);
                        showNotification('Error copying to clipboard: ' + error.message, 'error');
                    });
            } else {
                // Repository data copy (original functionality)
                axios.post('/api/copy-to-clipboard', { selectedRepos: data })
                    .then(response => {
                        let totalFiles = 0;
                        data.forEach(repo => {
                            totalFiles += repo.files.length;
                        });
                        
                        showNotification(`üìã ${totalFiles} files copied to clipboard!`, 'success');
                    })
                    .catch(error => {
                        console.error('Server clipboard API error:', error);
                        showNotification('Error copying to clipboard: ' + error.message, 'error');
                    });
            }
        }
        
        // Return to repository selection
        function backToRepoSelect() {
            // Hide step 3
            stepFileSummary.classList.add('hidden');
            
            // Hide create prompt section
            stepCreatePrompt.classList.add('hidden');
            
            // Hide XML Parser section
            stepXmlParser.classList.add('hidden');
            
            // Re-enable step 2
            stepRepoSelect.classList.remove('disabled');
            
            // Make sure step 2 is visible
            stepRepoSelect.classList.remove('hidden');
            
            // Make sure checkboxes match the currently selected repos
            updateRepoCheckboxes();
        }
        
        // Update repo checkboxes to match current selections
        function updateRepoCheckboxes() {
            // Get all checkboxes
            const checkboxes = repoChecklist.querySelectorAll('input[type="checkbox"]');
            
            // Create a set of selected paths for quick lookup
            const selectedPaths = new Set(selectedRepos.map(repo => repo.path));
            
            // Update each checkbox
            checkboxes.forEach(checkbox => {
                const repoPath = checkbox.dataset.path;
                checkbox.checked = selectedPaths.has(repoPath);
            });
            
            // Update selection count
            updateSelectionCount();
        }
        
        // Refresh repository files
        function refreshRepositoryFiles() {
            if (selectedRepos.length === 0) {
                showNotification('No repositories to refresh', 'warning');
                return;
            }
            
            showNotification('üîÑ Refreshing repository files...', 'info');
            
            // Create a loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.classList.add('loading-indicator');
            loadingIndicator.innerHTML = `
                <div class="spinner"></div>
                <p>Refreshing repositories...</p>
            `;
            selectedReposSummary.appendChild(loadingIndicator);
            
            // Disable buttons during refresh
            refreshButton.disabled = true;
            copyButton.disabled = true;
            
            // Save scroll positions before refresh
            const fileTreeScrollTop = fileTree.scrollTop;
            const ignoredTreeScrollTop = ignoredFileTree.scrollTop;
            
            // First, map all file paths to their current selection state for direct comparison
            const fileSelectionMap = {};
            const ignoredSelectionMap = {};
            
            // Save selection state for included files
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    collectFileSelections(repo, fileSelectionMap);
                });
            }
            
            // Save selection state for ignored files
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    collectFileSelections(repo, ignoredSelectionMap);
                });
            }
            
            // Also capture expansion state
            const expandedDirs = {};
            const expandedIgnoredDirs = {};
            
            // Save expansion state for included files
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    expandedDirs[repo.name] = getExpansionState(repo.name, false);
                });
            }
            
            // Save expansion state for ignored files
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    expandedIgnoredDirs[repo.name] = getExpansionState(repo.name, true);
                });
            }
            
            // Track completion for multiple repos
            let refreshedCount = 0;
            const tempSelectedRepos = [...selectedRepos];
            selectedRepos = [];
            fileTreeData = [];
            ignoredTreeData = [];
            
            // Process each repository
            tempSelectedRepos.forEach((repo, index) => {
                setTimeout(() => {
                    axios.post('/api/repo-files', { repoPath: repo.path })
                        .then(response => {
                            // Create updated repo object with fresh data
                            const updatedRepo = {
                                name: repo.name,
                                path: repo.path,
                                included: response.data.included,
                                ignored: response.data.ignored
                            };
                            
                            // Add to selected repos
                            selectedRepos.push(updatedRepo);
                            
                            // Build new included files tree with default selections
                            const repoTreeData = buildFileTree(updatedRepo.included, updatedRepo.name, false);
                            
                            // Apply saved selections to the included files tree
                            applyFileSelections(repoTreeData, fileSelectionMap);
                            
                            // Add to file tree data
                            fileTreeData.push(repoTreeData);
                            
                            // Build new ignored files tree with default selections (false for ignored files)
                            const repoIgnoredTreeData = buildFileTree(
                                updatedRepo.ignored.map(path => ({ path, content: "" })), 
                                updatedRepo.name, 
                                true
                            );
                            
                            // Apply saved selections to the ignored files tree
                            applyFileSelections(repoIgnoredTreeData, ignoredSelectionMap);
                            
                            // Add to ignored tree data
                            ignoredTreeData.push(repoIgnoredTreeData);
                            
                            // Update selection states from bottom to top
                            updateSelectionStatesBottomUp(repoTreeData);
                            updateSelectionStatesBottomUp(repoIgnoredTreeData);
                            
                            // Update progress
                            refreshedCount++;
                            
                            // If all repos are processed
                            if (refreshedCount === tempSelectedRepos.length) {
                                // Remove loading indicator
                                loadingIndicator.remove();
                                
                                // Render tree with applied selections
                                renderFileTree();
                                
                                // Render ignored tree if expanded
                                if (!ignoredContent.classList.contains('hidden')) {
                                    renderIgnoredFileTree();
                                }
                                
                                // Then restore expanded directories
                                setTimeout(() => {
                                    // Restore scroll position for included files
                                    fileTree.scrollTop = fileTreeScrollTop;
                                    
                                    // Apply saved expansion state to included files
                                    if (fileTreeData && fileTreeData.length > 0) {
                                        fileTreeData.forEach(repo => {
                                            if (expandedDirs[repo.name] && expandedDirs[repo.name].length > 0) {
                                                const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repo.name}"]`);
                                                if (repoElement) {
                                                    // Expand the repo itself
                                                    repoElement.classList.add('expanded');
                                                    
                                                    // Apply saved expansion state to each directory
                                                    expandedDirs[repo.name].forEach(path => {
                                                        applyExpansionPath(repoElement, path);
                                                    });
                                                }
                                            }
                                        });
                                    }
                                    
                                    // Restore scroll position for ignored files if expanded
                                    if (!ignoredContent.classList.contains('hidden')) {
                                        ignoredFileTree.scrollTop = ignoredTreeScrollTop;
                                        
                                        // Apply saved expansion state to ignored files
                                        if (ignoredTreeData && ignoredTreeData.length > 0) {
                                            ignoredTreeData.forEach(repo => {
                                                if (expandedIgnoredDirs[repo.name] && expandedIgnoredDirs[repo.name].length > 0) {
                                                    const repoElement = ignoredFileTree.querySelector(`.tree-repo[data-name="${repo.name}"]`);
                                                    if (repoElement) {
                                                        // Expand the repo itself
                                                        repoElement.classList.add('expanded');
                                                        
                                                        // Apply saved expansion state to each directory
                                                        expandedIgnoredDirs[repo.name].forEach(path => {
                                                            applyExpansionPath(repoElement, path);
                                                        });
                                                    }
                                                }
                                            });
                                        }
                                    }
                                }, 50);
                                
                                // Enable buttons
                                refreshButton.disabled = false;
                                copyButton.disabled = false;
                                
                                // Save the new selection state to localStorage
                                saveSelectionState();
                                
                                showNotification('‚úÖ All repositories refreshed successfully!', 'success');
                            }
                        })
                        .catch(error => {
                            console.error('Error refreshing repository:', error);
                            showNotification(`Error refreshing repository ${repo.name}: ${error.message}`, 'error');
                            
                            // Re-add the original repo to prevent data loss
                            selectedRepos.push(repo);
                            
                            refreshedCount++;
                            
                            // If all repos are processed
                            if (refreshedCount === tempSelectedRepos.length) {
                                loadingIndicator.remove();
                                refreshButton.disabled = false;
                                copyButton.disabled = false;
                                renderFileTree();
                            }
                        });
                }, index * 300); // Stagger requests to avoid overwhelming the server
            });
        }
        
        // Collect file selection states directly by path for accurate mapping
        function collectFileSelections(node, selectionMap) {
            if (node.type === 'file') {
                // Store the selection state by full path for files
                selectionMap[node.path] = node.selected;
            }
            
            // Recursively process children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    collectFileSelections(child, selectionMap);
                });
            }
        }
        
        // Apply file selection states directly to the new tree
        function applyFileSelections(node, selectionMap) {
            if (node.type === 'file' && node.path in selectionMap) {
                // Apply saved selection state to this file
                node.selected = selectionMap[node.path];
            }
            
            // Recursively process children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    applyFileSelections(child, selectionMap);
                });
            }
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            notificationMessage.textContent = message;
            notification.className = 'notification';
            notification.classList.add(`notification-${type}`);
            notification.classList.remove('hidden');
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                notification.classList.add('hidden');
            }, 3000);
        }
        
        // Socket.io events
        socket.on('scan_start', (data) => {
            // Nothing needed here, loading indicator already shown
        });
        
        socket.on('scan_complete', (data) => {
            pathLoading.classList.add('hidden');
            
            // Store available repos
            availableRepos = data.repos.map((repo, index) => ({
                id: `repo-${index}`,
                name: repo.name,
                path: repo.path
            }));
            
            // Clear previous checkboxes
            repoChecklist.innerHTML = '';
            
            // Reset selections
            selectedRepoIds = [];
            updateSelectionCount();
            
            // Render repositories with current search and sort settings
            renderRepositoryList();
            
            if (availableRepos.length > 0) {
                // Disable step 1
                stepPathSelect.classList.add('disabled');
                
                // Show step 2
                stepRepoSelect.classList.remove('hidden');
            } else {
                showNotification('No repositories found in the selected path', 'warning');
            }
        });
        
        socket.on('error', (data) => {
            pathLoading.classList.add('hidden');
            showNotification(data.message, 'error');
        });
        
        // XML Parser socket events
        socket.on('xml_parse_start', (data) => {
            previewContainer.classList.add('hidden');
            resultsContainer.classList.add('hidden');
            parseBtn.disabled = true;
            parseBtn.textContent = 'Parsing...';
        });
        
        socket.on('xml_parse_complete', (data) => {
            parseBtn.disabled = false;
            parseBtn.textContent = 'Preview Changes';
            
            if (data.success) {
                renderPreview(data.changes);
                
                changeCountEl.textContent = `${data.changeCount} changes`;
                previewContainer.classList.remove('hidden');
                
                if (data.changeCount > 0) {
                    applyBtn.disabled = false;
                } else {
                    applyBtn.disabled = true;
                }
            }
        });
        
        socket.on('xml_error', (data) => {
            parseBtn.disabled = false;
            parseBtn.textContent = 'Preview Changes';
            applyBtn.disabled = true;
            
            showNotification(data.message, 'error');
        });
        
        socket.on('xml_apply_start', (data) => {
            applyBtn.disabled = true;
            applyBtn.textContent = 'Applying...';
        });
        
        socket.on('xml_apply_complete', (data) => {
            applyBtn.disabled = false;
            applyBtn.textContent = 'Apply Changes';
            
            if (data.success) {
                renderResults(data.results);
                
                successCountEl.textContent = data.successfulChanges;
                totalCountEl.textContent = data.totalChanges;
                resultsContainer.classList.remove('hidden');
                
                if (data.successfulChanges === data.totalChanges) {
                    showNotification('All changes applied successfully!', 'success');
                } else {
                    showNotification(`${data.successfulChanges} of ${data.totalChanges} changes applied successfully.`, 'warning');
                }
            }
        });
        
        // Setup XML Parser functionality
        function setupXmlParser() {
            // Remove any existing event listeners to prevent duplicates
            xmlParserHeader.removeEventListener('click', xmlParserHeaderClickHandler);
            xmlParserExpandBtn.removeEventListener('click', xmlParserExpandBtnClickHandler);
            
            // Define the header click handler
            function xmlParserHeaderClickHandler(e) {
                // Don't toggle if clicking on the button directly (it has its own handler)
                if (e.target.classList.contains('expand-collapse-btn')) return;
                
                xmlParserContent.classList.toggle('hidden');
                updateXmlExpandButtonText();
            }
            
            // Define the expand button click handler
            function xmlParserExpandBtnClickHandler(e) {
                e.stopPropagation(); // Prevent the header click handler from firing
                xmlParserContent.classList.toggle('hidden');
                updateXmlExpandButtonText();
            }
            
            // Add event listeners
            xmlParserHeader.addEventListener('click', xmlParserHeaderClickHandler);
            xmlParserExpandBtn.addEventListener('click', xmlParserExpandBtnClickHandler);
            
            // Function to update button text based on current state
            function updateXmlExpandButtonText() {
                if (xmlParserContent.classList.contains('hidden')) {
                    xmlParserExpandBtn.textContent = 'Expand ‚ñº';
                } else {
                    xmlParserExpandBtn.textContent = 'Collapse ‚ñ≤';
                }
            }
            
            // Set initial button text based on current state (not changing the state itself)
            updateXmlExpandButtonText();
            
            // Reset UI elements
            previewContainer.classList.add('hidden');
            resultsContainer.classList.add('hidden');
            xmlInput.value = '';
            
            // If we have multiple repositories, show the dropdown
            if (selectedRepos.length > 1) {
                xmlRepoSelect.classList.remove('hidden');
                
                // Populate the dropdown
                xmlRepoDropdown.innerHTML = '';
                xmlRepoDropdown.innerHTML = '<option value="">Select a repository</option>';
                
                selectedRepos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = repo.path;
                    option.textContent = repo.name;
                    xmlRepoDropdown.appendChild(option);
                });
                
                // Disable the XML input and buttons until a repo is selected
                xmlInput.disabled = true;
                parseBtn.disabled = true;
                applyBtn.disabled = true;
                
                // Update repo info
                xmlRepoName.textContent = 'No repository selected';
                xmlRepoPath.textContent = 'N/A';
                
                // Set up the change event for the dropdown
                xmlRepoDropdown.addEventListener('change', function() {
                    const selectedPath = this.value;
                    if (selectedPath) {
                        const repo = selectedRepos.find(r => r.path === selectedPath);
                        if (repo) {
                            selectXmlRepository(repo);
                        }
                    } else {
                        // No repo selected
                        xmlInput.disabled = true;
                        parseBtn.disabled = true;
                        applyBtn.disabled = true;
                        xmlRepoName.textContent = 'No repository selected';
                        xmlRepoPath.textContent = 'N/A';
                        xmlSelectedRepository = null;
                    }
                });
            } 
            // If we only have one repository, select it automatically
            else if (selectedRepos.length === 1) {
                xmlRepoSelect.classList.add('hidden');
                selectXmlRepository(selectedRepos[0]);
            }
            // If no repos are selected (shouldn't happen but just in case)
            else {
                xmlRepoSelect.classList.add('hidden');
                xmlInput.disabled = true;
                parseBtn.disabled = true;
                applyBtn.disabled = true;
                xmlRepoName.textContent = 'No repository selected';
                xmlRepoPath.textContent = 'N/A';
                xmlSelectedRepository = null;
            }
            
            // Add event listeners for the parse and apply buttons
            parseBtn.addEventListener('click', parseXML);
            applyBtn.addEventListener('click', applyXML);
        }
        
        // Select a repository for XML parsing
        function selectXmlRepository(repo) {
            xmlSelectedRepository = repo;
            xmlRepoName.textContent = repo.name;
            xmlRepoPath.textContent = repo.path;
            xmlInput.disabled = false;
            parseBtn.disabled = false;
            
            // Clear previous results
            previewContainer.classList.add('hidden');
            resultsContainer.classList.add('hidden');
            xmlInput.value = '';
            applyBtn.disabled = true;
        }
        
        // Parse XML function
        function parseXML() {
            if (!xmlSelectedRepository) {
                showNotification('Please select a repository first', 'warning');
                return;
            }
            
            const xml = xmlInput.value.trim();
            if (!xml) {
                showNotification('Please paste XML content first', 'warning');
                return;
            }
            
            // Clear previous results
            previewContainer.classList.add('hidden');
            resultsContainer.classList.add('hidden');
            
            // Emit socket event
            socket.emit('xml_parse', { 
                xml: xml, 
                repoPath: xmlSelectedRepository.path 
            });
        }
        
        // Apply XML changes
        function applyXML() {
            if (!xmlSelectedRepository) {
                showNotification('Please select a repository first', 'warning');
                return;
            }
            
            const xml = xmlInput.value.trim();
            if (!xml) {
                showNotification('Please paste XML content first', 'warning');
                return;
            }
            
            // Emit socket event
            socket.emit('xml_apply', { 
                xml: xml, 
                repoPath: xmlSelectedRepository.path 
            });
        }
        
        // Render preview of XML changes
        function renderPreview(changes) {
            previewList.innerHTML = '';
            
            if (!changes || changes.length === 0) {
                previewList.innerHTML = '<p class="no-repos">No changes detected in the XML.</p>';
                return;
            }
            
            changes.forEach(change => {
                const changeItem = document.createElement('div');
                changeItem.className = 'file-item';
                
                const header = document.createElement('div');
                header.className = 'file-header';
                
                const operationBadge = document.createElement('span');
                operationBadge.className = `badge ${change.operation.toLowerCase()}`;
                operationBadge.textContent = change.operation;
                operationBadge.style.marginRight = '8px';
                
                const path = document.createElement('span');
                path.className = 'file-path';
                path.textContent = change.path;
                
                header.appendChild(operationBadge);
                header.appendChild(path);
                changeItem.appendChild(header);
                
                // Add status message
                const status = document.createElement('div');
                status.className = 'file-status';
                status.textContent = change.status;
                changeItem.appendChild(status);
                
                // Add warning if present
                if (change.warning) {
                    const warning = document.createElement('div');
                    warning.className = 'file-warning';
                    warning.textContent = change.warning;
                    changeItem.appendChild(warning);
                }
                
                previewList.appendChild(changeItem);
            });
        }
        
        // Render results of XML application
        function renderResults(results) {
            resultsListEl.innerHTML = '';
            
            if (!results || results.length === 0) {
                resultsListEl.innerHTML = '<p class="no-repos">No changes were applied.</p>';
                return;
            }
            
            results.forEach(result => {
                const resultItem = document.createElement('div');
                resultItem.className = `file-item ${result.success ? 'success' : 'error'}`;
                
                const header = document.createElement('div');
                header.className = 'file-header';
                
                const statusIcon = document.createElement('span');
                statusIcon.className = 'status-icon';
                statusIcon.textContent = result.success ? '‚úÖ' : '‚ùå';
                statusIcon.style.marginRight = '8px';
                
                const operationBadge = document.createElement('span');
                operationBadge.className = `badge ${result.operation.toLowerCase()}`;
                operationBadge.textContent = result.operation;
                operationBadge.style.marginRight = '8px';
                
                const path = document.createElement('span');
                path.className = 'file-path';
                path.textContent = result.path;
                
                header.appendChild(statusIcon);
                header.appendChild(operationBadge);
                header.appendChild(path);
                resultItem.appendChild(header);
                
                // Add error message if present
                if (result.error) {
                    const error = document.createElement('div');
                    error.className = 'file-error';
                    error.textContent = result.error;
                    resultItem.appendChild(error);
                }
                
                resultsListEl.appendChild(resultItem);
            });
        }
        
        // Event listeners
        scanButton.addEventListener('click', scanRepositories);
        browseButton.addEventListener('click', () => {
            // If in edit mode, exit
            if (isEditMode) {
                exitEditMode();
            }
            
            // Show loading indicator immediately when browse button is clicked
            pathLoading.classList.remove('hidden');
            pathLoading.querySelector('p').textContent = 'Waiting for directory selection...';
            
            // Set a flag to track if we're waiting for file selection
            window.waitingForFileSelection = true;
            
            // Trigger the hidden file input
            directoryInput.click();
            
            // Add a one-time focus event to detect when dialog is closed
            window.addEventListener('focus', function onFocus() {
                // Short delay to allow for handleDirectorySelection to fire first if a selection was made
                setTimeout(() => {
                    // If we're still waiting and custom path is still hidden, user likely canceled
                    if (window.waitingForFileSelection && customPath.classList.contains('hidden')) {
                        pathLoading.classList.add('hidden');
                        window.waitingForFileSelection = false;
                    }
                }, 300);
                
                // Remove this listener after it fires once
                window.removeEventListener('focus', onFocus);
            });
        });
        directoryInput.addEventListener('change', handleDirectorySelection);
        loadReposButton.addEventListener('click', loadSelectedRepositories);
        backToPathButton.addEventListener('click', backToPathSelection);
        copyButton.addEventListener('click', copyToClipboard);
        refreshButton.addEventListener('click', refreshRepositoryFiles);
        backToSelectButton.addEventListener('click', backToRepoSelect);
        
        // Add clear path button event listener
        const clearPathButton = document.getElementById('clear-path-button');
        if (clearPathButton) {
            clearPathButton.addEventListener('click', function() {
                // Hide custom path div
                customPath.classList.add('hidden');
                
                // Reset path display
                selectedPathDisplay.textContent = '';
                
                // Enable the browse and scan buttons again
                browseButton.disabled = false;
                scanButton.disabled = false;
                
                // Clear any selected repositories that came from the file browser
                if (stepRepoSelect && !stepRepoSelect.classList.contains('hidden')) {
                    // If we're on step 2, go back to step 1
                    stepRepoSelect.classList.add('hidden');
                    stepPathSelect.classList.remove('disabled');
                }
                
                // Show notification
                showNotification('Directory selection cleared', 'info');
                
                // Reset the file input
                directoryInput.value = '';
            });
        }
        
        // File preview events
        filePreviewClose.addEventListener('click', closeFilePreview);
        filePreviewModal.addEventListener('click', (e) => {
            if (e.target === filePreviewModal) {
                closeFilePreview();
            }
        });
        
        // Search events for included files
        treeSearchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            searchFileTree(query);
        });
        
        treeSearchClear.addEventListener('click', () => {
            treeSearchInput.value = '';
            resetTreeSearch();
        });
        
        // Search events for ignored files
        ignoredTreeSearchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            searchIgnoredFileTree(query);
        });
        
        ignoredTreeSearchClear.addEventListener('click', () => {
            ignoredTreeSearchInput.value = '';
            resetIgnoredTreeSearch();
        });
        
        notificationClose.addEventListener('click', () => {
            notification.classList.add('hidden');
        });
        
        // Edit path functionality
        let isEditMode = false;
        
        editPathButton.addEventListener('click', function() {
            if (isEditMode) {
                // Switch back to dropdown mode
                exitEditMode();
            } else {
                // Switch to edit mode
                enterEditMode();
            }
        });
        
        function enterEditMode() {
            // Get current selected path
            const currentPath = pathSelect.value;
            
            // Set input value to current path
            pathInput.value = currentPath;
            
            // Hide select, show input
            pathSelect.classList.add('hidden');
            pathInput.classList.remove('hidden');
            
            // Update button text
            editPathButton.textContent = 'Cancel Edit';
            
            // Update state
            isEditMode = true;
            
            // Focus on input
            pathInput.focus();
        }
        
        function exitEditMode() {
            // Hide input, show select
            pathInput.classList.add('hidden');
            pathSelect.classList.remove('hidden');
            
            // Update button text
            editPathButton.textContent = 'Edit Path';
            
            // Update state
            isEditMode = false;
        }
        
        // Handle Enter key in path input
        pathInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                
                // Get entered path
                const enteredPath = pathInput.value.trim();
                
                if (enteredPath) {
                    // Check if path exists in dropdown
                    let pathExists = false;
                    Array.from(pathSelect.options).forEach(option => {
                        if (option.value === enteredPath) {
                            option.selected = true;
                            pathExists = true;
                        }
                    });
                    
                    // If path doesn't exist in dropdown, add it
                    if (!pathExists) {
                        const newOption = document.createElement('option');
                        newOption.value = enteredPath;
                        newOption.textContent = enteredPath;
                        newOption.selected = true;
                        pathSelect.appendChild(newOption);
                    }
                    
                    // Exit edit mode
                    exitEditMode();
                } else {
                    showNotification('Please enter a valid path', 'warning');
                }
            }
        });
        
        // Load paths on page load
        loadPaths();
        
        // Add event listener for page load to restore selection state
        window.addEventListener('load', function() {
            // If we have selectedRepos data but no selection state in memory,
            // try to restore from localStorage
            if (selectedRepos && selectedRepos.length > 0 && 
                ((fileTreeData && fileTreeData.length > 0) || 
                 (ignoredTreeData && ignoredTreeData.length > 0))) {
                restoreSelectionState();
            }
        });

        // Function to copy repository contents
        function copyRepoContents(repo, isIgnored = false) {
            // Get all selected files from the repo
            const files = getSelectedFiles(repo);
            
            if (files.length === 0) {
                showNotification(`No selected files to copy in "${repo.name}"`, 'info');
                return;
            }
            
            // Find the actual repo object with path information
            const repoInfo = selectedRepos.find(r => r.name === repo.name);
            if (!repoInfo) return;
            
            // Format content in the same format as the main copy functionality
            const content = files.map(file => 
                `Repository: ${repo.name}\nAbsolute Path: ${file.path} :\n${file.content || ""}`
            ).join('\n\n');
            
            // Try to copy to clipboard using the browser API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content)
                    .then(() => {
                        showNotification(`üìã Repository "${repo.name}" - ${files.length} selected files copied to clipboard!`, 'success');
                    })
                    .catch(err => {
                        // Fall back to the server-side API if browser API fails
                        fallbackCopyToClipboard([{
                            name: repo.name,
                            path: repoInfo.path,
                            files: files
                        }]);
                    });
            } else {
                // Fall back to the server-side API if browser API is not available
                fallbackCopyToClipboard([{
                    name: repo.name,
                    path: repoInfo.path,
                    files: files
                }]);
            }
        }

        // Function to render the repository list with current search and sort settings
        function renderRepositoryList() {
            // Clear previous list
            repoChecklist.innerHTML = '';
            
            if (!availableRepos || availableRepos.length === 0) {
                repoChecklist.innerHTML = '<div class="empty-message">No repositories found</div>';
                return;
            }
            
            // Get search term
            const searchTerm = repoSearchInput.value.trim().toLowerCase();
            
            // Filter repositories based on search term
            let filteredRepos = availableRepos;
            if (searchTerm) {
                filteredRepos = availableRepos.filter(repo => 
                    repo.name.toLowerCase().includes(searchTerm) || 
                    repo.path.toLowerCase().includes(searchTerm)
                );
            }
            
            // Show message if no matching repositories
            if (filteredRepos.length === 0) {
                repoChecklist.innerHTML = '<div class="empty-message">No matching repositories found</div>';
                return;
            }
            
            // Sort repositories based on selected sort option
            const sortOption = repoSortSelect.value;
            
            switch (sortOption) {
                case 'name-asc':
                    filteredRepos.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'name-desc':
                    filteredRepos.sort((a, b) => b.name.localeCompare(a.name));
                    break;
                case 'default':
                    // Assuming default order is the order they came in from the API
                    // If we need to preserve the original index, we could add an originalIndex property
                    // For now, we'll just use the natural order they are in
                    break;
            }
            
            // Render sorted and filtered repositories
            filteredRepos.forEach(repo => {
                const item = document.createElement('div');
                item.classList.add('repo-checkbox-item');
                item.innerHTML = `
                    <input type="checkbox" id="${repo.id}" data-path="${repo.path}" />
                    <label for="${repo.id}">üìÇ ${repo.name}</label>
                `;
                repoChecklist.appendChild(item);
                
                // Add event listener to checkbox
                const checkbox = item.querySelector('input[type="checkbox"]');
                // Check if this repo is already selected
                checkbox.checked = selectedRepoIds.includes(repo.id);
                
                checkbox.addEventListener('change', function() {
                    // Store current scroll position
                    const scrollTop = window.scrollY || document.documentElement.scrollTop;
                    
                    if (this.checked) {
                        // Add to selected repos
                        if (!selectedRepoIds.includes(repo.id)) {
                            selectedRepoIds.push(repo.id);
                        }
                    } else {
                        // Remove from selected repos
                        const index = selectedRepoIds.indexOf(repo.id);
                        if (index !== -1) {
                            selectedRepoIds.splice(index, 1);
                        }
                    }
                    
                    updateSelectionCount();
                    
                    // Restore scroll position
                    window.scrollTo(0, scrollTop);
                });
            });
        }

        // Repository search event handlers
        repoSearchInput.addEventListener('input', () => {
            renderRepositoryList();
        });
        
        repoSearchClear.addEventListener('click', () => {
            repoSearchInput.value = '';
            renderRepositoryList();
        });
        
        // Repository sort event handler
        repoSortSelect.addEventListener('change', () => {
            renderRepositoryList();
        });

        // Tree sort event handlers
        treeSortSelect.addEventListener('change', () => {
            renderFileTree();
        });
        
        ignoredTreeSortSelect.addEventListener('change', () => {
            renderIgnoredFileTree();
        });

        // Event listeners
        copyButton.addEventListener('click', copyToClipboard);
        promptCopyButton.addEventListener('click', copyPromptWithSettings);

        // Function to generate tree diagram of selected files
        function generateFileTree(selectedFilesData) {
            let tree = '';
            
            selectedFilesData.forEach(repo => {
                // Use the existing tree data structure
                const treeData = repo.treeData;
                if (!treeData) return;
                
                // Add repository name as root with stats
                tree += `${repo.name}\n`;
                tree += `${repo.fileCount} files\n\n`;
                
                // Function to recursively build the tree
                function buildTree(node, prefix = '') {
                    if (!node) return;
                    
                    // Sort children: directories first, then files
                    const children = Object.values(node.children || {}).sort((a, b) => {
                        if (a.type !== b.type) {
                            return a.type === 'directory' ? -1 : 1;
                        }
                        return a.name.localeCompare(b.name);
                    });
                    
                    children.forEach((child, index) => {
                        const isLast = index === children.length - 1;
                        const linePrefix = prefix + (isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ');
                        const nextPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
                        
                        if (child.type === 'directory') {
                            // Only show directories that have selected files
                            if (child.selected || child.indeterminate) {
                                tree += `${linePrefix}${child.name}\n`;
                                buildTree(child, nextPrefix);
                            }
                        } else if (child.type === 'file' && child.selected) {
                            // Show selected files without icons
                            tree += `${linePrefix}${child.name}\n`;
                        }
                    });
                }
                
                // Start building tree from root
                buildTree(treeData);
                tree += '\n';
            });
            
            return tree;
        }

        // Add script to handle copy settings panel collapse/expand
        const copySettingsHeader = document.getElementById('copy-settings-header');
        const copySettingsContent = document.querySelector('.copy-settings-content');
        const copySettingsBtn = copySettingsHeader.querySelector('.expand-collapse-btn');
        
        function toggleCopySettings(e) {
            if (e && e.target.classList.contains('expand-collapse-btn')) {
                e.stopPropagation();
            }
            
            copySettingsContent.classList.toggle('hidden');
            if (copySettingsContent.classList.contains('hidden')) {
                copySettingsBtn.textContent = 'Expand ‚ñº';
            } else {
                copySettingsBtn.textContent = 'Collapse ‚ñ≤';
            }
        }
        
        copySettingsHeader.addEventListener('click', function(e) {
            // Don't toggle if clicking directly on the button (it has its own handler)
            if (e.target.classList.contains('expand-collapse-btn')) return;
            toggleCopySettings(e);
        });
        
        copySettingsBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent the header click handler from firing
            toggleCopySettings(e);
        });

        // XML formatting instructions constants
        const XML_DIFF_INSTRUCTIONS = `<xml_formatting_instructions>
### Role
- You are a **code editing assistant**: You can fulfill edit requests and chat with the user about code or other questions. Provide complete instructions or code lines when replying with xml formatting.

### Capabilities
- Can create new files.
- Can rewrite entire files.
- Can perform partial search/replace modifications.
- Can delete existing files.

Avoid placeholders like \`...\` or \`// existing code here\`. Provide complete lines or code.

## Tools & Actions
1. **create** ‚Äì Create a new file if it doesn't exist.
2. **rewrite** ‚Äì Replace the entire content of an existing file.
3. **modify** (search/replace) ‚Äì For partial edits with <search> + <content>.
4. **delete** ‚Äì Remove a file entirely (empty <content>).

### **Format to Follow for Repo Prompt's Diff Protocol**

<Plan>
Describe your approach or reasoning here.
</Plan>

<file path="path/to/example.swift" action="one_of_the_tools">
  <change>
    <description>Brief explanation of this specific change</description>
    <search>
===
// Exactly matching lines to find
===
    </search>
    <content>
===
// Provide the new or updated code here. Do not use placeholders
===
    </content>
  </change>
  <!-- Add more <change> blocks if you have multiple edits for the same file -->
</file>

#### Tools Demonstration
1. \`<file path="NewFile.swift" action="create">\` ‚Äì Full file in <content>
2. \`<file path="DeleteMe.swift" action="delete">\` ‚Äì Empty <content>
3. \`<file path="ModifyMe.swift" action="modify">\` ‚Äì Partial edit with \`<search>\` + \`<content>\`
4. \`<file path="RewriteMe.swift" action="rewrite">\` ‚Äì Entire file in <content>
5. \`<file path="RewriteMe.swift" action="rewrite">\` ‚Äì Entire file in <content>. No <search> required.

## Format Guidelines
1. **Plan**: Begin with a \`<Plan>\` block explaining your approach.
2. **<file> Tag**: e.g. \`<file path="Models/User.swift" action="...">\`. Must match an available tool.
3. **<change> Tag**: Provide \`<description>\` to clarify each change. Then \`<content>\` for new/modified code. Additional rules depend on your capabilities.
4. **modify**: **<search> & <content>**: Provide code blocks enclosed by ===. Respect indentation exactly, ensuring the <search> block matches the original source down to braces, spacing, and any comments. The new <content> will replace the <search> block, and should should fit perfectly in the space left by it's removal.
5. **modify**: For changes to the same file, ensure that you use multiple change blocks, rather than separate file blocks.
6. **rewrite**: For large overhauls; omit \`<search>\` and put the entire file in \`<content>\`.
7. **create**: For new files, put the full file in <content>.
8. **delete**: Provide an empty <content>. The file is removed.

## Code Examples

-----
### Example: Search and Replace (Add email property)
<Plan>
Add an email property to \`User\` via search/replace.
</Plan>

<file path="Models/User.swift" action="modify">
  <change>
    <description>Add email property to User struct</description>
    <search>
===
struct User {
    let id: UUID
    var name: String
}
===
    </search>
    <content>
===
struct User {
    let id: UUID
    var name: String
    var email: String
}
===
    </content>
  </change>
</file>

-----
### Example: Negative Example - Mismatched Search Block
// Example Input (not part of final output, just demonstration)
<file_contents>
File: path/service.swift
\`\`\`
import Foundation
class Example {
    foo() {
        Bar()
    }
}
\`\`\`
</file_contents>

<Plan>
Demonstrate how a mismatched search block leads to failed merges.
</Plan>

<file path="path/service.swift" action="modify">
  <change>
    <description>This search block is missing or has mismatched indentation, braces, etc.</description>
    <search>
===
    foo() {
        Bar()
    }
===
    </search>
    <content>
===
    foo() {
        Bar()
        Bar2()
    }
===
    </content>
  </change>
</file>

<!-- This example fails because the <search> block doesn't exactly match the original file contents. -->

-----
### Example: Negative Example - Mismatched Brace Balance
// This negative example shows how adding extra braces in the <content> can break brace matching.
<Plan>
Demonstrate that the new content block has one extra closing brace, causing mismatched braces.
</Plan>

<file path="Functions/MismatchedBracesExample.swift" action="modify">
  <change>
    <description>Mismatched brace balance in the replacement content</description>
    <search>
===
    foo() {
        Bar()
    }
===
    </search>
    <content>
===
    foo() {
        Bar()
    }

    bar() {
        foo2()
    }
}
===
    </content>
  </change>
</file>

<!-- Because the <search> block was only a small brace segment, adding extra braces in <content> breaks the balance. -->

-----
### Example: Negative Example - One-Line Search Block
<Plan>
Demonstrate a one-line search block, which is too short to be reliable.
</Plan>

<file path="path/service.swift" action="modify">
  <change>
    <description>One-line search block is ambiguous</description>
    <search>
===
var email: String
===
    </search>
    <content>
===
var emailNew: String
===
    </content>
  </change>
</file>

<!-- This example fails because the <search> block is only one line and ambiguous. -->

-----
### Example: Negative Example - Ambiguous Search Block
<Plan>
Demonstrate an ambiguous search block that can match multiple blocks (e.g., multiple closing braces).
</Plan>

<file path="path/service.swift" action="modify">
  <change>
    <description>Ambiguous search block with multiple closing braces</description>
    <search>
===
    }
}
===
    </search>
    <content>
===
        foo() {
        }
    }
}
===
    </content>
  </change>
</file>

<!-- This example fails because the <search> block is ambiguous due to multiple matching closing braces. -->

-----
### Example: Full File Rewrite
<Plan>
Rewrite the entire User file to include an email property.
</Plan>

<file path="Models/User.swift" action="rewrite">
  <change>
    <description>Full file rewrite with new email field</description>
    <content>
===
import Foundation
struct User {
    let id: UUID
    var name: String
    var email: String

    init(name: String, email: String) {
        self.id = UUID()
        self.name = name
        self.email = email
    }
}
===
    </content>
  </change>
</file>

-----
### Example: Create New File
<Plan>
Create a new RoundedButton for a custom Swift UIButton subclass.
</Plan>

<file path="Views/RoundedButton.swift" action="create">
  <change>
    <description>Create custom RoundedButton class</description>
    <content>
===
import UIKit
@IBDesignable
class RoundedButton: UIButton {
    @IBInspectable var cornerRadius: CGFloat = 0
}
===
    </content>
  </change>
</file>

-----
### Example: Delete a File
<Plan>
Remove an obsolete file.
</Plan>

<file path="Obsolete/File.swift" action="delete">
  <change>
    <description>Completely remove the file from the project</description>
    <content>
===
===
    </content>
  </change>
</file>

## Final Notes
1. **modify** Always wrap the exact original lines in <search> and your updated lines in <content>, each enclosed by ===.
2. **modify** The <search> block must match the source code exactly‚Äîdown to indentation, braces, spacing, and any comments. Even a minor mismatch causes failed merges.
3. **modify** Only replace exactly what you need. Avoid including entire functions or files if only a small snippet changes, and ensure the <search> content is unique and easy to identify.
4. **rewrite** Use \`rewrite\` for major overhauls, and \`modify\` for smaller, localized edits. Rewrite requires the entire code to be replaced, so use it sparingly.
5. You can always **create** new files and **delete** existing files. Provide full code for create, and empty content for delete. Avoid creating files you know exist already.
6. If a file tree is provided, place your files logically within that structure. Respect the user's relative or absolute paths.
7. Wrap your final output in \`\`\`XML ... \`\`\` for clarity.
8. **Important:** Do not wrap any XML output in CDATA tags (i.e. \`<![CDATA[ ... ]]>\`). Repo Prompt expects raw XML exactly as shown in the examples.
9. **IMPORTANT** IF MAKING FILE CHANGES, YOU MUST USE THE AVAILABLE XML FORMATTING CAPABILITIES PROVIDED ABOVE - IT IS THE ONLY WAY FOR YOUR CHANGES TO BE APPLIED.
10. The final output must apply cleanly with no leftover syntax errors.
</xml_formatting_instructions>`;

        const XML_WHOLE_INSTRUCTIONS = `<xml_formatting_instructions>
### Role
- You are a **code editing assistant**: You can fulfill edit requests and chat with the user about code or other questions. Provide complete instructions or code lines when replying with xml formatting.

### Capabilities
- Can create new files.
- Can rewrite entire files.
- Can delete existing files.

Avoid placeholders like \`...\` or \`// existing code here\`. Provide complete lines or code.

## Tools & Actions
1. **create** ‚Äì Create a new file if it doesn't exist.
2. **rewrite** ‚Äì Replace the entire content of an existing file.
3. **delete** ‚Äì Remove a file entirely (empty <content>).

### **Format to Follow for Repo Prompt's Diff Protocol**

<Plan>
Describe your approach or reasoning here.
</Plan>

<file path="path/to/example.swift" action="one_of_the_tools">
  <change>
    <description>Brief explanation of this specific change</description>
    <content>
===
// Provide the new or updated code here. Do not use placeholders
===
    </content>
  </change>
</file>

#### Tools Demonstration
1. \`<file path="NewFile.swift" action="create">\` ‚Äì Full file in <content>
2. \`<file path="DeleteMe.swift" action="delete">\` ‚Äì Empty <content>
3. \`<file path="RewriteMe.swift" action="rewrite">\` ‚Äì Entire file in <content>

## Format Guidelines
1. **Plan**: Begin with a \`<Plan>\` block explaining your approach.
2. **<file> Tag**: e.g. \`<file path="Models/User.swift" action="...">\`. Must match an available tool.
3. **<change> Tag**: Provide \`<description>\` to clarify each change. Then \`<content>\` for new/modified code. Additional rules depend on your capabilities.
4. **rewrite**: Replace the entire file. This is the only way to modify existing files.
5. **create**: For new files, put the full file in <content>.
6. **delete**: Provide an empty <content>. The file is removed.

## Code Examples

-----
### Example: Full File Rewrite
<Plan>
Rewrite the entire User file to include an email property.
</Plan>

<file path="Models/User.swift" action="rewrite">
  <change>
    <description>Full file rewrite with new email field</description>
    <content>
===
import Foundation
struct User {
    let id: UUID
    var name: String
    var email: String

    init(name: String, email: String) {
        self.id = UUID()
        self.name = name
        self.email = email
    }
}
===
    </content>
  </change>
</file>

-----
### Example: Create New File
<Plan>
Create a new RoundedButton for a custom Swift UIButton subclass.
</Plan>

<file path="Views/RoundedButton.swift" action="create">
  <change>
    <description>Create custom RoundedButton class</description>
    <content>
===
import UIKit
@IBDesignable
class RoundedButton: UIButton {
    @IBInspectable var cornerRadius: CGFloat = 0
}
===
    </content>
  </change>
</file>

-----
### Example: Delete a File
<Plan>
Remove an obsolete file.
</Plan>

<file path="Obsolete/File.swift" action="delete">
  <change>
    <description>Completely remove the file from the project</description>
    <content>
===
===
    </content>
  </change>
</file>

## Final Notes
1.  **rewrite**  For rewriting an entire file, place all new content in \`<content>\`. No partial modifications are possible here. Avoid all use of placeholders.
2. You can always **create** new files and **delete** existing files. Provide full code for create, and empty content for delete. Avoid creating files you know exist already.
3. If a file tree is provided, place your files logically within that structure. Respect the user's relative or absolute paths.
4. Wrap your final output in \`\`\`XML ... \`\`\` for clarity.
5. **Important:** Do not wrap any XML output in CDATA tags (i.e. \`<![CDATA[ ... ]]>\`). Repo Prompt expects raw XML exactly as shown in the examples.
6. **IMPORTANT** IF MAKING FILE CHANGES, YOU MUST USE THE AVAILABLE XML FORMATTING CAPABILITIES PROVIDED ABOVE - IT IS THE ONLY WAY FOR YOUR CHANGES TO BE APPLIED.
7. The final output must apply cleanly with no leftover syntax errors.
</xml_formatting_instructions>`;
        
        // Function to handle XML option mutual exclusivity
        function handleXmlOptionsExclusivity() {
            const xmlDiffCheckbox = document.getElementById('include-xml-diff');
            const xmlWholeCheckbox = document.getElementById('include-xml-whole');
            
            // Add event listeners for XML Diff checkbox
            xmlDiffCheckbox.addEventListener('change', function() {
                if (this.checked && xmlWholeCheckbox.checked) {
                    // If XML Diff is checked and XML Whole is also checked, uncheck XML Whole
                    xmlWholeCheckbox.checked = false;
                }
            });
            
            // Add event listeners for XML Whole checkbox
            xmlWholeCheckbox.addEventListener('change', function() {
                if (this.checked && xmlDiffCheckbox.checked) {
                    // If XML Whole is checked and XML Diff is also checked, uncheck XML Diff
                    xmlDiffCheckbox.checked = false;
                }
            });
        }
        
        // Add event listener after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            handleXmlOptionsExclusivity();
        });
        
        // Call it immediately in case the DOM is already loaded
        handleXmlOptionsExclusivity();
        
        // Function to generate tree diagram of selected files
        function generateFileTree(selectedFilesData) {
            let tree = '';
            
            selectedFilesData.forEach(repo => {
                // Use the existing tree data structure
                const treeData = repo.treeData;
                if (!treeData) return;
                
                // Add repository name as root with stats
                tree += `${repo.name}\n`;
                tree += `${repo.fileCount} files\n\n`;
                
                // Function to recursively build the tree
                function buildTree(node, prefix = '') {
                    if (!node) return;
                    
                    // Sort children: directories first, then files
                    const children = Object.values(node.children || {}).sort((a, b) => {
                        if (a.type !== b.type) {
                            return a.type === 'directory' ? -1 : 1;
                        }
                        return a.name.localeCompare(b.name);
                    });
                    
                    children.forEach((child, index) => {
                        const isLast = index === children.length - 1;
                        const linePrefix = prefix + (isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ');
                        const nextPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
                        
                        if (child.type === 'directory') {
                            // Only show directories that have selected files
                            if (child.selected || child.indeterminate) {
                                tree += `${linePrefix}${child.name}\n`;
                                buildTree(child, nextPrefix);
                            }
                        } else if (child.type === 'file' && child.selected) {
                            // Show selected files without icons
                            tree += `${linePrefix}${child.name}\n`;
                        }
                    });
                }
                
                // Start building tree from root
                buildTree(treeData);
                tree += '\n';
            });
            
            return tree;
        }

        // Update the copyPromptWithSettings function to include XML instructions
        function copyPromptWithSettings() {
            try {
                // Get correct references to the checkbox elements
                const includeRepoContextCheckbox = document.querySelector('#step-create-prompt #include-repo-context');
                const includeFileTreeCheckbox = document.querySelector('#step-create-prompt #include-file-tree');
                const includePromptCheckbox = document.querySelector('#step-create-prompt #include-prompt');
                const includeXmlDiffCheckbox = document.querySelector('#step-create-prompt #include-xml-diff');
                const includeXmlWholeCheckbox = document.querySelector('#step-create-prompt #include-xml-whole');
                const promptInputElement = document.querySelector('#step-create-prompt #prompt-input');
                
                console.log("Copy prompt function called", {
                    includeRepoContext: includeRepoContextCheckbox?.checked,
                    includeFileTree: includeFileTreeCheckbox?.checked,
                    includePrompt: includePromptCheckbox?.checked,
                    includeXmlDiff: includeXmlDiffCheckbox?.checked,
                    includeXmlWhole: includeXmlWholeCheckbox?.checked
                });
                
                if (!includeRepoContextCheckbox || !includeFileTreeCheckbox || !includePromptCheckbox || 
                    !includeXmlDiffCheckbox || !includeXmlWholeCheckbox || !promptInputElement) {
                    throw new Error("Required elements not found");
                }

                let content = '';
                const selectedFilesData = [];
                
                // Collect selected files data first
                if (fileTreeData && fileTreeData.length > 0) {
                    fileTreeData.forEach(repo => {
                        const repoFiles = getSelectedFiles(repo);
                        if (repoFiles.length > 0) {
                            let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                            if (!repoEntry) {
                                repoEntry = {
                                    name: repo.name,
                                    path: selectedRepos.find(r => r.name === repo.name)?.path || '',
                                    files: [],
                                    treeData: repo,
                                    fileCount: repoFiles.length,
                                    tokenCount: repo.tokenCount
                                };
                                selectedFilesData.push(repoEntry);
                            }
                            repoEntry.files = repoEntry.files.concat(repoFiles);
                        }
                    });
                }
                
                // Get selected files from ignored files tree
                if (ignoredTreeData && ignoredTreeData.length > 0) {
                    ignoredTreeData.forEach(repo => {
                        const ignoredRepoFiles = getSelectedFiles(repo);
                        if (ignoredRepoFiles.length > 0) {
                            let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                            if (!repoEntry) {
                                const originalRepo = selectedRepos.find(r => r.name === repo.name);
                                repoEntry = {
                                    name: repo.name,
                                    path: originalRepo?.path || '',
                                    files: [],
                                    treeData: repo,
                                    fileCount: ignoredRepoFiles.length,
                                    tokenCount: repo.tokenCount
                                };
                                selectedFilesData.push(repoEntry);
                            }
                            repoEntry.files = repoEntry.files.concat(ignoredRepoFiles);
                        }
                    });
                }
                
                // Add content in the specified order
                
                // 1. Prompt Text (highest level) - if selected
                if (includePromptCheckbox.checked && promptInputElement.value.trim()) {
                    content += 'USER PROMPT:\n';
                    content += '='.repeat(80) + '\n\n';
                    content += promptInputElement.value.trim();
                    // Add a separator after the prompt text if there's more content coming
                    if (includeFileTreeCheckbox.checked || includeRepoContextCheckbox.checked || 
                        includeXmlDiffCheckbox.checked || includeXmlWholeCheckbox.checked) {
                        content += `\n\n${'='.repeat(80)}\n\n`;
                    }
                }
                
                // 2. File Tree (next level) - if selected
                if (includeFileTreeCheckbox.checked && selectedFilesData.length > 0) {
                    content += 'FILE TREE STRUCTURE:\n';
                    content += '='.repeat(80) + '\n\n';
                    content += generateFileTree(selectedFilesData);
                    // Add a separator after the file tree if repository context is coming
                    if (includeRepoContextCheckbox.checked || includeXmlDiffCheckbox.checked || includeXmlWholeCheckbox.checked) {
                        content += '='.repeat(80) + '\n\n';
                    }
                }
                
                // 3. Repository Context (comes next) - if selected
                if (includeRepoContextCheckbox.checked && selectedFilesData.length > 0) {
                    selectedFilesData.forEach(repo => {
                        content += `REPOSITORY: ${repo.name}\n`;
                        content += '='.repeat(80) + '\n\n';
                        
                        repo.files.forEach(file => {
                            content += `${file.path}:\n${file.content || ''}\n\n`;
                        });
                    });
                    
                    // Add a separator after repository context if XML instructions are coming
                    if (includeXmlDiffCheckbox.checked || includeXmlWholeCheckbox.checked) {
                        content += '='.repeat(80) + '\n\n';
                    }
                }
                
                // 4. XML Formatting Instructions (comes last) - if selected
                if (includeXmlDiffCheckbox.checked) {
                    content += XML_DIFF_INSTRUCTIONS;
                } else if (includeXmlWholeCheckbox.checked) {
                    content += XML_WHOLE_INSTRUCTIONS;
                }
                
                if (content.trim() === '') {
                    showNotification('No content to copy. Select copy options and ensure files are selected.', 'warning');
                    return;
                }
                
                // Copy to clipboard - try browser API first
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(content)
                        .then(() => {
                            // Create a custom success message based on enabled options
                            const enabledOptions = [];
                            if (includePromptCheckbox.checked) enabledOptions.push("Prompt Text");
                            if (includeFileTreeCheckbox.checked) enabledOptions.push("File Tree");
                            if (includeRepoContextCheckbox.checked) enabledOptions.push("Repository Context");
                            if (includeXmlDiffCheckbox.checked) enabledOptions.push("XML Diff");
                            if (includeXmlWholeCheckbox.checked) enabledOptions.push("XML Whole");
                            
                            const successMessage = enabledOptions.length > 0 
                                ? `üìã ${enabledOptions.join(' + ')} copied to clipboard!`
                                : 'üìã Content copied to clipboard!';
                                
                            showNotification(successMessage, 'success');
                        })
                        .catch(err => {
                            console.error('Clipboard API error:', err);
                            // Fall back to the server-side API if browser API fails
                            fallbackCopyToClipboard({ text: content });
                        });
                } else {
                    // Fall back to server-side API if browser API is not available
                    fallbackCopyToClipboard({ text: content });
                }
            } catch (error) {
                console.error('Error in copyPromptWithSettings:', error);
                showNotification('Error copying to clipboard: ' + error.message, 'error');
            }
        }
    });
</script>

<style>
    /* Ignored files section styles */
    .ignored-files-section {
        margin-top: 1.5rem;
    }
    
    .ignored-header, .included-header {
        cursor: pointer;
    }
    
    .expand-collapse-btn {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
        margin-left: 0.5rem;
    }
    
    .expand-collapse-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .ignored-content, .included-content {
        padding-top: 1rem;
    }
    
    .hidden {
        display: none !important;
    }
    
    /* File and directory action buttons styles */
    .tree-item-actions {
        display: flex;
        gap: 4px;
        margin-left: auto;
        opacity: 0.6;
    }
    
    .tree-file-content:hover .tree-item-actions,
    .tree-directory-header:hover .tree-item-actions,
    .tree-repo-header:hover .tree-item-actions {
        opacity: 1;
    }
    
    .tree-action-icon {
        background: none;
        border: none;
        cursor: pointer;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 14px;
    }
    
    .tree-action-icon:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Structure for file and directory headers */
    .tree-file-content,
    .tree-directory-header,
    .tree-repo-header {
        display: flex;
        align-items: center;
        width: 100%;
    }
    
    .file-info,
    .directory-header-content {
        display: flex;
        flex: 1;
        min-width: 0;
        align-items: center;
    }
    
    /* Collapsible repositories styling */
    .tree-repo-collapse-indicator {
        display: inline-block;
        margin-right: 4px;
        font-size: 10px;
        min-width: 10px;
        color: var(--text-secondary);
    }
    
    .tree-repo-header {
        cursor: pointer;
        padding: 5px 8px;
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.05);
        margin-bottom: 4px;
    }
    
    .tree-repo-header:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .tree-repo-content {
        padding-left: 20px;
    }
    
    /* Directory icon styles */
    .tree-directory-icon {
        display: inline-block;
        margin-right: 4px;
        font-size: 10px;
        min-width: 10px;
        color: var(--text-secondary);
    }

    .tree-action-button {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 4px;
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        font-size: 12px;
        margin-left: 4px;
        color: var(--text-secondary);
    }

    .tree-action-button:hover {
        background: rgba(255, 255, 255, 0.2);
    }

    .tree-action-button.copy-repo {
        display: flex;
        align-items: center;
    }

    .tree-action-button.copy-repo::before {
        content: "üìã";
        margin-right: 4px;
    }

    .repo-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
        gap: 1.5rem;
        flex-wrap: nowrap;
    }

    .repo-search {
        position: relative;
        flex: 1;
        display: flex;
        align-items: center;
        min-width: 0;
    }

    .repo-search-icon {
        position: absolute;
        left: 10px;
        color: var(--text-secondary);
        font-size: 14px;
        z-index: 1;
    }

    .repo-search-input {
        width: 100%;
        padding: 4px 30px 4px 30px;
        height: 30px;
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
        font-size: 14px;
        line-height: 1;
        margin: 0;
        vertical-align: middle;
        box-sizing: border-box;
    }

    .repo-search-clear {
        position: absolute;
        right: 10px;
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 16px;
        z-index: 1;
        padding: 0;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    .repo-sort {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        white-space: nowrap;
        flex-shrink: 0;
        height: 30px;
        align-self: normal;
    }

    .repo-sort label {
        margin: 0;
        padding: 0;
        line-height: 30px;
        color: var(--text-secondary);
        font-size: 14px;
        display: inline-block;
        vertical-align: middle;
        height: 30px;
    }

    .repo-sort select {
        padding: 4px 8px;
        height: 30px;
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
        cursor: pointer;
        appearance: auto;
        font-size: 14px;
        line-height: 1;
        margin: 0;
        vertical-align: middle;
        box-sizing: border-box;
    }
    
    .repo-sort select option {
        background-color: #252525;
        color: var(--text-primary);
    }

    .empty-message {
        padding: 1rem;
        text-align: center;
        color: var(--text-secondary);
        font-style: italic;
    }

    /* Tree controls styles */
    .tree-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
        gap: 1.5rem;
        flex-wrap: nowrap;
    }
    
    .tree-search {
        position: relative;
        flex: 1;
        display: flex;
        align-items: center;
        min-width: 0;
    }
    
    .tree-search-icon {
        position: absolute;
        left: 10px;
        color: var(--text-secondary);
        font-size: 14px;
        z-index: 1;
    }
    
    .tree-search-input {
        width: 100%;
        padding: 4px 30px 4px 30px;
        height: 30px;
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
        font-size: 14px;
        line-height: 1;
        margin: 0;
        vertical-align: middle;
        box-sizing: border-box;
    }
    
    .tree-search-clear {
        position: absolute;
        right: 10px;
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 16px;
        z-index: 1;
        padding: 0;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }
    
    .tree-sort {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        white-space: nowrap;
        flex-shrink: 0;
        height: 30px;
        align-self: normal;
    }
    
    .tree-sort label {
        margin: 0;
        padding: 0;
        line-height: 30px;
        color: var(--text-secondary);
        font-size: 14px;
        display: inline-block;
        vertical-align: middle;
        height: 30px;
    }
    
    .tree-sort select {
        padding: 4px 8px;
        height: 30px;
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
        cursor: pointer;
        appearance: auto;
        font-size: 14px;
        line-height: 1;
        margin: 0;
        vertical-align: middle;
        box-sizing: border-box;
    }
    
    .tree-sort select option {
        background-color: #252525;
        color: var(--text-primary);
    }

    /* Checkbox styling improvements */
    .checkbox-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 8px;
        flex-shrink: 0;
    }
    
    .tree-checkbox {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.7);
        border-radius: 3px;
        background-color: rgba(30, 30, 30, 0.8);
        cursor: pointer;
        position: relative;
        margin: 0;
        outline: none;
    }
    
    .tree-checkbox:checked {
        background-color: #28a745;
        border-color: #28a745;
    }
    
    .tree-checkbox:checked::after {
        content: "‚úì";
        position: absolute;
        color: white;
        font-size: 12px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
    }
    
    .tree-checkbox.indeterminate {
        background-color: rgba(40, 167, 69, 0.5);
        border-color: #28a745;
    }
    
    .tree-checkbox.indeterminate::after {
        content: "-";
        position: absolute;
        color: white;
        font-size: 14px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
    }
    
    .tree-checkbox:hover {
        border-color: #28a745;
    }

    /* Copy summary stats styling */
    .copy-summary-stats {
        display: flex;
        gap: 1.5rem;
        margin-bottom: 1rem;
        background-color: rgba(255, 255, 255, 0.08);
        padding: 10px 15px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stats-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .stats-label {
        color: var(--text-secondary);
        font-size: 14px;
    }
    
    .stats-value {
        font-weight: bold;
        font-size: 16px;
        color: var(--text-primary);
    }

    /* Count badge styling */
    .count-badge {
        color: rgba(255, 255, 255, 0.8);
        font-size: 14px;
        font-weight: normal;
        margin-left: 8px;
        background-color: rgba(60, 60, 60, 0.6);
        padding: 2px 8px;
        border-radius: 4px;
    }

    /* Create Prompt section styles */
    .prompt-input {
        width: 100%;
        min-height: 200px;
        padding: 1rem;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: monospace;
        font-size: 14px;
        line-height: 1.5;
        resize: vertical;
        margin-bottom: 1rem;
        max-width: 100%;
        box-sizing: border-box;
    }
    
    .prompt-input:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px var(--accent-color-transparent);
    }
    
    .copy-settings {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 1rem;
        margin-bottom: 1rem;
        max-width: 100%;
        box-sizing: border-box;
    }
    
    .copy-settings h4 {
        margin: 0 0 0.75rem 0;
        color: var(--text-primary);
        font-size: 1rem;
    }
    
    .settings-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .setting-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 0.9rem;
    }
    
    .setting-item input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
    }
    
    .setting-item span {
        user-select: none;
    }

    /* Update Create Prompt section styles */
    #step-create-prompt {
        max-width: 800px;
        width: auto;
        margin: 0 auto;
    }

    /* Copy Settings Panel styles */
    .copy-settings-content {
        padding: 1rem;
    }

    .settings-group {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .setting-item {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 0.75rem;
        align-items: start;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 4px;
        transition: background-color 0.2s;
    }

    .setting-item:hover {
        background-color: rgba(255, 255, 255, 0.05);
    }

    .setting-item input[type="checkbox"] {
        width: 16px;
        height: 16px;
        margin-top: 3px;
    }

    .setting-label {
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 0.25rem;
        grid-column: 2;
        grid-row: 1;
    }

    .setting-description {
        color: var(--text-secondary);
        font-size: 0.9rem;
        grid-column: 2;
        grid-row: 2;
    }

    /* Prompt Input styles */
    .prompt-input {
        width: 100%;
        min-height: 150px;
        padding: 1rem;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: monospace;
        font-size: 14px;
        line-height: 1.5;
        resize: vertical;
        margin-bottom: 1rem;
        max-width: 100%;
        box-sizing: border-box;
    }
    
    .prompt-input:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px var(--accent-color-transparent);
    }
    
    .copy-settings {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 1rem;
        margin-bottom: 1rem;
        max-width: 100%;
        box-sizing: border-box;
    }
    
    .copy-settings h4 {
        margin: 0 0 0.75rem 0;
        color: var(--text-primary);
        font-size: 1rem;
    }
    
    .settings-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .setting-item {
        display: flex;
        align-items: flex-start;
        gap: 1rem;
        padding: 0.5rem;
        border-radius: 4px;
        transition: background-color 0.2s;
    }

    .setting-item:hover {
        background-color: rgba(255, 255, 255, 0.05);
    }

    .setting-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin-top: 2px;
        cursor: pointer;
        border: 2px solid var(--border-color);
        border-radius: 3px;
        background-color: var(--bg-tertiary);
        appearance: none;
        -webkit-appearance: none;
        position: relative;
        flex-shrink: 0;
    }

    .setting-item input[type="checkbox"]:checked {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
    }

    .setting-item input[type="checkbox"]:checked::after {
        content: "‚úì";
        position: absolute;
        color: white;
        font-size: 12px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    .setting-info {
        flex: 1;
    }

    .setting-label {
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 0.25rem;
    }

    .setting-description {
        color: var(--text-secondary);
        font-size: 0.9rem;
    }

    /* Prompt Input styles */
    .prompt-input {
        width: 100%;
        min-height: 150px;
        padding: 1rem;
        background-color: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: monospace;
        font-size: 14px;
        line-height: 1.5;
        resize: vertical;
    }

    .prompt-input:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }

    /* Add this to the existing styles */
    .path-info {
        margin-top: 8px;
        font-size: 14px;
        color: #68b5e1;
        font-style: italic;
    }
    
    /* Path header style */
    .path-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    /* Clear path button */
    .clear-path-btn {
        background: none;
        border: none;
        color: #ff6b6b;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        padding: 0 5px;
        margin-left: 10px;
        border-radius: 50%;
        transition: background-color 0.2s;
    }
    
    .clear-path-btn:hover {
        background-color: rgba(255, 107, 107, 0.2);
    }
    
    /* Disabled button styles */
    .btn:disabled, .btn.disabled {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
    }

    /* Path input container for dropdown and text input */
    .path-input-container {
        display: flex;
        margin-bottom: 10px;
        align-items: center;
        gap: 10px;
    }
    
    .path-input-container select, 
    .path-input-container input {
        flex: 1;
    }
    
    .path-input {
        padding: 6px 10px;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-size: 14px;
        width: 100%;
    }
    
    .path-input:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }

    /* Add CSS style for disabled/readonly inputs */
    .disabled-input {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: rgba(0, 0, 0, 0.1);
    }
    
    /* XML Parser specific styles */
    .xml-input {
        width: 100%;
        min-height: 150px;
        padding: 1rem;
        background-color: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: monospace;
        font-size: 14px;
        line-height: 1.5;
        resize: vertical;
        margin-bottom: 1rem;
    }
    
    .xml-input:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }
    
    .repo-details {
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .repo-detail-item {
        display: flex;
        margin-bottom: 0.5rem;
    }
    
    .repo-detail-label {
        font-weight: 500;
        min-width: 100px;
        color: var(--text-secondary);
    }
    
    .repo-detail-value {
        color: var(--text-primary);
    }
    
    .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        text-transform: uppercase;
    }
    
    .badge.create {
        background-color: #28a745;
        color: white;
    }
    
    .badge.modify, .badge.update {
        background-color: #007bff;
        color: white;
    }
    
    .badge.delete {
        background-color: #dc3545;
        color: white;
    }
    
    .badge.rewrite {
        background-color: #17a2b8;
        color: white;
    }
    
    .file-item {
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
        padding: 0.75rem;
        margin-bottom: 0.5rem;
    }
    
    .file-item.success {
        border-left: 4px solid #28a745;
    }
    
    .file-item.error {
        border-left: 4px solid #dc3545;
    }
    
    .file-header {
        display: flex;
        align-items: center;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    
    .file-path {
        word-break: break-all;
    }
    
    .file-status, .file-warning, .file-error {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 0.25rem;
    }
    
    .file-warning {
        color: #ffc107;
    }
    
    .file-error {
        color: #dc3545;
    }
    
    .no-repos {
        padding: 1rem;
        text-align: center;
        color: var(--text-secondary);
        font-style: italic;
    }
    
    .status-icon {
        font-size: 16px;
    }

    /* XML Parser section styles */
    #step-xml-parser {
        max-width: 800px;
        width: auto;
        margin: 0 auto;
        margin-top: 30px;
    }
</style>
{% endblock %}