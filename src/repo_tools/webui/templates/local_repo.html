{% extends "base.html" %}

{% block title %}Repo Tools - Local Repository{% endblock %}

{% block content %}
<div class="page-header">
    <h2>ğŸ“¦ Local Repository Context Copier</h2>
    <p>Copy code context from local repositories on your machine</p>
</div>

<div class="workflow-container">
    <div class="workflow-step" id="step-path-select">
        <h3>ğŸ” Step 1: Select Path</h3>
        <div class="form-group">
            <label for="path-select">Choose a path to search for repositories:</label>
            <select id="path-select" class="select-dark"></select>
            <div class="button-group">
                <button id="scan-button" class="btn">Scan for Repositories</button>
                <button id="browse-button" class="btn btn-blue">Browse for Path</button>
                <input type="file" id="directory-input" webkitdirectory directory multiple style="display: none;" />
            </div>
        </div>
        <div id="custom-path" class="custom-path hidden">
            <p class="selected-path-label">Selected custom path:</p>
            <p id="selected-path-display" class="selected-path"></p>
        </div>
        <div id="path-loading" class="loading-indicator hidden">
            <div class="spinner"></div>
            <p>Scanning for repositories...</p>
        </div>
    </div>
    
    <div class="workflow-step hidden" id="step-repo-select">
        <h3>ğŸ“‹ Step 2: Select Repositories <span id="repo-selection-count" class="selection-count hidden">0</span></h3>
        
        <!-- New section for displaying selected repositories with X buttons -->
        <div id="repo-select-summary" class="summary-section hidden">
            <h4>Selected Repositories:</h4>
            <div id="repo-select-list" class="repo-list">
                <!-- Selected repos will be shown here with X buttons -->
            </div>
        </div>
        
        <div class="form-group">
            <label>Select one or more repositories:</label>
            <div id="repo-checklist" class="repo-checklist">
                <!-- Repositories will be populated here as checkboxes -->
            </div>
            <div class="button-group">
                <button id="load-repos-button" class="btn">Load Selected Repositories</button>
                <button id="back-to-path-button" class="btn btn-secondary">Back</button>
            </div>
        </div>
        <div id="repo-loading" class="loading-indicator hidden">
            <div class="spinner"></div>
            <p>Loading repository files...</p>
        </div>
    </div>
    
    <div class="workflow-step hidden" id="step-file-summary">
        <h3>ğŸ“Š Step 3: File Summary</h3>
        
        <div id="selected-repos-summary" class="summary-section hidden">
            <h4>Selected Repositories (<span id="selected-repos-count">0</span>/50):</h4>
            <div id="selected-repos-list" class="repo-list">
                <!-- Selected repos will be shown here -->
            </div>
        </div>
        
        <!-- Files to be included section -->
        <div class="summary-box">
            <div class="summary-header">
                <h4>Files to be included:</h4>
                <span id="included-count" class="count-badge">0 files</span>
            </div>
            
            <!-- File Tree Search -->
            <div class="tree-search">
                <span class="tree-search-icon">ğŸ”</span>
                <input type="text" id="tree-search-input" class="tree-search-input" placeholder="Search files...">
                <button id="tree-search-clear" class="tree-search-clear">Ã—</button>
            </div>
            
            <!-- New File Tree View -->
            <div id="file-tree" class="file-tree">
                <!-- File tree will be rendered here -->
                <div class="tree-empty">
                    <div class="tree-empty-icon">ğŸ“‚</div>
                    <p>No files loaded yet</p>
                </div>
            </div>
        </div>
        
        <!-- Files ignored section - collapsed by default -->
        <div class="summary-box ignored-files-section">
            <div class="summary-header ignored-header" id="ignored-files-header">
                <h4>Files ignored:</h4>
                <span id="ignored-count" class="count-badge">0 files</span>
                <button class="expand-collapse-btn">Expand â–¼</button>
            </div>
            
            <!-- Collapsed content -->
            <div class="ignored-content hidden">
                <!-- Ignored Files Tree Search -->
                <div class="tree-search">
                    <span class="tree-search-icon">ğŸ”</span>
                    <input type="text" id="ignored-tree-search-input" class="tree-search-input" placeholder="Search ignored files...">
                    <button id="ignored-tree-search-clear" class="tree-search-clear">Ã—</button>
                </div>
                
                <!-- Ignored Files Tree View -->
                <div id="ignored-file-tree" class="file-tree">
                    <!-- Ignored file tree will be rendered here -->
                    <div class="tree-empty">
                        <div class="tree-empty-icon">ğŸ“‚</div>
                        <p>No ignored files loaded yet</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="action-buttons">
            <!-- Add token count display above button -->
            <div class="total-tokens-display">
                <span>Total tokens to be copied: </span>
                <span id="total-tokens-count" class="token-count-badge">0</span>
            </div>
            <button id="copy-button" class="btn btn-primary">ğŸ“‹ Copy to Clipboard</button>
            <button id="refresh-button" class="btn btn-info">ğŸ”„ Refresh Files</button>
            <button id="back-to-select-button" class="btn btn-secondary">Back</button>
        </div>
    </div>
</div>

<!-- File Preview Modal -->
<div id="file-preview-modal" class="file-preview-modal">
    <div class="file-preview-content">
        <div class="file-preview-header">
            <div class="file-preview-title">
                <span class="file-preview-title-icon">ğŸ“„</span>
                <span id="file-preview-filename">filename.ext</span>
            </div>
            <button id="file-preview-close" class="file-preview-close">Ã—</button>
        </div>
        <div class="file-preview-body">
            <pre id="file-preview-code" class="file-preview-code"></pre>
        </div>
    </div>
</div>

<div id="notification" class="notification hidden">
    <div class="notification-content">
        <span id="notification-message"></span>
        <span class="notification-close">&times;</span>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize socket.io
        const socket = io();
        
        // DOM elements
        const stepPathSelect = document.getElementById('step-path-select');
        const pathSelect = document.getElementById('path-select');
        const scanButton = document.getElementById('scan-button');
        const browseButton = document.getElementById('browse-button');
        const directoryInput = document.getElementById('directory-input');
        const customPath = document.getElementById('custom-path');
        const selectedPathDisplay = document.getElementById('selected-path-display');
        const pathLoading = document.getElementById('path-loading');
        
        const stepRepoSelect = document.getElementById('step-repo-select');
        const repoChecklist = document.getElementById('repo-checklist');
        const repoSelectionCount = document.getElementById('repo-selection-count');
        const loadReposButton = document.getElementById('load-repos-button');
        const backToPathButton = document.getElementById('back-to-path-button');
        const repoLoading = document.getElementById('repo-loading');
        
        const repoSelectSummary = document.getElementById('repo-select-summary');
        const repoSelectList = document.getElementById('repo-select-list');
        
        const stepFileSummary = document.getElementById('step-file-summary');
        const includedCount = document.getElementById('included-count');
        const fileTree = document.getElementById('file-tree');
        const ignoredCount = document.getElementById('ignored-count');
        const ignoredHeader = document.getElementById('ignored-files-header');
        const ignoredContent = document.querySelector('.ignored-content');
        const expandCollapseBtn = document.querySelector('.expand-collapse-btn');
        const ignoredFileTree = document.getElementById('ignored-file-tree');
        const copyButton = document.getElementById('copy-button');
        const refreshButton = document.getElementById('refresh-button');
        const backToSelectButton = document.getElementById('back-to-select-button');
        const selectedReposSummary = document.getElementById('selected-repos-summary');
        const selectedReposCount = document.getElementById('selected-repos-count');
        const selectedReposList = document.getElementById('selected-repos-list');
        
        // File tree search
        const treeSearchInput = document.getElementById('tree-search-input');
        const treeSearchClear = document.getElementById('tree-search-clear');
        const ignoredTreeSearchInput = document.getElementById('ignored-tree-search-input');
        const ignoredTreeSearchClear = document.getElementById('ignored-tree-search-clear');
        
        // File preview modal
        const filePreviewModal = document.getElementById('file-preview-modal');
        const filePreviewFilename = document.getElementById('file-preview-filename');
        const filePreviewCode = document.getElementById('file-preview-code');
        const filePreviewClose = document.getElementById('file-preview-close');
        
        const notification = document.getElementById('notification');
        const notificationMessage = document.getElementById('notification-message');
        const notificationClose = document.querySelector('.notification-close');
        
        // Repository data
        let availableRepos = [];
        let selectedRepoIds = []; // Store selected repo IDs
        let selectedRepos = [];
        let fileTreeData = []; // Store hierarchical file tree data for included files
        let ignoredTreeData = []; // Store hierarchical file tree data for ignored files
        let totalTokenCount = 0; // Track total tokens across all repos
        
        // Toggle ignored files section expand/collapse
        ignoredHeader.addEventListener('click', function() {
            ignoredContent.classList.toggle('hidden');
            const btn = this.querySelector('.expand-collapse-btn');
            
            if (ignoredContent.classList.contains('hidden')) {
                btn.textContent = 'Expand â–¼';
            } else {
                btn.textContent = 'Collapse â–²';
                // When expanding, re-render the ignored files tree
                renderIgnoredFileTree();
            }
        });
        
        // Load paths
        function loadPaths() {
            axios.get('/api/paths')
                .then(response => {
                    pathSelect.innerHTML = '';
                    response.data.paths.forEach(path => {
                        const option = document.createElement('option');
                        option.value = path.path;
                        option.textContent = path.display;
                        
                        // Set selected if this is the default path (parent directory)
                        if (response.data.default && path.path === response.data.default) {
                            option.selected = true;
                        }
                        
                        pathSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    showNotification('Error loading paths: ' + error.message, 'error');
                });
        }
        
        // Scan for repositories
        function scanRepositories() {
            // First check if we have a custom path displayed
            let path;
            if (!customPath.classList.contains('hidden')) {
                // Use the custom path from the file browser
                path = selectedPathDisplay.textContent.trim();
            } else {
                // Use the path from the dropdown
                path = pathSelect.value;
            }
            
            if (!path) {
                showNotification('Please select a valid path', 'error');
                return;
            }
            
            pathLoading.classList.remove('hidden');
            
            socket.emit('scan_repos', { path: path });
        }
        
        // Handle directory selection via browser's file dialog
        function handleDirectorySelection(e) {
            if (e.target.files.length > 0) {
                // Get the root directory path
                const rootPath = e.target.files[0].webkitRelativePath.split('/')[0];
                
                // Extract the full path in a cross-platform way
                // This is a limitation of the browser API - we can only get the selected directory name,
                // not its full path due to security restrictions
                // We'll display the selected directory name and pass it to the backend
                
                // Display the selected directory
                selectedPathDisplay.textContent = rootPath;
                customPath.classList.remove('hidden');
                
                // Simulate full path for display (this would need backend functionality)
                // In a real implementation, you would need to resolve this path on the server side
                showNotification(`Selected directory: ${rootPath}`, 'info');
            }
        }

        // Update selection count badge
        function updateSelectionCount() {
            const count = selectedRepoIds.length;
            repoSelectionCount.textContent = count;
            
            if (count > 0) {
                repoSelectionCount.classList.remove('hidden');
                repoSelectSummary.classList.remove('hidden');
            } else {
                repoSelectionCount.classList.add('hidden');
                repoSelectSummary.classList.add('hidden');
            }
            
            // Update the selected repositories display in Step 2
            updateRepoSelectList();
        }
        
        // Update the list of selected repositories in Step 2
        function updateRepoSelectList() {
            repoSelectList.innerHTML = '';
            
            // Create a select item for each selected repo
            selectedRepoIds.forEach(repoId => {
                const repo = availableRepos.find(r => r.id === repoId);
                if (!repo) return;
                
                const repoItem = document.createElement('div');
                repoItem.classList.add('repo-item');
                repoItem.innerHTML = `
                    <span class="repo-name">ğŸ“‚ ${repo.name}</span>
                    <button class="repo-remove-btn" data-repo-id="${repo.id}">Ã—</button>
                `;
                repoSelectList.appendChild(repoItem);
                
                // Add event listener to the remove button
                const removeButton = repoItem.querySelector('.repo-remove-btn');
                removeButton.addEventListener('click', function() {
                    const repoId = this.dataset.repoId;
                    
                    // Remove from selectedRepoIds
                    const index = selectedRepoIds.indexOf(repoId);
                    if (index !== -1) {
                        selectedRepoIds.splice(index, 1);
                    }
                    
                    // Update the checkbox state
                    const checkbox = repoChecklist.querySelector(`input[id="${repoId}"]`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    
                    // Update UI
                    updateSelectionCount();
                });
            });
        }
        
        // Load selected repositories
        function loadSelectedRepositories() {
            if (selectedRepoIds.length === 0) {
                showNotification('Please select at least one repository', 'warning');
                return;
            }
            
            // Disable Step 2
            stepRepoSelect.classList.add('disabled');
            
            // Show loading indicator
            repoLoading.classList.remove('hidden');
            
            // Keep track of loaded repositories
            let loadedCount = 0;
            selectedRepos = [];
            fileTreeData = [];
            ignoredTreeData = [];
            
            // Load each selected repository
            selectedRepoIds.forEach((repoId, index) => {
                const repo = availableRepos.find(r => r.id === repoId);
                if (!repo) return;
                
                setTimeout(() => {
                    axios.post('/api/repo-files', { repoPath: repo.path })
                        .then(response => {
                            // Create repository object with data
                            const loadedRepo = {
                                name: repo.name,
                                path: repo.path,
                                included: response.data.included,
                                ignored: response.data.ignored
                            };
                            
                            // Add to selected repos
                            selectedRepos.push(loadedRepo);
                            
                            // Convert the repository's included files into a hierarchical tree structure
                            const repoTreeData = buildFileTree(loadedRepo.included, loadedRepo.name, false);
                            fileTreeData.push(repoTreeData);
                            
                            // Convert the repository's ignored files into a hierarchical tree structure
                            const repoIgnoredTreeData = buildFileTree(loadedRepo.ignored.map(path => ({ path, content: "" })), loadedRepo.name, true);
                            ignoredTreeData.push(repoIgnoredTreeData);
                            
                            // Track completion
                            loadedCount++;
                            
                            // If all repos are loaded
                            if (loadedCount === selectedRepoIds.length) {
                                repoLoading.classList.add('hidden');
                                
                                // Update UI with file summary
                                updateFileSummary();
                                
                                // Render the file trees
                                renderFileTree();
                                // Ignored file tree will be rendered when expanded
                                
                                // Show the file summary step
                                stepFileSummary.classList.remove('hidden');
                                
                                // Save initial selection state to localStorage
                                saveSelectionState();
                            }
                        })
                        .catch(error => {
                            loadedCount++;
                            showNotification(`Error loading repository ${repo.name}: ${error.message}`, 'error');
                            
                            // If all repos are loaded
                            if (loadedCount === selectedRepoIds.length) {
                                repoLoading.classList.add('hidden');
                                
                                if (selectedRepos.length > 0) {
                                    // We have at least some repos, so continue
                                    updateFileSummary();
                                    renderFileTree();
                                    stepFileSummary.classList.remove('hidden');
                                } else {
                                    // Re-enable Step 2 if no repos were loaded
                                    stepRepoSelect.classList.remove('disabled');
                                }
                            }
                        });
                }, index * 200); // Stagger requests
            });
        }
        
        // Go back to Step 1
        function backToPathSelection() {
            // Hide Step 2
            stepRepoSelect.classList.add('hidden');
            
            // Re-enable Step 1
            stepPathSelect.classList.remove('disabled');
            
            // Clear previous selections
            selectedRepoIds = [];
            availableRepos = [];
            repoChecklist.innerHTML = '';
            updateSelectionCount();
        }
        
        // Estimate tokens in text
        function estimateTokens(text) {
            if (!text) return 0;
            
            // Basic estimation: characters / 4 is a reasonable approximation
            // For more accuracy, we could use a proper tokenizer library
            const charCount = text.length;
            return Math.ceil(charCount / 4);
        }
        
        // Format token count with abbreviation
        function formatTokenCount(count) {
            if (count < 1000) {
                return count.toString();
            } else if (count < 1000000) {
                return (Math.round(count / 100) / 10).toFixed(1) + 'k';
            } else {
                return (Math.round(count / 100000) / 10).toFixed(1) + 'M';
            }
        }
        
        // Helper function to display "Unknown" for ignored files token counts
        function getTokenDisplay(file) {
            if (file.isIgnored) {
                return "Unknown";
            }
            return formatTokenCount(file.tokenCount || 0);
        }
        
        // Build a hierarchical file tree from flat file list
        function buildFileTree(files, repoName, isIgnored = false) {
            const root = { 
                name: repoName, 
                type: 'repo', 
                children: {}, 
                expanded: true,
                fileCount: 0, // Will be calculated below
                tokenCount: 0,
                selected: !isIgnored, // Default selected state (true for included, false for ignored)
                indeterminate: false,
                isIgnored: isIgnored
            };
            let totalFileCount = 0;

            files.forEach(file => {
                // Convert ignored files array format to match included files format
                const filePath = typeof file === 'string' ? file : file.path;
                const fileContent = typeof file === 'string' ? "" : file.content;
                
                // Estimate tokens in file content
                const tokenCount = estimateTokens(fileContent);
                totalFileCount++; // Increment total file count for the repo
                
                // Extract the relative path (remove repository path prefix if present)
                let relativePath = filePath;
                if (typeof relativePath === 'string' && relativePath.includes(repoName)) {
                    // Try to extract the relative path after the repository name
                    const parts = relativePath.split(repoName);
                    if (parts.length > 1) {
                        relativePath = parts[1].replace(/^[\/\\]/, ''); // Remove leading slash
                    }
                }
                
                // Split path into segments
                const pathSegments = relativePath.split(/[/\\]/);
                
                let currentLevelNode = root;
                const ancestorNodes = [root]; // Store ancestors, starting with root
                
                // Navigate through directories, creating as needed
                for (let i = 0; i < pathSegments.length - 1; i++) {
                    const segment = pathSegments[i];
                    if (!segment) continue; // Skip empty segments (e.g., from double slashes)
                    
                    // Build the directory path for this level (relative to repo root)
                    const dirPath = pathSegments.slice(0, i + 1).join('/');
                    
                    if (!currentLevelNode.children[segment]) {
                        currentLevelNode.children[segment] = { 
                            name: segment, 
                            type: 'directory',
                            children: {},
                            expanded: false,
                            fileCount: 0, // Initialize file count for new directory
                            tokenCount: 0, // Initialize token count for new directory
                            path: dirPath, // Store relative path for the directory
                            selected: !isIgnored, // Default selected state (true for included, false for ignored)
                            indeterminate: false,
                            isIgnored: isIgnored
                        };
                    }
                    // Increment file count for the directory containing this file/subdir
                    currentLevelNode.children[segment].fileCount++;
                    
                    // Move down to the next level node
                    currentLevelNode = currentLevelNode.children[segment];
                    ancestorNodes.push(currentLevelNode); // Add this directory to ancestors
                }
                
                // Add the file at the final level
                const fileName = pathSegments[pathSegments.length - 1];
                if (fileName) {
                    currentLevelNode.children[fileName] = { 
                        name: fileName, 
                        type: 'file',
                        path: filePath, // Store full original path
                        content: fileContent,
                        extension: getFileExtension(fileName),
                        tokenCount: tokenCount,
                        selected: !isIgnored, // Default selected state (true for included, false for ignored)
                        indeterminate: false,
                        isIgnored: isIgnored
                    };
                    
                    // Update token counts for all ancestors (directories and the root)
                    ancestorNodes.forEach(ancestor => {
                        ancestor.tokenCount += tokenCount;
                    });
                }
            });
            
            // Set the final file count for the root node
            root.fileCount = totalFileCount;

            // After building the tree, update all selection states from bottom to top
            // (This ensures indeterminate states are set correctly if loaded state is partially selected)
            updateSelectionStatesBottomUp(root);
            
            return root;
        }
        
        // Get file extension
        function getFileExtension(filename) {
            return filename.slice((filename.lastIndexOf('.') - 1 >>> 0) + 2);
        }
        
        // Get file icon based on extension
        function getFileIcon(extension) {
            const iconMap = {
                // Web
                'html': 'ğŸ“„',
                'css': 'ğŸ“„',
                'js': 'ğŸ“„',
                'jsx': 'ğŸ“„',
                'ts': 'ğŸ“„',
                'tsx': 'ğŸ“„',
                
                // Config
                'json': 'âš™ï¸',
                'yml': 'âš™ï¸',
                'yaml': 'âš™ï¸',
                'toml': 'âš™ï¸',
                'env': 'ğŸ”‘',
                
                // Backend
                'py': 'ğŸ',
                'rb': 'ğŸ’',
                'php': 'ğŸ˜',
                'java': 'â˜•',
                'go': 'ğŸš€',
                'rs': 'ğŸ¦€',
                'c': 'ğŸ§®',
                'cpp': 'ğŸ§®',
                'cs': 'ğŸ§®',
                
                // Data
                'sql': 'ğŸ—„ï¸',
                'csv': 'ğŸ“Š',
                'xml': 'ğŸ“Š',
                
                // Documents
                'md': 'ğŸ“',
                'mdx': 'ğŸ“',
                'txt': 'ğŸ“',
                
                // Default
                'default': 'ğŸ“„'
            };
            
            return iconMap[extension.toLowerCase()] || iconMap.default;
        }
        
        // Render file tree
        function renderFileTree() {
            // Clear previous content
            fileTree.innerHTML = '';
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            let totalFileCount = 0;
            let selectedFileCount = 0;
            
            // Handle empty case
            if (fileTreeData.length === 0) {
                fileTree.innerHTML = `
                    <div class="tree-empty">
                        <div class="tree-empty-icon">ğŸ“‚</div>
                        <p>No files loaded yet</p>
                    </div>
                `;
                return;
            }
            
            // Calculate counts first to ensure accuracy
            fileTreeData.forEach(repo => {
                totalTokenCount += repo.tokenCount;
                totalFileCount += repo.fileCount;
                
                // Count selected items
                if (repo.selected) {
                    selectedTokenCount += repo.tokenCount;
                    selectedFileCount += repo.fileCount;
                } else if (repo.indeterminate) {
                    // For indeterminate state, count only selected children
                    selectedTokenCount += getSelectedTokenCount(repo);
                    selectedFileCount += getSelectedFileCount(repo);
                }
            });

            // Now render the tree with accurate counts
            fileTreeData.forEach(repo => {
                const repoElement = document.createElement('div');
                repoElement.classList.add('tree-repo');
                repoElement.dataset.name = repo.name;
                
                // Repository header
                const repoHeader = document.createElement('div');
                repoHeader.classList.add('tree-repo-header');
                
                // Create checkbox wrapper
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.classList.add('checkbox-wrapper');
                
                // Create checkbox for repository
                const repoCheckbox = document.createElement('input');
                repoCheckbox.type = 'checkbox';
                repoCheckbox.checked = repo.selected;
                repoCheckbox.classList.add('tree-checkbox');
                
                // Add indeterminate state if needed
                if (repo.indeterminate) {
                    repoCheckbox.classList.add('indeterminate');
                    repoCheckbox.dataset.indeterminate = 'true';
                }
                
                // Stop event propagation on the checkbox
                repoCheckbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                repoCheckbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    
                    // Apply selection state to repo and all its children
                    const isSelected = e.target.checked;
                    updateSelectionState(repo, isSelected);
                    
                    // Re-render tree immediately to reflect changes
                    renderFileTree();
                    
                    // Update the summary counts
                    updateFileSummary();
                    
                    // Save selection state to localStorage
                    saveSelectionState();
                });
                
                checkboxWrapper.appendChild(repoCheckbox);
                
                repoHeader.innerHTML = `
                    <div class="tree-repo-name">
                        <span class="tree-repo-icon">ğŸ“¦</span>
                        ${repo.name}
                    </div>
                    <div class="tree-repo-stats">
                        ${repo.fileCount} files Â· ~${formatTokenCount(repo.tokenCount)} tokens
                    </div>
                    <div class="tree-repo-actions">
                        <button class="tree-action-button expand-all">Expand All</button>
                        <button class="tree-action-button collapse-all">Collapse All</button>
                    </div>
                `;
                
                // Insert checkbox wrapper as first child
                repoHeader.insertBefore(checkboxWrapper, repoHeader.firstChild);
                
                // Repository content
                const repoContent = document.createElement('div');
                repoContent.classList.add('tree-repo-content');
                
                // Add repository children (directories and files)
                const sortedChildren = Object.values(repo.children)
                    .sort((a, b) => {
                        // Directories first, then files
                        if (a.type !== b.type) {
                            return a.type === 'directory' ? -1 : 1;
                        }
                        // Alphabetical within same type
                        return a.name.localeCompare(b.name);
                    });
                
                sortedChildren.forEach(child => {
                    if (child.type === 'directory') {
                        repoContent.appendChild(renderDirectory(child, repo.name));
                    } else {
                        repoContent.appendChild(renderFile(child, repo.name));
                    }
                });
                
                // Keep existing event listeners for expand/collapse all
                const expandAllBtn = repoHeader.querySelector('.expand-all');
                expandAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.add('expanded');
                    });
                });
                
                const collapseAllBtn = repoHeader.querySelector('.collapse-all');
                collapseAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.remove('expanded');
                    });
                });
                
                // Toggle repository content on header click
                repoHeader.addEventListener('click', (e) => {
                    // Only toggle if not clicking on checkbox, its wrapper, or action buttons
                    if (!e.target.closest('.checkbox-wrapper') && !e.target.closest('.tree-action-button')) {
                        repoElement.classList.toggle('expanded');
                    }
                });
                
                repoElement.appendChild(repoHeader);
                repoElement.appendChild(repoContent);
                fileTree.appendChild(repoElement);
            });
            
            // Update the included count with selected token information
            includedCount.textContent = `${selectedFileCount} of ${totalFileCount} files Â· ~${formatTokenCount(selectedTokenCount)} tokens`;

            // Update total tokens count above the Copy button
            const totalTokensCount = document.getElementById('total-tokens-count');
            if (totalTokensCount) {
                totalTokensCount.textContent = formatTokenCount(selectedTokenCount);
            }

            // Apply search filter if search input has value
            applySearchFilter();
        }
        
        // Render ignored file tree - similar to renderFileTree but for ignored files
        function renderIgnoredFileTree() {
            // Clear previous content
            ignoredFileTree.innerHTML = '';
            let totalIgnoredFileCount = 0;
            let selectedIgnoredFileCount = 0;
            
            // Handle empty case
            if (ignoredTreeData.length === 0) {
                ignoredFileTree.innerHTML = `
                    <div class="tree-empty">
                        <div class="tree-empty-icon">ğŸ“‚</div>
                        <p>No ignored files loaded yet</p>
                    </div>
                `;
                return;
            }
            
            // Calculate counts first to ensure accuracy
            ignoredTreeData.forEach(repo => {
                totalIgnoredFileCount += repo.fileCount;
                
                // Count selected items
                if (repo.selected) {
                    selectedIgnoredFileCount += repo.fileCount;
                } else if (repo.indeterminate) {
                    // For indeterminate state, count only selected children
                    selectedIgnoredFileCount += getSelectedFileCount(repo);
                }
            });

            // Now render the tree with accurate counts
            ignoredTreeData.forEach(repo => {
                const repoElement = document.createElement('div');
                repoElement.classList.add('tree-repo');
                repoElement.dataset.name = repo.name;
                
                // Repository header
                const repoHeader = document.createElement('div');
                repoHeader.classList.add('tree-repo-header');
                
                // Create checkbox wrapper
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.classList.add('checkbox-wrapper');
                
                // Create checkbox for repository
                const repoCheckbox = document.createElement('input');
                repoCheckbox.type = 'checkbox';
                repoCheckbox.checked = repo.selected;
                repoCheckbox.classList.add('tree-checkbox');
                
                // Add indeterminate state if needed
                if (repo.indeterminate) {
                    repoCheckbox.classList.add('indeterminate');
                    repoCheckbox.dataset.indeterminate = 'true';
                }
                
                // Stop event propagation on the checkbox
                repoCheckbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                repoCheckbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    
                    // Apply selection state to repo and all its children
                    const isSelected = e.target.checked;
                    updateSelectionState(repo, isSelected);
                    
                    // Re-render tree immediately to reflect changes
                    renderIgnoredFileTree();
                    
                    // Update the summary counts
                    updateFileSummary();
                    
                    // Save selection state to localStorage
                    saveSelectionState();
                });
                
                checkboxWrapper.appendChild(repoCheckbox);
                
                repoHeader.innerHTML = `
                    <div class="tree-repo-name">
                        <span class="tree-repo-icon">ğŸ“¦</span>
                        ${repo.name}
                    </div>
                    <div class="tree-repo-stats">
                        ${repo.fileCount} files
                    </div>
                    <div class="tree-repo-actions">
                        <button class="tree-action-button expand-all">Expand All</button>
                        <button class="tree-action-button collapse-all">Collapse All</button>
                    </div>
                `;
                
                // Insert checkbox wrapper as first child
                repoHeader.insertBefore(checkboxWrapper, repoHeader.firstChild);
                
                // Repository content
                const repoContent = document.createElement('div');
                repoContent.classList.add('tree-repo-content');
                
                // Add repository children (directories and files)
                const sortedChildren = Object.values(repo.children)
                    .sort((a, b) => {
                        // Directories first, then files
                        if (a.type !== b.type) {
                            return a.type === 'directory' ? -1 : 1;
                        }
                        // Alphabetical within same type
                        return a.name.localeCompare(b.name);
                    });
                
                sortedChildren.forEach(child => {
                    if (child.type === 'directory') {
                        repoContent.appendChild(renderDirectory(child, repo.name));
                    } else {
                        repoContent.appendChild(renderFile(child, repo.name));
                    }
                });
                
                // Keep existing event listeners for expand/collapse all
                const expandAllBtn = repoHeader.querySelector('.expand-all');
                expandAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.add('expanded');
                    });
                });
                
                const collapseAllBtn = repoHeader.querySelector('.collapse-all');
                collapseAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const directories = repoElement.querySelectorAll('.tree-directory');
                    directories.forEach(dir => {
                        dir.classList.remove('expanded');
                    });
                });
                
                // Toggle repository content on header click
                repoHeader.addEventListener('click', (e) => {
                    // Only toggle if not clicking on checkbox, its wrapper, or action buttons
                    if (!e.target.closest('.checkbox-wrapper') && !e.target.closest('.tree-action-button')) {
                        repoElement.classList.toggle('expanded');
                    }
                });
                
                repoElement.appendChild(repoHeader);
                repoElement.appendChild(repoContent);
                ignoredFileTree.appendChild(repoElement);
            });
            
            // Update the ignored count with selected file information
            ignoredCount.textContent = `${selectedIgnoredFileCount} of ${totalIgnoredFileCount} files`;

            // Apply search filter if search input has value
            applyIgnoredSearchFilter();
        }
        
        // Get selected file count from a node (repo or directory)
        function getSelectedFileCount(node) {
            if (node.type === 'file') {
                return node.selected ? 1 : 0;
            }
            
            // Removed the faulty check: if (!node.selected) return 0;
            // Always recurse down. If a directory/repo is truly deselected 
            // (selected=false, indeterminate=false), the recursive calls 
            // to its children will correctly return 0.
            
            let count = 0;
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    count += getSelectedFileCount(child);
                });
            }
            return count;
        }
        
        // Update selection state recursively
        function updateSelectionState(node, isSelected) {
            // Update this node's selection state
            node.selected = isSelected;
            // Clear indeterminate state when explicitly selected/deselected
            node.indeterminate = false;
            
            // Apply to all children recursively
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    updateSelectionState(child, isSelected);
                });
            }
        }
        
        // Check if all children of a node are selected
        function areAllChildrenSelected(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return true;
            }
            
            return Object.values(node.children).every(child => {
                return child.selected && (child.type === 'file' || areAllChildrenSelected(child));
            });
        }
        
        // Check if any children of a node are selected
        function areAnyChildrenSelected(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return false;
            }
            
            return Object.values(node.children).some(child => {
                return child.selected || (child.type !== 'file' && areAnyChildrenSelected(child));
            });
        }
        
        // Update parent selection states based on children
        function updateParentSelectionState(parentNode) {
            if (!parentNode.children || Object.keys(parentNode.children).length === 0) {
                return;
            }
            
            const allSelected = areAllChildrenSelected(parentNode);
            const anySelected = areAnyChildrenSelected(parentNode);
            
            // Set the node's selected state based on children
            if (allSelected) {
                parentNode.selected = true;
                parentNode.indeterminate = false;
            } else if (!anySelected) {
                parentNode.selected = false;
                parentNode.indeterminate = false;
            } else {
                // Some but not all children are selected
                parentNode.selected = false;
                parentNode.indeterminate = true;
            }
            
            return { allSelected, anySelected, indeterminate: parentNode.indeterminate };
        }
        
        // Update selection states from bottom to top
        function updateSelectionStatesBottomUp(node) {
            if (!node.children || Object.keys(node.children).length === 0) {
                return;
            }
            
            // First update all children recursively
            Object.values(node.children).forEach(child => {
                if (child.type === 'directory') {
                    updateSelectionStatesBottomUp(child);
                }
            });
            
            // Then update this node based on its children
            const allSelected = areAllChildrenSelected(node);
            const anySelected = areAnyChildrenSelected(node);
            
            // Update selection state
            if (allSelected) {
                node.selected = true;
                node.indeterminate = false;
            } else if (!anySelected) {
                node.selected = false;
                node.indeterminate = false;
            } else {
                // Some but not all children are selected
                node.selected = false;
                node.indeterminate = true;
            }
        }
        
        // Render directory
        function renderDirectory(directory, repoName) {
            const dirElement = document.createElement('div');
            dirElement.classList.add('tree-directory');
            dirElement.dataset.name = directory.name;
            
            // Directory header
            const dirHeader = document.createElement('div');
            dirHeader.classList.add('tree-directory-header');
            
            // Create checkbox wrapper
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.classList.add('checkbox-wrapper');
            
            // Create checkbox for directory
            const dirCheckbox = document.createElement('input');
            dirCheckbox.type = 'checkbox';
            dirCheckbox.checked = directory.selected;
            dirCheckbox.classList.add('tree-checkbox');
            
            // Add indeterminate state if needed
            if (directory.indeterminate) {
                dirCheckbox.indeterminate = true;
                dirCheckbox.classList.add('indeterminate');
                dirCheckbox.dataset.indeterminate = 'true';
            }
            
            // Handle checkbox directly - IMPORTANT: Stop both click and change events
            dirCheckbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop event from reaching dirHeader
            });
            
            dirCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Get the new selection state
                const isSelected = e.target.checked;
                
                // Apply selection state to directory and ALL its children recursively
                updateSelectionState(directory, isSelected);
                
                // Track if this directory was expanded before the change
                const wasExpanded = dirElement.classList.contains('expanded');
                
                // Update the directory's visuals without replacing the whole element
                // Just update the checkbox state and any visual indicators
                dirCheckbox.checked = directory.selected;
                dirCheckbox.indeterminate = directory.indeterminate;
                
                if (directory.indeterminate) {
                    dirCheckbox.classList.add('indeterminate');
                    dirCheckbox.dataset.indeterminate = 'true';
                } else {
                    dirCheckbox.classList.remove('indeterminate');
                    dirCheckbox.dataset.indeterminate = 'false';
                }
                
                // Recursively update child checkboxes
                updateChildCheckboxes(dirElement, directory.selected);
                
                // Make sure expanded state is preserved
                if (wasExpanded) {
                    dirElement.classList.add('expanded');
                }
                
                // Update parent selection states bottom-up
                updateTreeSelectionStates();
                
                // Update the summary counts only - no need to rebuild the entire tree
                updateFileSummaryWithoutRender();
                
                // Save selection state to localStorage
                saveSelectionState();
            });
            
            checkboxWrapper.appendChild(dirCheckbox);
            
            dirHeader.innerHTML = `
                <div class="tree-directory-name">
                    <span class="tree-directory-icon">â–¶</span>
                    <span>ğŸ“‚ ${directory.name}</span>
                </div>
                <div class="tree-directory-stats">
                    <span class="tree-directory-file-count">${directory.fileCount} files</span>
                    <span class="tree-directory-token-count">~${directory.isIgnored ? "Unknown" : formatTokenCount(directory.tokenCount)} tokens</span>
                </div>
            `;
            
            // Insert checkbox wrapper as first child
            dirHeader.insertBefore(checkboxWrapper, dirHeader.firstChild);
            
            // Directory content
            const dirContent = document.createElement('div');
            dirContent.classList.add('tree-directory-content');
            
            // Add directory children (subdirectories and files)
            const sortedChildren = Object.values(directory.children)
                .sort((a, b) => {
                    // Directories first, then files
                    if (a.type !== b.type) {
                        return a.type === 'directory' ? -1 : 1;
                    }
                    // Alphabetical within same type
                    return a.name.localeCompare(b.name);
                });
            
            sortedChildren.forEach(child => {
                if (child.type === 'directory') {
                    dirContent.appendChild(renderDirectory(child, repoName));
                } else {
                    dirContent.appendChild(renderFile(child, repoName));
                }
            });
            
            // Toggle directory expansion on header click
            dirHeader.addEventListener('click', (e) => {
                // Only toggle if not clicking on checkbox or its wrapper
                if (!e.target.closest('.checkbox-wrapper')) {
                    e.stopPropagation();
                    dirElement.classList.toggle('expanded');
                }
            });
            
            dirElement.appendChild(dirHeader);
            dirElement.appendChild(dirContent);
            return dirElement;
        }
        
        // Update all child checkboxes in the DOM
        function updateChildCheckboxes(parentElement, isSelected) {
            const childCheckboxes = parentElement.querySelectorAll('.tree-checkbox');
            childCheckboxes.forEach(checkbox => {
                checkbox.checked = isSelected;
                checkbox.indeterminate = false;
                checkbox.classList.remove('indeterminate');
                checkbox.dataset.indeterminate = 'false';
            });
        }
        
        // Render file
        function renderFile(file, repoName) {
            const fileElement = document.createElement('div');
            fileElement.classList.add('tree-file');
            if (file.extension) {
                fileElement.classList.add(file.extension.toLowerCase());
            }
            fileElement.dataset.name = file.name;
            fileElement.dataset.path = file.path;
            fileElement.dataset.repo = repoName;
            fileElement.dataset.tokens = file.tokenCount || 0;
            
            // File name parts
            const nameParts = file.name.split('.');
            const baseName = nameParts.length > 1 ? nameParts.slice(0, -1).join('.') : nameParts[0];
            const extension = nameParts.length > 1 ? nameParts[nameParts.length - 1] : '';
            
            // File icon
            const fileIcon = getFileIcon(file.extension || '');
            
            // Create checkbox wrapper
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.classList.add('checkbox-wrapper');
            
            // Create checkbox for file
            const fileCheckbox = document.createElement('input');
            fileCheckbox.type = 'checkbox';
            fileCheckbox.checked = file.selected;
            fileCheckbox.classList.add('tree-checkbox');
            
            // Handle checkbox directly
            fileCheckbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop event from propagating
            });
            
            fileCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Update this file's selection state
                file.selected = e.target.checked;
                
                // Find parent directory and update up the tree
                updateTreeSelectionStates();
                
                // Update just the checkbox appearance
                applyCheckboxState(fileCheckbox, file);
                
                // Update the summary counts
                updateFileSummaryWithoutRender();
                
                // Save selection state to localStorage
                saveSelectionState();
            });
            
            checkboxWrapper.appendChild(fileCheckbox);
            
            // Create file element structure
            const fileContent = document.createElement('div');
            fileContent.classList.add('tree-file-content');
            fileContent.innerHTML = `
                <span class="tree-file-icon">${fileIcon}</span>
                <span class="tree-file-name">${baseName}<span class="tree-file-ext">.${extension}</span></span>
                <span class="tree-file-tokens">~${file.isIgnored ? "Unknown" : formatTokenCount(file.tokenCount || 0)}</span>
            `;
            
            // Add checkbox and file content to the element
            fileElement.appendChild(checkboxWrapper);
            fileElement.appendChild(fileContent);
            
            // File click handler
            fileContent.addEventListener('click', (e) => {
                e.stopPropagation();
                // Only show preview if there's actual content
                if (file.content) {
                    showFilePreview(file);
                } else if (file.isIgnored) {
                    showNotification('Cannot preview ignored file content', 'info');
                }
            });
            
            return fileElement;
        }
        
        // Get current selection state
        function getSelectionState() {
            if ((!fileTreeData || fileTreeData.length === 0) && 
                (!ignoredTreeData || ignoredTreeData.length === 0)) return null;
            
            const state = {
                included: {},
                ignored: {}
            };
            
            // Save included files selection state
            fileTreeData.forEach(repo => {
                state.included[repo.name] = {
                    deselectedPaths: getNodeSelectionPaths(repo),
                    expansionState: getExpansionState(repo.name, false)
                };
            });
            
            // Save ignored files selection state
            ignoredTreeData.forEach(repo => {
                state.ignored[repo.name] = {
                    selectedPaths: getNodeSelectionPaths(repo, '', true),
                    expansionState: getExpansionState(repo.name, true)
                };
            });
            
            return state;
        }
        
        // Get all paths that are NOT selected for included files,
        // or paths that ARE selected for ignored files
        function getNodeSelectionPaths(node, basePath = '', isIgnored = false) {
            let paths = [];
            
            // For files
            if (node.type === 'file') {
                // For included files, store deselected paths
                // For ignored files, store selected paths
                if ((!isIgnored && !node.selected) || (isIgnored && node.selected)) {
                    // Use the full file path instead of just the name
                    paths.push(node.path);
                }
            } 
            // For directories
            else if (node.type === 'directory' || node.type === 'repo') {
                // For completely deselected directories in included files
                // or completely selected directories in ignored files
                if (((!isIgnored && !node.selected && !node.indeterminate) || 
                     (isIgnored && node.selected && !node.indeterminate)) && 
                    node.type === 'directory') {
                    
                    // For directories, use relative path within the repo
                    paths.push(basePath + (node.name || ''));
                } 
                // For directories with mixed selection, check children
                else if (node.children) {
                    Object.entries(node.children).forEach(([childName, child]) => {
                        const childPath = basePath + (node.name && node.type === 'directory' ? node.name + '/' : '') + childName;
                        paths = paths.concat(getNodeSelectionPaths(child, childPath, isIgnored));
                    });
                }
            }
            
            return paths;
        }
        
        // Get current expansion state (which directories are expanded)
        function getExpansionState(repoName, isIgnored = false) {
            const expandedDirs = [];
            const treeContainer = isIgnored ? ignoredFileTree : fileTree;
            const repoElement = treeContainer.querySelector(`.tree-repo[data-name="${repoName}"]`);
            
            if (repoElement) {
                // Get all expanded directories
                const dirs = repoElement.querySelectorAll('.tree-directory.expanded');
                dirs.forEach(dir => {
                    // Build path from repo name to this directory
                    let path = dir.dataset.name;
                    let parent = dir.parentElement.closest('.tree-directory');
                    
                    while (parent) {
                        path = parent.dataset.name + '/' + path;
                        parent = parent.parentElement.closest('.tree-directory');
                    }
                    
                    expandedDirs.push(path);
                });
            }
            
            return expandedDirs;
        }
        
        // Apply selection state saved previously
        function applySelectionState(state) {
            if (!state) return;
            
            // Apply to included files
            if (state.included && fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    const repoState = state.included[repo.name];
                    if (!repoState) return;
                    
                    // First reset all selections to true (default state for included files)
                    resetSelectionState(repo, true);
                    
                    // Apply deselected paths
                    if (repoState.deselectedPaths) {
                        repoState.deselectedPaths.forEach(path => {
                            applySelectionPath(repo, path, false);
                        });
                    }
                });
                
                // Update all parent selection states bottom-up
                fileTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
            }
            
            // Apply to ignored files
            if (state.ignored && ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    const repoState = state.ignored[repo.name];
                    if (!repoState) return;
                    
                    // First reset all selections to false (default state for ignored files)
                    resetSelectionState(repo, false);
                    
                    // Apply selected paths
                    if (repoState.selectedPaths) {
                        repoState.selectedPaths.forEach(path => {
                            applySelectionPath(repo, path, true);
                        });
                    }
                });
                
                // Update all parent selection states bottom-up
                ignoredTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
            }
        }
        
        // Apply selection to a specific path
        function applySelectionPath(node, path, value) {
            // Direct match for file paths - handles both stored relative and absolute paths
            if (node.type === 'file' && (path === node.path || path === node.name)) {
                node.selected = value;
                return true;
            }
            
            // Direct match for directory names
            if ((node.type === 'directory' || node.type === 'repo') && path === node.name) {
                node.selected = value;
                if (node.children) {
                    Object.values(node.children).forEach(child => {
                        resetSelectionState(child, value);
                    });
                }
                return true;
            }
            
            // Handle nested paths for directories
            if (path.startsWith(node.name + '/') && node.children) {
                const remainingPath = path.substring(node.name.length + 1);
                const nextSegment = remainingPath.split('/')[0];
                
                if (node.children[nextSegment]) {
                    return applySelectionPath(node.children[nextSegment], remainingPath, value);
                }
            }
            
            // Handle absolute file paths match - traverse all children looking for matching path
            if (node.children && node.type !== 'file') {
                for (const child of Object.values(node.children)) {
                    if (child.type === 'file' && child.path === path) {
                        child.selected = value;
                        return true;
                    }
                    
                    // Recursively search directories
                    if (child.type !== 'file' && applySelectionPath(child, path, value)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Reset selection state of node and all children
        function resetSelectionState(node, value) {
            node.selected = value;
            node.indeterminate = false;
            
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    resetSelectionState(child, value);
                });
            }
        }
        
        // Apply expansion state
        function applyExpansionState(state) {
            if (!state) return;
            
            // Apply after the trees have been rendered
            setTimeout(() => {
                // Apply to included files
                if (state.included) {
                    Object.keys(state.included).forEach(repoName => {
                        const repoState = state.included[repoName];
                        if (!repoState || !repoState.expansionState) return;
                        
                        const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repoName}"]`);
                        if (!repoElement) return;
                        
                        // Apply each expanded directory path
                        repoState.expansionState.forEach(path => {
                            applyExpansionPath(repoElement, path);
                        });
                    });
                }
                
                // Apply to ignored files
                if (state.ignored) {
                    Object.keys(state.ignored).forEach(repoName => {
                        const repoState = state.ignored[repoName];
                        if (!repoState || !repoState.expansionState) return;
                        
                        const repoElement = ignoredFileTree.querySelector(`.tree-repo[data-name="${repoName}"]`);
                        if (!repoElement) return;
                        
                        // Apply each expanded directory path
                        repoState.expansionState.forEach(path => {
                            applyExpansionPath(repoElement, path);
                        });
                    });
                }
            }, 100);
        }
        
        // Apply expansion to a specific path
        function applyExpansionPath(repoElement, path) {
            const segments = path.split('/');
            let currentElement = repoElement;
            
            // Navigate through segments to find the directory
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const dirElement = currentElement.querySelector(`.tree-directory[data-name="${segment}"]`);
                
                if (dirElement) {
                    dirElement.classList.add('expanded');
                    currentElement = dirElement;
                } else {
                    break;
                }
            }
        }
        
        // Update tree selection states bottom-up
        function updateTreeSelectionStates() {
            // Update both included and ignored trees
            
            // Update included files tree from bottom to top
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
                
                // Update tree UI to reflect new states
                updateTreeCheckboxes(fileTree, fileTreeData);
            }
            
            // Update ignored files tree from bottom to top
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    updateSelectionStatesBottomUp(repo);
                });
                
                // Update tree UI to reflect new states if the ignored tree is expanded
                if (!ignoredContent.classList.contains('hidden')) {
                    updateTreeCheckboxes(ignoredFileTree, ignoredTreeData);
                }
            }
            
            // Save selection state
            saveSelectionState();
        }
        
        // Update all checkboxes in a tree to match data model
        function updateTreeCheckboxes(treeContainer, treeData) {
            const checkboxes = treeContainer.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => {
                const parentElement = checkbox.closest('.tree-repo, .tree-directory, .tree-file');
                
                if (parentElement) {
                    // Find matching node in data
                    let node = null;
                    
                    if (parentElement.classList.contains('tree-repo')) {
                        const repoName = parentElement.dataset.name;
                        node = treeData.find(r => r.name === repoName);
                    }
                    else if (parentElement.classList.contains('tree-directory')) {
                        const dirName = parentElement.dataset.name;
                        const repoElement = parentElement.closest('.tree-repo');
                        if (repoElement) {
                            const repoName = repoElement.dataset.name;
                            const repo = treeData.find(r => r.name === repoName);
                            if (repo) {
                                // Find directory by name
                                node = findNodeByName(repo, dirName);
                            }
                        }
                    }
                    else if (parentElement.classList.contains('tree-file')) {
                        const filePath = parentElement.dataset.path;
                        const repoName = parentElement.dataset.repo;
                        if (repoName) {
                            const repo = treeData.find(r => r.name === repoName);
                            if (repo) {
                                // Find file by path
                                node = findNodeByPath(repo, filePath);
                            }
                        }
                    }
                    
                    // Update checkbox state to match data
                    if (node) {
                        applyCheckboxState(checkbox, node);
                    }
                }
            });
        }
        
        // Find a node by name in a tree
        function findNodeByName(root, name) {
            if (root.name === name) {
                return root;
            }
            
            if (root.children) {
                for (const child of Object.values(root.children)) {
                    const found = findNodeByName(child, name);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // Find a node by path in a tree
        function findNodeByPath(root, path) {
            if (root.path === path) {
                return root;
            }
            
            if (root.children) {
                for (const child of Object.values(root.children)) {
                    const found = findNodeByPath(child, path);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // Apply checkbox state based on node
        function applyCheckboxState(checkbox, node) {
            checkbox.checked = node.selected;
            
            if (node.indeterminate) {
                checkbox.indeterminate = true;
                checkbox.classList.add('indeterminate');
                checkbox.dataset.indeterminate = 'true';
            } else {
                checkbox.indeterminate = false;
                checkbox.classList.remove('indeterminate');
                checkbox.dataset.indeterminate = 'false';
            }
        }
        
        // Save selection state to localStorage
        function saveSelectionState() {
            if ((!fileTreeData || fileTreeData.length === 0) && 
                (!ignoredTreeData || ignoredTreeData.length === 0)) return;
            
            try {
                // Get current state for included and ignored files
                const state = {
                    included: {},
                    ignored: {}
                };
                
                // Save included files state
                if (fileTreeData && fileTreeData.length > 0) {
                    fileTreeData.forEach(repo => {
                        state.included[repo.name] = {
                            deselectedPaths: getNodeSelectionPaths(repo),
                            expansionState: getExpansionState(repo.name, false)
                        };
                    });
                }
                
                // Save ignored files state
                if (ignoredTreeData && ignoredTreeData.length > 0) {
                    ignoredTreeData.forEach(repo => {
                        state.ignored[repo.name] = {
                            selectedPaths: getNodeSelectionPaths(repo, '', true),
                            expansionState: getExpansionState(repo.name, true)
                        };
                    });
                }
                
                // Save to localStorage with a key that includes the repository paths
                const repoKey = selectedRepos.map(r => r.path).sort().join(',');
                localStorage.setItem(`repo_selection_${repoKey}`, JSON.stringify(state));
            } catch (e) {
                console.error('Error saving selection state:', e);
            }
        }
        
        // Restore selection state from localStorage on page load
        function restoreSelectionState() {
            try {
                if (!selectedRepos || selectedRepos.length === 0) return;
                
                // Generate key from repository paths
                const repoKey = selectedRepos.map(r => r.path).sort().join(',');
                const savedState = localStorage.getItem(`repo_selection_${repoKey}`);
                
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    // Convert old format to new format if needed (compatibility)
                    if (!state.included && !state.ignored) {
                        // Old format - convert to new format
                        const newState = {
                            included: {},
                            ignored: {}
                        };
                        
                        Object.keys(state).forEach(repoName => {
                            if (Array.isArray(state[repoName])) {
                                // Old format - just deselected paths for included files
                                newState.included[repoName] = {
                                    deselectedPaths: state[repoName],
                                    expansionState: []
                                };
                            } else {
                                // Newer format with nested structure but not separate included/ignored
                                newState.included[repoName] = state[repoName];
                            }
                        });
                        
                        // Apply the converted state
                        applySelectionState(newState);
                        applyExpansionState(newState);
                    } else {
                        // New format with separate included/ignored sections
                        applySelectionState(state);
                        applyExpansionState(state);
                    }
                    
                    // Re-render trees with updated selections
                    updateFileSummaryWithoutRender();
                }
            } catch (e) {
                console.error('Error restoring selection state:', e);
            }
        }
        
        // Update file summary without re-rendering the tree
        function updateFileSummaryWithoutRender() {
            // Calculate total files and selected files
            let totalIncludedFiles = 0;
            let totalSelectedFiles = 0;
            let totalIgnoredFiles = 0;
            let totalSelectedIgnoredFiles = 0;
            totalTokenCount = 0;
            let selectedTokenCount = 0;
            
            // Calculate included files stats
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    totalIncludedFiles += repo.fileCount;
                    totalTokenCount += repo.tokenCount;
                    selectedTokenCount += getSelectedTokenCount(repo);
                    totalSelectedFiles += getSelectedFileCount(repo);
                });
            }
            
            // Calculate ignored files stats
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    totalIgnoredFiles += repo.fileCount;
                    totalSelectedIgnoredFiles += getSelectedFileCount(repo);
                    // Add tokens from selected ignored files
                    selectedTokenCount += getSelectedTokenCount(repo);
                });
            }
            
            // Update counts
            includedCount.textContent = `${totalSelectedFiles} of ${totalIncludedFiles} files Â· ~${formatTokenCount(selectedTokenCount)} tokens`;
            ignoredCount.textContent = `${totalSelectedIgnoredFiles} of ${totalIgnoredFiles} files`;
            selectedReposCount.textContent = selectedRepos.length;

            // Update total tokens count above the Copy button
            const totalTokensCount = document.getElementById('total-tokens-count');
            if (totalTokensCount) {
                totalTokensCount.textContent = formatTokenCount(selectedTokenCount);
            }

            // Show the selected repos section
            selectedReposSummary.classList.remove('hidden');
            
            // Update the selected repos list
            updateSelectedReposList();
        }
        
        // Update file summary UI
        function updateFileSummary() {
            // Calculate total files and selected files
            let totalIncludedFiles = 0;
            let totalSelectedFiles = 0;
            let totalIgnoredFiles = 0;
            let totalSelectedIgnoredFiles = 0;
            totalTokenCount = 0;
            let selectedTokenCount = 0;

            // Calculate included files stats
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    totalIncludedFiles += repo.fileCount;
                    totalTokenCount += repo.tokenCount;
                    selectedTokenCount += getSelectedTokenCount(repo);
                    totalSelectedFiles += getSelectedFileCount(repo);
                });
            }
            
            // Calculate ignored files stats
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    totalIgnoredFiles += repo.fileCount;
                    totalSelectedIgnoredFiles += getSelectedFileCount(repo);
                    // Add tokens from selected ignored files
                    selectedTokenCount += getSelectedTokenCount(repo);
                });
            }

            // Update counts
            includedCount.textContent = `${totalSelectedFiles} of ${totalIncludedFiles} files Â· ~${formatTokenCount(selectedTokenCount)} tokens`;
            ignoredCount.textContent = `${totalSelectedIgnoredFiles} of ${totalIgnoredFiles} files`;
            selectedReposCount.textContent = selectedRepos.length;

            // Update total tokens count above the Copy button
            const totalTokensCount = document.getElementById('total-tokens-count');
            if (totalTokensCount) {
                totalTokensCount.textContent = formatTokenCount(selectedTokenCount);
            }

            // Show the selected repos section
            selectedReposSummary.classList.remove('hidden');

            // Update the selected repos list
            updateSelectedReposList();
        }

        // Show file preview
        function showFilePreview(file) {
            filePreviewFilename.textContent = `${file.name} (~${file.isIgnored ? "Unknown" : formatTokenCount(file.tokenCount || 0)} tokens)`;
            filePreviewCode.textContent = file.content || "Preview not available for ignored files";
            filePreviewModal.classList.add('visible');
        }
        
        // Close file preview
        function closeFilePreview() {
            filePreviewModal.classList.remove('visible');
        }
        
        // Search file tree
        function searchFileTree(query) {
            if (!query) {
                // Clear search
                resetTreeSearch();
                return;
            }
            
            const lowerQuery = query.toLowerCase();
            let foundAny = false;
            
            // Search in each repo
            const repoElements = fileTree.querySelectorAll('.tree-repo');
            repoElements.forEach(repoEl => {
                let foundInRepo = false;
                
                // Search files in this repo
                const fileElements = repoEl.querySelectorAll('.tree-file');
                fileElements.forEach(fileEl => {
                    const fileName = fileEl.dataset.name.toLowerCase();
                    const filePath = fileEl.dataset.path.toLowerCase();
                    
                    if (fileName.includes(lowerQuery) || filePath.includes(lowerQuery)) {
                        fileEl.style.display = 'flex';
                        highlightMatch(fileEl, lowerQuery);
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make sure parent directories are expanded and visible
                        let parent = fileEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else {
                        fileEl.style.display = 'none';
                    }
                });
                
                // Search directories
                const dirElements = repoEl.querySelectorAll('.tree-directory');
                dirElements.forEach(dirEl => {
                    const dirName = dirEl.dataset.name.toLowerCase();
                    const hasVisibleChildren = dirEl.querySelector('.tree-file[style*="display: flex"]');
                    
                    if (dirName.includes(lowerQuery)) {
                        // Highlight the directory name and make it visible
                        const nameElement = dirEl.querySelector('.tree-directory-name span:last-child');
                        nameElement.innerHTML = nameElement.textContent.replace(
                            new RegExp(lowerQuery, 'ig'),
                            match => `<span class="match-highlight">${match}</span>`
                        );
                        
                        // Show and expand the directory
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make parent directories visible and expanded
                        let parent = dirEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else if (hasVisibleChildren) {
                        // Directory has matching files, keep it visible and expanded
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                    } else if (!hasVisibleChildren && !dirName.includes(lowerQuery)) {
                        // Hide the directory if it neither matches nor has matching children
                        dirEl.style.display = 'none';
                    }
                });
                
                // Show/hide the entire repo based on matches
                if (foundInRepo) {
                    repoEl.style.display = 'block';
                    repoEl.classList.add('expanded');
                } else {
                    repoEl.style.display = 'none';
                }
            });
            
            // Show no results message if nothing found
            if (!foundAny) {
                if (!fileTree.querySelector('.tree-empty')) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.classList.add('tree-empty');
                    emptyMessage.innerHTML = `
                        <div class="tree-empty-icon">ğŸ”</div>
                        <p>No files match your search</p>
                    `;
                    fileTree.appendChild(emptyMessage);
                }
            } else {
                const emptyMessage = fileTree.querySelector('.tree-empty');
                if (emptyMessage) {
                    emptyMessage.remove();
                }
            }
        }
        
        // Search ignored file tree - nearly identical to searchFileTree but for ignored files
        function searchIgnoredFileTree(query) {
            if (!query) {
                // Clear search
                resetIgnoredTreeSearch();
                return;
            }
            
            const lowerQuery = query.toLowerCase();
            let foundAny = false;
            
            // Search in each repo
            const repoElements = ignoredFileTree.querySelectorAll('.tree-repo');
            repoElements.forEach(repoEl => {
                let foundInRepo = false;
                
                // Search files in this repo
                const fileElements = repoEl.querySelectorAll('.tree-file');
                fileElements.forEach(fileEl => {
                    const fileName = fileEl.dataset.name.toLowerCase();
                    const filePath = fileEl.dataset.path.toLowerCase();
                    
                    if (fileName.includes(lowerQuery) || filePath.includes(lowerQuery)) {
                        fileEl.style.display = 'flex';
                        highlightMatch(fileEl, lowerQuery);
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make sure parent directories are expanded and visible
                        let parent = fileEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else {
                        fileEl.style.display = 'none';
                    }
                });
                
                // Search directories
                const dirElements = repoEl.querySelectorAll('.tree-directory');
                dirElements.forEach(dirEl => {
                    const dirName = dirEl.dataset.name.toLowerCase();
                    const hasVisibleChildren = dirEl.querySelector('.tree-file[style*="display: flex"]');
                    
                    if (dirName.includes(lowerQuery)) {
                        // Highlight the directory name and make it visible
                        const nameElement = dirEl.querySelector('.tree-directory-name span:last-child');
                        nameElement.innerHTML = nameElement.textContent.replace(
                            new RegExp(lowerQuery, 'ig'),
                            match => `<span class="match-highlight">${match}</span>`
                        );
                        
                        // Show and expand the directory
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                        foundInRepo = true;
                        foundAny = true;
                        
                        // Make parent directories visible and expanded
                        let parent = dirEl.parentElement;
                        while (parent && !parent.classList.contains('tree-repo-content')) {
                            if (parent.classList.contains('tree-directory-content')) {
                                parent.parentElement.classList.add('expanded');
                                parent.style.display = 'block';
                            }
                            parent = parent.parentElement;
                        }
                    } else if (hasVisibleChildren) {
                        // Directory has matching files, keep it visible and expanded
                        dirEl.style.display = 'block';
                        dirEl.classList.add('expanded');
                    } else if (!hasVisibleChildren && !dirName.includes(lowerQuery)) {
                        // Hide the directory if it neither matches nor has matching children
                        dirEl.style.display = 'none';
                    }
                });
                
                // Show/hide the entire repo based on matches
                if (foundInRepo) {
                    repoEl.style.display = 'block';
                    repoEl.classList.add('expanded');
                } else {
                    repoEl.style.display = 'none';
                }
            });
            
            // Show no results message if nothing found
            if (!foundAny) {
                if (!ignoredFileTree.querySelector('.tree-empty')) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.classList.add('tree-empty');
                    emptyMessage.innerHTML = `
                        <div class="tree-empty-icon">ğŸ”</div>
                        <p>No ignored files match your search</p>
                    `;
                    ignoredFileTree.appendChild(emptyMessage);
                }
            } else {
                const emptyMessage = ignoredFileTree.querySelector('.tree-empty');
                if (emptyMessage) {
                    emptyMessage.remove();
                }
            }
        }
        
        // Highlight search matches
        function highlightMatch(element, query) {
            // Highlight in the file name
            const nameElement = element.querySelector('.tree-file-name');
            const originalText = nameElement.textContent;
            
            // Only replace in the text nodes to avoid messing up the extension styling
            const textNode = Array.from(nameElement.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
            const extNode = nameElement.querySelector('.tree-file-ext');
            
            if (textNode && originalText.toLowerCase().includes(query)) {
                const baseName = textNode.textContent;
                textNode.textContent = '';
                
                // Create a new span with highlighted text
                const newSpan = document.createElement('span');
                newSpan.innerHTML = baseName.replace(
                    new RegExp(query, 'ig'),
                    match => `<span class="match-highlight">${match}</span>`
                );
                
                // Insert the highlighted text before the extension
                nameElement.insertBefore(newSpan, extNode);
            }
            
            // Also check if the extension contains the query
            if (extNode && extNode.textContent.toLowerCase().includes(query)) {
                extNode.innerHTML = extNode.textContent.replace(
                    new RegExp(query, 'ig'),
                    match => `<span class="match-highlight">${match}</span>`
                );
            }
        }
        
        // Reset tree search
        function resetTreeSearch() {
            // Show all elements
            const allRepos = fileTree.querySelectorAll('.tree-repo');
            const allDirs = fileTree.querySelectorAll('.tree-directory');
            const allFiles = fileTree.querySelectorAll('.tree-file');
            
            allRepos.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allDirs.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allFiles.forEach(el => {
                el.style.display = 'flex';
                
                // Remove highlights
                const nameElement = el.querySelector('.tree-file-name');
                if (nameElement) {
                    nameElement.innerHTML = `${nameElement.textContent.split('.')[0]}<span class="tree-file-ext">.${nameElement.textContent.split('.')[1] || ''}</span>`;
                }
            });
            
            // Remove empty message if present
            const emptyMessage = fileTree.querySelector('.tree-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Re-expand first level directories if needed
            renderFileTree();
        }
        
        // Reset ignored tree search
        function resetIgnoredTreeSearch() {
            // Show all elements
            const allRepos = ignoredFileTree.querySelectorAll('.tree-repo');
            const allDirs = ignoredFileTree.querySelectorAll('.tree-directory');
            const allFiles = ignoredFileTree.querySelectorAll('.tree-file');
            
            allRepos.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allDirs.forEach(el => {
                el.style.display = 'block';
                el.classList.remove('expanded');
            });
            
            allFiles.forEach(el => {
                el.style.display = 'flex';
                
                // Remove highlights
                const nameElement = el.querySelector('.tree-file-name');
                if (nameElement) {
                    nameElement.innerHTML = `${nameElement.textContent.split('.')[0]}<span class="tree-file-ext">.${nameElement.textContent.split('.')[1] || ''}</span>`;
                }
            });
            
            // Remove empty message if present
            const emptyMessage = ignoredFileTree.querySelector('.tree-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Re-expand first level directories if needed
            renderIgnoredFileTree();
        }
        
        // Apply current search filter
        function applySearchFilter() {
            const query = treeSearchInput.value.trim();
            if (query) {
                searchFileTree(query);
            }
        }
        
        // Apply current search filter for ignored files
        function applyIgnoredSearchFilter() {
            const query = ignoredTreeSearchInput.value.trim();
            if (query) {
                searchIgnoredFileTree(query);
            }
        }
        
        // Get selected token count for a node (recursive)
        function getSelectedTokenCount(node) {
            if (node.type === 'file') {
                // Base case: file
                return node.selected ? (node.tokenCount || 0) : 0;
            }

            // If the directory/repo itself is completely deselected, return 0
            // (A node is completely deselected if selected is false and indeterminate is false)
            if (!node.selected && !node.indeterminate) {
                 return 0;
            }

            // Recursive case: directory or repo
            // If it's selected (fully or partially), always sum the selected token counts of its children.
            // This replaces the previous optimization which could return a stale node.tokenCount.
            let count = 0;
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    count += getSelectedTokenCount(child);
                });
            }
            return count;
        }
        
        // Get selected files from a node (recursive)
        function getSelectedFiles(node) {
            const files = [];
            
            if (node.type === 'file') {
                if (node.selected) {
                    files.push({
                        path: node.path,
                        content: node.content || ""
                    });
                }
                return files;
            }
            
            // For directories and repos, collect from all children
            if (node.children) {
                // Skip completely deselected directories/repos
                if (!node.selected && !node.indeterminate) {
                    return files;
                }
                
                Object.values(node.children).forEach(child => {
                    files.push(...getSelectedFiles(child));
                });
            }
            
            return files;
        }
        
        // Update the list of selected repositories
        function updateSelectedReposList() {
            selectedReposList.innerHTML = '';
            
            selectedRepos.forEach(repo => {
                // Find the corresponding repo in fileTreeData to get token count
                const repoData = fileTreeData.find(r => r.name === repo.name);
                const ignoredRepoData = ignoredTreeData.find(r => r.name === repo.name);
                
                const totalTokenCount = repoData ? repoData.tokenCount : 0;
                const selectedTokenCount = repoData ? getSelectedTokenCount(repoData) : 0;
                
                // Count tokens from selected ignored files
                const selectedIgnoredTokenCount = ignoredRepoData ? getSelectedTokenCount(ignoredRepoData) : 0;
                
                const totalFiles = (repoData ? repoData.fileCount : 0) + (ignoredRepoData ? ignoredRepoData.fileCount : 0);
                const selectedFiles = (repoData ? getSelectedFileCount(repoData) : 0) + 
                                      (ignoredRepoData ? getSelectedFileCount(ignoredRepoData) : 0);
                
                const repoItem = document.createElement('div');
                repoItem.classList.add('repo-item');
                repoItem.innerHTML = `
                    <span class="repo-name">ğŸ“‚ ${repo.name}</span>
                    <span class="repo-files">${selectedFiles} of ${totalFiles} files Â· ~${formatTokenCount(selectedTokenCount + selectedIgnoredTokenCount)} tokens</span>
                `;
                selectedReposList.appendChild(repoItem);
            });
        }
        // Copy to clipboard
        function copyToClipboard() {
            if (selectedRepos.length === 0) return;
            
            // Collect all selected files from both trees
            const selectedFilesData = [];
            
            // Get selected files from included files tree
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    const repoFiles = getSelectedFiles(repo);
                    
                    if (repoFiles.length > 0) {
                        // Find if this repo is already in selectedFilesData
                        let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                        
                        if (!repoEntry) {
                            repoEntry = {
                                name: repo.name,
                                path: selectedRepos.find(r => r.name === repo.name)?.path || '',
                                files: []
                            };
                            selectedFilesData.push(repoEntry);
                        }
                        
                        // Add files to this repo entry
                        repoEntry.files = repoEntry.files.concat(repoFiles);
                    }
                });
            }
            
            // Get selected files from ignored files tree
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    const ignoredRepoFiles = getSelectedFiles(repo);
                    
                    if (ignoredRepoFiles.length > 0) {
                        // Find if this repo is already in selectedFilesData
                        let repoEntry = selectedFilesData.find(r => r.name === repo.name);
                        
                        if (!repoEntry) {
                            repoEntry = {
                                name: repo.name,
                                path: selectedRepos.find(r => r.name === repo.name)?.path || '',
                                files: []
                            };
                            selectedFilesData.push(repoEntry);
                        }
                        
                        // Add ignored files to this repo entry
                        repoEntry.files = repoEntry.files.concat(ignoredRepoFiles);
                    }
                });
            }
            
            // Send only selected files to be copied
            axios.post('/api/copy-to-clipboard', { selectedRepos: selectedFilesData })
                .then(response => {
                    // Calculate total selected files
                    let totalFiles = 0;
                    selectedFilesData.forEach(repo => {
                        totalFiles += repo.files.length;
                    });
                    
                    showNotification(`ğŸ“‹ ${totalFiles} files from ${selectedFilesData.length} repositories copied to clipboard!`, 'success');
                })
                .catch(error => {
                    showNotification('Error copying to clipboard: ' + error.message, 'error');
                });
        }
        
        // Return to repository selection
        function backToRepoSelect() {
            // Hide step 3
            stepFileSummary.classList.add('hidden');
            
            // Re-enable step 2
            stepRepoSelect.classList.remove('disabled');
            
            // Make sure step 2 is visible
            stepRepoSelect.classList.remove('hidden');
            
            // Make sure checkboxes match the currently selected repos
            updateRepoCheckboxes();
        }
        
        // Update repo checkboxes to match current selections
        function updateRepoCheckboxes() {
            // Get all checkboxes
            const checkboxes = repoChecklist.querySelectorAll('input[type="checkbox"]');
            
            // Create a set of selected paths for quick lookup
            const selectedPaths = new Set(selectedRepos.map(repo => repo.path));
            
            // Update each checkbox
            checkboxes.forEach(checkbox => {
                const repoPath = checkbox.dataset.path;
                checkbox.checked = selectedPaths.has(repoPath);
            });
            
            // Update selection count
            updateSelectionCount();
        }
        
        // Refresh repository files
        function refreshRepositoryFiles() {
            if (selectedRepos.length === 0) {
                showNotification('No repositories to refresh', 'warning');
                return;
            }
            
            showNotification('ğŸ”„ Refreshing repository files...', 'info');
            
            // Create a loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.classList.add('loading-indicator');
            loadingIndicator.innerHTML = `
                <div class="spinner"></div>
                <p>Refreshing repositories...</p>
            `;
            selectedReposSummary.appendChild(loadingIndicator);
            
            // Disable buttons during refresh
            refreshButton.disabled = true;
            copyButton.disabled = true;
            
            // Save scroll positions before refresh
            const fileTreeScrollTop = fileTree.scrollTop;
            const ignoredTreeScrollTop = ignoredFileTree.scrollTop;
            
            // First, map all file paths to their current selection state for direct comparison
            const fileSelectionMap = {};
            const ignoredSelectionMap = {};
            
            // Save selection state for included files
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    collectFileSelections(repo, fileSelectionMap);
                });
            }
            
            // Save selection state for ignored files
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    collectFileSelections(repo, ignoredSelectionMap);
                });
            }
            
            // Also capture expansion state
            const expandedDirs = {};
            const expandedIgnoredDirs = {};
            
            // Save expansion state for included files
            if (fileTreeData && fileTreeData.length > 0) {
                fileTreeData.forEach(repo => {
                    expandedDirs[repo.name] = getExpansionState(repo.name, false);
                });
            }
            
            // Save expansion state for ignored files
            if (ignoredTreeData && ignoredTreeData.length > 0) {
                ignoredTreeData.forEach(repo => {
                    expandedIgnoredDirs[repo.name] = getExpansionState(repo.name, true);
                });
            }
            
            // Track completion for multiple repos
            let refreshedCount = 0;
            const tempSelectedRepos = [...selectedRepos];
            selectedRepos = [];
            fileTreeData = [];
            ignoredTreeData = [];
            
            // Process each repository
            tempSelectedRepos.forEach((repo, index) => {
                setTimeout(() => {
                    axios.post('/api/repo-files', { repoPath: repo.path })
                        .then(response => {
                            // Create updated repo object with fresh data
                            const updatedRepo = {
                                name: repo.name,
                                path: repo.path,
                                included: response.data.included,
                                ignored: response.data.ignored
                            };
                            
                            // Add to selected repos
                            selectedRepos.push(updatedRepo);
                            
                            // Build new included files tree with default selections
                            const repoTreeData = buildFileTree(updatedRepo.included, updatedRepo.name, false);
                            
                            // Apply saved selections to the included files tree
                            applyFileSelections(repoTreeData, fileSelectionMap);
                            
                            // Add to file tree data
                            fileTreeData.push(repoTreeData);
                            
                            // Build new ignored files tree with default selections (false for ignored files)
                            const repoIgnoredTreeData = buildFileTree(
                                updatedRepo.ignored.map(path => ({ path, content: "" })), 
                                updatedRepo.name, 
                                true
                            );
                            
                            // Apply saved selections to the ignored files tree
                            applyFileSelections(repoIgnoredTreeData, ignoredSelectionMap);
                            
                            // Add to ignored tree data
                            ignoredTreeData.push(repoIgnoredTreeData);
                            
                            // Update selection states from bottom to top
                            updateSelectionStatesBottomUp(repoTreeData);
                            updateSelectionStatesBottomUp(repoIgnoredTreeData);
                            
                            // Update progress
                            refreshedCount++;
                            
                            // If all repos are processed
                            if (refreshedCount === tempSelectedRepos.length) {
                                // Remove loading indicator
                                loadingIndicator.remove();
                                
                                // Render tree with applied selections
                                renderFileTree();
                                
                                // Render ignored tree if expanded
                                if (!ignoredContent.classList.contains('hidden')) {
                                    renderIgnoredFileTree();
                                }
                                
                                // Then restore expanded directories
                                setTimeout(() => {
                                    // Restore scroll position for included files
                                    fileTree.scrollTop = fileTreeScrollTop;
                                    
                                    // Apply saved expansion state to included files
                                    if (fileTreeData && fileTreeData.length > 0) {
                                        fileTreeData.forEach(repo => {
                                            if (expandedDirs[repo.name] && expandedDirs[repo.name].length > 0) {
                                                const repoElement = fileTree.querySelector(`.tree-repo[data-name="${repo.name}"]`);
                                                if (repoElement) {
                                                    // Expand the repo itself
                                                    repoElement.classList.add('expanded');
                                                    
                                                    // Apply saved expansion state to each directory
                                                    expandedDirs[repo.name].forEach(path => {
                                                        applyExpansionPath(repoElement, path);
                                                    });
                                                }
                                            }
                                        });
                                    }
                                    
                                    // Restore scroll position for ignored files if expanded
                                    if (!ignoredContent.classList.contains('hidden')) {
                                        ignoredFileTree.scrollTop = ignoredTreeScrollTop;
                                        
                                        // Apply saved expansion state to ignored files
                                        if (ignoredTreeData && ignoredTreeData.length > 0) {
                                            ignoredTreeData.forEach(repo => {
                                                if (expandedIgnoredDirs[repo.name] && expandedIgnoredDirs[repo.name].length > 0) {
                                                    const repoElement = ignoredFileTree.querySelector(`.tree-repo[data-name="${repo.name}"]`);
                                                    if (repoElement) {
                                                        // Expand the repo itself
                                                        repoElement.classList.add('expanded');
                                                        
                                                        // Apply saved expansion state to each directory
                                                        expandedIgnoredDirs[repo.name].forEach(path => {
                                                            applyExpansionPath(repoElement, path);
                                                        });
                                                    }
                                                }
                                            });
                                        }
                                    }
                                }, 50);
                                
                                // Enable buttons
                                refreshButton.disabled = false;
                                copyButton.disabled = false;
                                
                                // Save the new selection state to localStorage
                                saveSelectionState();
                                
                                showNotification('âœ… All repositories refreshed successfully!', 'success');
                            }
                        })
                        .catch(error => {
                            console.error('Error refreshing repository:', error);
                            showNotification(`Error refreshing repository ${repo.name}: ${error.message}`, 'error');
                            
                            // Re-add the original repo to prevent data loss
                            selectedRepos.push(repo);
                            
                            refreshedCount++;
                            
                            // If all repos are processed
                            if (refreshedCount === tempSelectedRepos.length) {
                                loadingIndicator.remove();
                                refreshButton.disabled = false;
                                copyButton.disabled = false;
                                renderFileTree();
                            }
                        });
                }, index * 300); // Stagger requests to avoid overwhelming the server
            });
        }
        
        // Collect file selection states directly by path for accurate mapping
        function collectFileSelections(node, selectionMap) {
            if (node.type === 'file') {
                // Store the selection state by full path for files
                selectionMap[node.path] = node.selected;
            }
            
            // Recursively process children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    collectFileSelections(child, selectionMap);
                });
            }
        }
        
        // Apply file selection states directly to the new tree
        function applyFileSelections(node, selectionMap) {
            if (node.type === 'file' && node.path in selectionMap) {
                // Apply saved selection state to this file
                node.selected = selectionMap[node.path];
            }
            
            // Recursively process children
            if (node.children) {
                Object.values(node.children).forEach(child => {
                    applyFileSelections(child, selectionMap);
                });
            }
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            notificationMessage.textContent = message;
            notification.className = 'notification';
            notification.classList.add(`notification-${type}`);
            notification.classList.remove('hidden');
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                notification.classList.add('hidden');
            }, 3000);
        }
        
        // Socket.io events
        socket.on('scan_start', (data) => {
            // Nothing needed here, loading indicator already shown
        });
        
        socket.on('scan_complete', (data) => {
            pathLoading.classList.add('hidden');
            
            // Store available repos
            availableRepos = data.repos.map((repo, index) => ({
                id: `repo-${index}`,
                name: repo.name,
                path: repo.path
            }));
            
            // Clear previous checkboxes
            repoChecklist.innerHTML = '';
            
            // Reset selections
            selectedRepoIds = [];
            updateSelectionCount();
            
            // Populate the checklist
            availableRepos.forEach(repo => {
                const item = document.createElement('div');
                item.classList.add('repo-checkbox-item');
                item.innerHTML = `
                    <input type="checkbox" id="${repo.id}" data-path="${repo.path}" />
                    <label for="${repo.id}">ğŸ“‚ ${repo.name}</label>
                `;
                repoChecklist.appendChild(item);
                
                // Add event listener to checkbox
                const checkbox = item.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        // Add to selected repos
                        if (!selectedRepoIds.includes(repo.id)) {
                            selectedRepoIds.push(repo.id);
                        }
                    } else {
                        // Remove from selected repos
                        const index = selectedRepoIds.indexOf(repo.id);
                        if (index !== -1) {
                            selectedRepoIds.splice(index, 1);
                        }
                    }
                    updateSelectionCount();
                });
            });
            
            if (availableRepos.length > 0) {
                // Disable step 1
                stepPathSelect.classList.add('disabled');
                
                // Show step 2
                stepRepoSelect.classList.remove('hidden');
            } else {
                showNotification('No repositories found in the selected path', 'warning');
            }
        });
        
        socket.on('error', (data) => {
            pathLoading.classList.add('hidden');
            showNotification(data.message, 'error');
        });
        
        // Event listeners
        scanButton.addEventListener('click', scanRepositories);
        browseButton.addEventListener('click', () => directoryInput.click()); // Trigger the hidden file input
        directoryInput.addEventListener('change', handleDirectorySelection);
        loadReposButton.addEventListener('click', loadSelectedRepositories);
        backToPathButton.addEventListener('click', backToPathSelection);
        copyButton.addEventListener('click', copyToClipboard);
        refreshButton.addEventListener('click', refreshRepositoryFiles);
        backToSelectButton.addEventListener('click', backToRepoSelect);
        
        // File preview events
        filePreviewClose.addEventListener('click', closeFilePreview);
        filePreviewModal.addEventListener('click', (e) => {
            if (e.target === filePreviewModal) {
                closeFilePreview();
            }
        });
        
        // Search events for included files
        treeSearchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            searchFileTree(query);
        });
        
        treeSearchClear.addEventListener('click', () => {
            treeSearchInput.value = '';
            resetTreeSearch();
        });
        
        // Search events for ignored files
        ignoredTreeSearchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            searchIgnoredFileTree(query);
        });
        
        ignoredTreeSearchClear.addEventListener('click', () => {
            ignoredTreeSearchInput.value = '';
            resetIgnoredTreeSearch();
        });
        
        notificationClose.addEventListener('click', () => {
            notification.classList.add('hidden');
        });
        
        // Load paths on page load
        loadPaths();
        
        // Add event listener for page load to restore selection state
        window.addEventListener('load', function() {
            // If we have selectedRepos data but no selection state in memory,
            // try to restore from localStorage
            if (selectedRepos && selectedRepos.length > 0 && 
                ((fileTreeData && fileTreeData.length > 0) || 
                 (ignoredTreeData && ignoredTreeData.length > 0))) {
                restoreSelectionState();
            }
        });
    });
</script>

<style>
    /* Ignored files section styles */
    .ignored-files-section {
        margin-top: 1.5rem;
    }
    
    .ignored-header {
        cursor: pointer;
    }
    
    .expand-collapse-btn {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
        margin-left: 0.5rem;
    }
    
    .expand-collapse-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .ignored-content {
        padding-top: 1rem;
    }
</style>
{% endblock %}