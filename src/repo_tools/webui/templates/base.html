<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Repo Tools{% endblock %}</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo.svg') }}" type="image/svg+xml">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    
    <!-- File System Access API Manager -->
    <script>
        // Global file handling system for client-side file operations
        window.FileSystemManager = {
            // Check browser support
            isSupported: function() {
                return 'showDirectoryPicker' in window;
            },
            
            getBrowserSupport: function() {
                if ('showDirectoryPicker' in window) {
                    return 'full';
                } else if ('webkitdirectory' in HTMLInputElement.prototype) {
                    return 'partial';
                } else {
                    return 'none';
                }
            },
            
            // Directory selection with fallback
            selectDirectory: async function() {
                const support = this.getBrowserSupport();
                
                if (support === 'full') {
                    try {
                        const dirHandle = await window.showDirectoryPicker({
                            mode: 'readwrite'
                        });
                        return await this.processDirectoryHandle(dirHandle);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            throw new Error('Directory selection cancelled');
                        }
                        throw error;
                    }
                } else if (support === 'partial') {
                    return await this.fallbackDirectorySelect();
                } else {
                    throw new Error('Directory selection not supported in this browser');
                }
            },
            
            // Fallback for browsers without File System Access API
            fallbackDirectorySelect: async function() {
                return new Promise((resolve, reject) => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.webkitdirectory = true;
                    input.multiple = true;
                    input.style.display = 'none';
                    
                    input.onchange = (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length > 0) {
                            resolve(this.processFileList(files));
                        } else {
                            reject(new Error('No files selected'));
                        }
                        document.body.removeChild(input);
                    };
                    
                    input.oncancel = () => {
                        reject(new Error('Directory selection cancelled'));
                        document.body.removeChild(input);
                    };
                    
                    document.body.appendChild(input);
                    input.click();
                });
            },
            
            // Process directory handle from File System Access API
            processDirectoryHandle: async function(dirHandle) {
                const files = [];
                const repos = [];
                
                async function* getFilesRecursively(entry, path = '') {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        yield {path: path + entry.name, file, handle: entry};
                    } else if (entry.kind === 'directory') {
                        const newPath = path + entry.name + '/';
                        if (entry.name === '.git') {
                            repos.push(path);
                        }
                        for await (const handle of entry.values()) {
                            yield* getFilesRecursively(handle, newPath);
                        }
                    }
                }
                
                for await (const fileData of getFilesRecursively(dirHandle, '')) {
                    files.push(fileData);
                }
                
                return {
                    files,
                    repos: this.extractReposFromPaths(repos),
                    directoryHandle: dirHandle
                };
            },
            
            // Process file list from webkitdirectory
            processFileList: function(fileList) {
                const files = [];
                const repos = new Set();
                
                fileList.forEach(file => {
                    const path = file.webkitRelativePath || file.name;
                    files.push({
                        path: path,
                        file: file
                    });
                    
                    // Check for .git directory
                    if (path.includes('/.git/')) {
                        const repoPath = path.substring(0, path.indexOf('/.git/'));
                        repos.add(repoPath);
                    }
                });
                
                return {
                    files,
                    repos: this.extractReposFromPaths(Array.from(repos))
                };
            },
            
            // Extract repository information from paths
            extractReposFromPaths: function(repoPaths) {
                return repoPaths.map(path => ({
                    name: path.split('/').pop() || 'unnamed',
                    path: path,
                    files: []
                }));
            },
            
            // Find Git repositories in files
            findGitRepositories: function(files) {
                const repos = new Map();
                
                files.forEach(fileData => {
                    const path = fileData.path;
                    if (path.includes('/.git/')) {
                        const repoPath = path.substring(0, path.indexOf('/.git/'));
                        if (!repos.has(repoPath)) {
                            repos.set(repoPath, {
                                name: repoPath.split('/').pop(),
                                path: repoPath,
                                files: []
                            });
                        }
                        // Add file to repository (excluding .git directory contents)
                        const relPath = path.substring(repoPath.length + 1);
                        if (!relPath.startsWith('.git/')) {
                            repos.get(repoPath).files.push(fileData);
                        }
                    }
                });
                
                return Array.from(repos.values());
            },
            
            // Read file content
            readFileContent: async function(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            },
            
            // Filter repository files (match server-side logic)
            filterRepoFiles: async function(files, options = {}) {
                const {
                    includeExtensions = null,
                    excludeExtensions = [],
                    maxFileSize = 10 * 1024 * 1024, // 10MB
                    followGitignore = true
                } = options;
                
                // Common files to ignore
                const commonIgnores = [
                    /node_modules\//,
                    /\.git\//,
                    /\.vscode\//,
                    /\.idea\//,
                    /__pycache__\//,
                    /\.pyc$/,
                    /\.pyo$/,
                    /\.DS_Store$/,
                    /Thumbs\.db$/,
                    /\.identifier$/  // File System Access API permission tracking file
                ];
                
                const filtered = [];
                
                for (const fileData of files) {
                    const path = fileData.path;
                    const file = fileData.file;
                    
                    // Skip if file is too large
                    if (file.size > maxFileSize) continue;
                    
                    // Skip common ignores
                    if (commonIgnores.some(regex => regex.test(path))) continue;
                    
                    // Check extensions
                    const ext = path.split('.').pop().toLowerCase();
                    if (includeExtensions && !includeExtensions.includes(ext)) continue;
                    if (excludeExtensions.includes(ext)) continue;
                    
                    filtered.push(fileData);
                }
                
                return filtered;
            },
            
            // Check if file is binary
            isBinaryFile: function(file) {
                const binaryExtensions = [
                    'jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg',
                    'mp3', 'mp4', 'avi', 'mov', 'wav',
                    'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
                    'zip', 'tar', 'gz', 'rar', '7z',
                    'exe', 'dll', 'so', 'dylib',
                    'bin', 'dat', 'db'
                ];
                
                const ext = file.name.split('.').pop().toLowerCase();
                return binaryExtensions.includes(ext) || 
                       file.type.startsWith('image/') || 
                       file.type.startsWith('video/') || 
                       file.type.startsWith('audio/');
            }
        };
        
        // Universal clipboard function for all tools
        window.ClipboardManager = {
            // Copy text to clipboard
            async copyText(text) {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(text);
                        return true;
                    } else {
                        // Fallback for older browsers
                        const textArea = document.createElement('textarea');
                        textArea.value = text;
                        textArea.style.position = 'fixed';
                        textArea.style.opacity = '0';
                        document.body.appendChild(textArea);
                        textArea.select();
                        const success = document.execCommand('copy');
                        document.body.removeChild(textArea);
                        return success;
                    }
                } catch (error) {
                    console.error('Clipboard error:', error);
                    return false;
                }
            },
            
            // Format repository content for clipboard
            formatRepositoryContent(repositories) {
                let formattedContent = "";
                
                // Add file tree structure
                formattedContent += "FILE TREE STRUCTURE:\\n";
                formattedContent += "=" + "=".repeat(79) + "\\n\\n";
                
                let totalFiles = 0;
                
                for (const repo of repositories) {
                    const files = repo.files || repo.included || [];
                    const selectedFiles = files.filter(f => f.selected !== false);
                    totalFiles += selectedFiles.length;
                    
                    formattedContent += `${repo.name}\\n`;
                    formattedContent += `${selectedFiles.length} files\\n\\n`;
                    
                    // Build simple tree structure
                    for (const file of selectedFiles) {
                        formattedContent += `‚îú‚îÄ‚îÄ ${file.path}\\n`;
                    }
                    formattedContent += "\\n";
                }
                
                formattedContent += "=" + "=".repeat(79) + "\\n\\n";
                
                // Add file contents
                for (const repo of repositories) {
                    formattedContent += `REPOSITORY: ${repo.name}\\n`;
                    formattedContent += "=" + "=".repeat(79) + "\\n\\n";
                    
                    const files = repo.files || repo.included || [];
                    for (const file of files) {
                        if (file.selected !== false) {
                            formattedContent += `${file.path}:\\n${file.content || ''}\\n\\n`;
                        }
                    }
                }
                
                return formattedContent;
            },
            
            // Copy repositories to clipboard
            async copyRepositories(repositories) {
                const content = this.formatRepositoryContent(repositories);
                const success = await this.copyText(content);
                
                if (success) {
                    const totalFiles = repositories.reduce((sum, repo) => {
                        const files = repo.files || repo.included || [];
                        return sum + files.filter(f => f.selected !== false).length;
                    }, 0);
                    return `Copied ${totalFiles} files from ${repositories.length} repositories to clipboard`;
                } else {
                    throw new Error('Failed to copy to clipboard');
                }
            }
        };
        
        // Browser compatibility warning
        document.addEventListener('DOMContentLoaded', function() {
            const support = window.FileSystemManager.getBrowserSupport();
            
            if (support === 'none') {
                console.warn('File directory selection is not supported in this browser. Please use Chrome, Edge, or a compatible browser for full functionality.');
            } else if (support === 'partial') {
                console.info('Using legacy directory selection. For best experience, please use Chrome or Edge.');
            }
        });
    </script>
    
    {% block extra_head %}{% endblock %}
</head>
<body>
    <canvas id="matrix-canvas" class="matrix-background"></canvas>
    <div class="app">
        <header>
            <div class="logo">
                <a href="/" style="text-decoration: none; color: inherit; display: inline-block; transition: transform 0.2s ease-in-out;">
                    <h1>üõ†Ô∏è Repo Tools</h1>
                </a>
                <style>
                    .logo a:hover {
                        transform: scale(1.05);
                    }
                    .logo a:active {
                        transform: scale(0.98);
                    }
                    
                    /* Matrix background styling */
                    .matrix-background {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        z-index: -1;
                        pointer-events: none;
                        opacity: 0.8;
                    }
                    
                    /* Ensure the app container has proper z-index to appear above matrix */
                    .app {
                        position: relative;
                        z-index: 1;
                        background: transparent;
                    }
                </style>
            </div>
            <nav>
                <ul>
                    <li><a href="/" {% if request.path == '/' %}class="active"{% endif %}>Home</a></li>
                    <li><a href="/local-repo" {% if request.path == '/local-repo' %}class="active"{% endif %}>Local Repository</a></li>
                    <li><a href="/github-repo" {% if request.path == '/github-repo' %}class="active"{% endif %}>GitHub Repository</a></li>
                    <li><a href="/xml-parser" {% if request.path == '/xml-parser' %}class="active"{% endif %}>XML Parser</a></li>
                    <li><a href="/settings" {% if request.path == '/settings' %}class="active"{% endif %}>Settings</a></li>
                </ul>
            </nav>
        </header>
        
        <main>
            {% block content %}{% endblock %}
        </main>
        
        <footer>
            <p>&copy; {{ current_year }} Repo Tools</p>
        </footer>
    </div>
    
    {% block scripts %}{% endblock %}
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize default matrix values if they don't exist in localStorage
            if (localStorage.getItem('matrixEffectEnabled') === null) {
                localStorage.setItem('matrixEffectEnabled', true);
            }
            if (localStorage.getItem('matrixSpeed') === null) {
                localStorage.setItem('matrixSpeed', '0.22');
            }
            if (localStorage.getItem('matrixDensity') === null) {
                localStorage.setItem('matrixDensity', '0.5');
            }
            if (localStorage.getItem('matrixFontSize') === null) {
                localStorage.setItem('matrixFontSize', '0.8');
            }
            if (localStorage.getItem('matrixColor') === null) {
                localStorage.setItem('matrixColor', 'green');
            }
            
            // Check local storage for matrix effect preference
            const matrixEnabled = localStorage.getItem('matrixEffectEnabled') !== 'false';
            
            // Matrix effect
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            
            // Show/hide matrix effect based on preference
            if (!matrixEnabled) {
                canvas.style.display = 'none';
            }
            
            // Set canvas dimensions to window size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Matrix effect configuration - brighter and more noticeable
            const matrix = {
                fontSize: parseFloat(localStorage.getItem('matrixFontSize')),
                characters: "„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥",
                drops: [],
                columns: 0,
                fallSpeed: localStorage.getItem('matrixSpeed'),
                density: localStorage.getItem('matrixDensity'),
                colorTheme: localStorage.getItem('matrixColor'),
                colors: {
                    green: {
                        leading: 'rgba(112, 255, 117, [opacity])',
                        trail: 'rgba(34, 90, 36, [opacity])',
                        glow: '#4caf5030'
                    },
                    white: {
                        leading: 'rgba(255, 255, 255, [opacity])',
                        trail: 'rgba(180, 180, 180, [opacity])',
                        glow: '#ffffff30'
                    },
                    neon: {
                        leading: 'rgba(88, 181, 255, [opacity])',
                        trail: 'rgba(30, 82, 148, [opacity])',
                        glow: '#0077ff30'
                    },
                    // Rainbow and random are handled in getColors()
                },
                animationId: null,
                frameCount: 0,
                maxDrops: 1000 // Will be calculated based on density
            };
            
            // Function to get colors based on current theme
            function getColors(j, drop) {
                const opacity = (10 - j) / 10;
                const trailOpacity = (opacity * 0.7);
                
                if (matrix.colorTheme === 'rainbow') {
                    // Each column gets a different color on the rainbow
                    const hue = (drop.column * 37) % 360; // Distribute colors
                    return {
                        leading: `hsla(${hue}, 100%, 70%, ${opacity})`,
                        trail: `hsla(${hue}, 70%, 40%, ${trailOpacity})`,
                        glow: `hsla(${hue}, 100%, 50%, 0.3)`
                    };
                } else if (matrix.colorTheme === 'random') {
                    // Random color for each drop
                    return {
                        leading: `hsla(${drop.colorHue}, 100%, 70%, ${opacity})`,
                        trail: `hsla(${drop.colorHue}, 70%, 40%, ${trailOpacity})`,
                        glow: `hsla(${drop.colorHue}, 100%, 50%, 0.3)`
                    };
                } else {
                    // Standard theme
                    const theme = matrix.colors[matrix.colorTheme] || matrix.colors.green;
                    return {
                        leading: theme.leading.replace('[opacity]', opacity),
                        trail: theme.trail.replace('[opacity]', trailOpacity),
                        glow: theme.glow
                    };
                }
            }
            
            // Calculate font size from slider value
            function calculateFontSize() {
                const sliderValue = parseFloat(matrix.fontSize);
                return Math.max(4, Math.pow(sliderValue, 3) * 40 + 4);
            }
            
            // Create a single drop
            function createDrop(column, yPos = null) {
                // Random character
                const character = matrix.characters.charAt(Math.floor(Math.random() * matrix.characters.length));
                
                // Start with random position - use different ranges to create more randomness
                // Sometimes start above screen, sometimes on screen
                const startPosition = yPos !== null 
                    ? yPos 
                    : (Math.random() > 0.7 
                        ? Math.random() * (canvas.height / calculateFontSize()) // Already on screen
                        : -Math.random() * 10); // Above screen with random offset
                
                // Random fall speed variation factor (0.7-1.3) to create desynchronized movement
                const speedFactor = 0.7 + Math.random() * 0.6;
                
                if (matrix.colorTheme === 'random') {
                    return {
                        column: column,
                        position: startPosition,
                        character: character,
                        colorHue: Math.floor(Math.random() * 360),
                        active: true,
                        speedFactor: speedFactor,
                        // Random update frequency - makes some characters change more often than others
                        updateFrequency: Math.random() > 0.7 ? 0.05 : 0.01
                    };
                } else {
                    return {
                        column: column,
                        position: startPosition,
                        character: character,
                        active: true,
                        speedFactor: speedFactor,
                        updateFrequency: Math.random() > 0.7 ? 0.05 : 0.01
                    };
                }
            }
            
            // Initialize drops array
            function initDrops() {
                // Clear previous drops
                matrix.drops = [];
                
                const actualFontSize = calculateFontSize();
                matrix.columns = Math.floor(canvas.width / actualFontSize);
                
                // Calculate max drops based on density (cubic function for dramatic effect)
                // Density 0.1 = very few, Density 1.0 = lots of drops
                const rawDensity = parseFloat(matrix.density) || 0.3;
                const scaledDensity = Math.pow(rawDensity, 3);
                
                // Calculate how many drops we should have based on screen size and density
                const screenArea = canvas.width * canvas.height;
                const maxPossibleDrops = Math.floor(screenArea / (actualFontSize * actualFontSize * 5)); 
                matrix.maxDrops = Math.max(10, Math.min(5000, Math.ceil(maxPossibleDrops * scaledDensity)));
                
                // Create initial drops - distribute randomly across columns and heights
                // We'll start with a full distribution to avoid the "wave" effect
                const initialDrops = Math.ceil(matrix.maxDrops * 0.8); 
                
                // First pass - ensure every column has at least one drop to avoid clumping
                for (let i = 0; i < matrix.columns; i++) {
                    if (Math.random() < scaledDensity) { // Only place initial drops based on density
                        const randomHeight = Math.random() * canvas.height / actualFontSize;
                        matrix.drops.push(createDrop(i, randomHeight));
                    }
                }
                
                // Second pass - add remaining drops with completely random distribution
                const remainingDrops = initialDrops - matrix.drops.length;
                for (let i = 0; i < remainingDrops; i++) {
                    const randomColumn = Math.floor(Math.random() * matrix.columns);
                    const randomHeight = Math.random() * canvas.height / actualFontSize;
                    matrix.drops.push(createDrop(randomColumn, randomHeight));
                }
            }
            
            initDrops();
            window.addEventListener('resize', initDrops);
            
            // Draw function
            function draw() {
                // Clear the canvas completely on each frame to prevent color build-up
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Increment frame counter (used for rainbow mode)
                matrix.frameCount++;
                
                const actualFontSize = calculateFontSize();
                
                // Track active drops to maintain proper density
                let activeDrops = 0;
                
                // Process all drops
                for (let i = 0; i < matrix.drops.length; i++) {
                    if (!matrix.drops[i].active) continue;
                    
                    activeDrops++;
                    const drop = matrix.drops[i];
                    const yPos = Math.floor(drop.position * actualFontSize);
                    
                    // Randomly change the character sometimes to create more visual entropy
                    if (Math.random() < drop.updateFrequency) {
                        drop.character = matrix.characters.charAt(Math.floor(Math.random() * matrix.characters.length));
                    }
                    
                    // Draw a trail of the same character with fading intensity
                    for (let j = 0; j < 10; j++) {
                        // Calculate trail position (characters above the current position)
                        const trailPos = yPos - (j * actualFontSize);
                        
                        // Skip if outside canvas
                        if (trailPos < 0) continue;
                        
                        // Get colors for this position
                        const colors = getColors(j, drop);
                        
                        // Leading character (brightest)
                        if (j === 0) {
                            ctx.fillStyle = colors.leading;
                            ctx.shadowBlur = 2;
                            ctx.shadowColor = colors.glow;
                        } 
                        // Trail characters (with fading intensity)
                        else {
                            ctx.fillStyle = colors.trail;
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.font = Math.round(actualFontSize) + 'px monospace';
                        ctx.fillText(drop.character, drop.column * actualFontSize, trailPos);
                    }
                    
                    // Apply speed calculation with individual variation for more randomness
                    const speedMultiplier = parseFloat(matrix.fallSpeed);
                    // For super high speeds (values 0.5-1.0), use a moderately aggressive calculation
                    // Old formula had extreme speeds at max value
                    let baseSpeed;
                    if (speedMultiplier > 0.5) {
                        // Reduced the multiplier by half to make it less extreme
                        baseSpeed = Math.pow(speedMultiplier, 3) * 1250;
                    } else {
                        // Keep original calculation for lower speeds
                        baseSpeed = Math.pow(speedMultiplier, 5) * 100;
                    }
                    const actualSpeed = baseSpeed * drop.speedFactor;
                    drop.position += actualSpeed;
                    
                    // Reset drop if it reaches the bottom - with completely random timing
                    if (yPos > canvas.height) {
                        // Either recycle the drop or create a new one in a random column
                        // Use very random rules to avoid synchronized waves
                        
                        // Reset vertical position - sometimes with a random delay above screen
                        drop.position = -Math.random() * 5; // Random start position above screen
                        
                        // Assign a new random character when resetting
                        drop.character = matrix.characters.charAt(Math.floor(Math.random() * matrix.characters.length));
                        
                        // Sometimes change columns for more horizontal variation
                        if (Math.random() > 0.6) {
                            drop.column = Math.floor(Math.random() * matrix.columns);
                        }
                        
                        // Change speed factor for next iteration
                        drop.speedFactor = 0.7 + Math.random() * 0.6;
                        
                        // New random color for random theme
                        if (matrix.colorTheme === 'random') {
                            drop.colorHue = Math.floor(Math.random() * 360);
                        }
                        
                        // Rarely deactivate a drop if we have too many
                        if (activeDrops > matrix.maxDrops && Math.random() > 0.9) {
                            drop.active = false;
                        }
                    }
                }
                
                // Add new drops much more randomly
                const rawDensity = parseFloat(matrix.density) || 0.3;
                const dropsNeeded = matrix.maxDrops - activeDrops;
                
                // Add drops one by one with random chance proportional to density and need
                // This creates a more natural, continuous rain effect
                const addChance = (dropsNeeded / matrix.maxDrops) * rawDensity;
                
                // Add drops randomly based on density
                if (Math.random() < addChance) {
                    // First check if we can reactivate an inactive drop
                    let reactivated = false;
                    
                    if (Math.random() > 0.5) { // 50% chance to try reactivation vs. new drop
                        for (let j = 0; j < matrix.drops.length; j++) {
                            if (!matrix.drops[j].active) {
                                matrix.drops[j].active = true;
                                matrix.drops[j].position = -Math.random() * 5; // Random start above screen
                                matrix.drops[j].column = Math.floor(Math.random() * matrix.columns);
                                matrix.drops[j].character = matrix.characters.charAt(Math.floor(Math.random() * matrix.characters.length));
                                matrix.drops[j].speedFactor = 0.7 + Math.random() * 0.6;
                                
                                if (matrix.colorTheme === 'random') {
                                    matrix.drops[j].colorHue = Math.floor(Math.random() * 360);
                                }
                                
                                reactivated = true;
                                break;
                            }
                        }
                    }
                    
                    // If no inactive drops found or chose not to reactivate, create a new one
                    if (!reactivated && matrix.drops.length < matrix.maxDrops * 1.2) {
                        const column = Math.floor(Math.random() * matrix.columns);
                        matrix.drops.push(createDrop(column));
                    }
                }
                
                // Performance optimization: limit the array size if it grows too large
                if (matrix.drops.length > matrix.maxDrops * 2) {
                    // Remove inactive drops to prevent array from growing too large
                    matrix.drops = matrix.drops.filter(drop => drop.active);
                }
                
                if (matrixEnabled) {
                    matrix.animationId = requestAnimationFrame(draw);
                }
            }
            
            // Start animation if enabled
            if (matrixEnabled) {
                draw();
            }
            
            // Function to toggle matrix effect with optional settings
            window.toggleMatrixEffect = function(enabled, settings = {}) {
                if (settings) {
                    // Update matrix settings
                    if (settings.speed !== undefined) {
                        matrix.fallSpeed = settings.speed;
                    }
                    if (settings.density !== undefined) {
                        matrix.density = settings.density;
                        // Reinitialize drops with new density
                        initDrops();
                    }
                    if (settings.color !== undefined) {
                        matrix.colorTheme = settings.color;
                    }
                    if (settings.fontSize !== undefined) {
                        // Apply new font size
                        matrix.fontSize = settings.fontSize;
                        // Reinitialize drops as font size affects column count
                        resizeCanvas();
                        initDrops();
                    }
                }
                
                if (enabled) {
                    canvas.style.display = 'block';
                    if (!matrix.animationId) {
                        draw();
                    }
                } else {
                    canvas.style.display = 'none';
                    if (matrix.animationId) {
                        cancelAnimationFrame(matrix.animationId);
                        matrix.animationId = null;
                    }
                }
                
                localStorage.setItem('matrixEffectEnabled', enabled);
            };
        });
    </script>
</body>
</html>